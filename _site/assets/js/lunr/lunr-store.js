var store = [{
        "title": "Cpp Tutorial #1",
        "excerpt":"서문   안녕하세요.   C++ 강좌를 연재하게 된 김종혁이라고 합니다.   예상 독자   이 강좌의 예상 독자는 프로그래밍 입문자분들이나 초보자분들입니다.   배경   평소에 컴퓨터를 좋아하기도 하고, 주변에서 컴퓨터를 잘한다는 소리를 들으면서 자라온 저는 비전공자임에도 이 분야에 조금이나마 기여를 하고자 이 글을 작성하는 것입니다. 또한 주변 친구들의 프로그래밍 과제를 도와주면서 그들이 겪었던 어려움들을 다른 분들께 알려드릴 수 있다면 조금이나마 도움이 되시지 않을까 하는 바람에 작성하는 것입니다. 마지막으로 비전공자임에도 이 분야에 대한 열정을 가지고 열심히만 한다면 전공자 못지 않게 컴퓨터를 잘할 수 있음을 증명하기 위해 작성하는 것입니다.   의의   이 강좌의 의의에 대해서는 필자가 백번을 말한다 한들 의미가 없음을 독자 여러분들께서는 잘 아시리라 믿습니다. 직접 강좌를 읽어보시고 강좌의 중요성이나 가치에 대해서 스스로 한번씩 생각해보시면 제가 말씀드리는 답보다 더 좋은 답을 얻으실 수 있으리라 생각됩니다.   마지막으로 드리고 싶은 말씀   이 강좌를 읽어보시고 마음에 안드시는 부분이나 내용, 그리고 잘못된 부분들이 있다면 댓글로 남겨주시면 감사드리겠습니다.   비판은 언제든지 환영입니다. 다만 악플은 가급적 지양해주시면 감사드리겠습니다. 이 글은 한 분만 읽는 것이 아님을 알아주셨으면 좋겠습니다.   C++란 무엇인가?   위키피디아에 내용이 잘 정리된 듯하여 일부를 발췌하였습니다.   C++ is a general-purpose programming language created by Bjarne Stroustrup as an extension of the C programming language, or “C with Classes”.   C++은 C 프로그래밍 언어의 확장 즉, 클래스를 가진 C 언어로서 BjarneStroustrup에 의해 만들어진 범용 프로그래밍 언어이다.   The language has expanded significantly over time, and modern C++ now has object-oriented, generic, and functional features in addition to facilities for low-level memory manipulation.   C++는 시간이 지남에 따라 눈에 띄게 확장되어 왔으며 지금의 C++는 저수준 메모리 조작에 대한 편리함에 더해 객체지향, 제네릭과 함수형의 특징들을 지닌다.   출처   위 글을 통해서 우리는 C++가 C의 확장이며, C++이 C보다 다양하고 많은 특징들을 지니고 있음을 알 수 있습니다.   (시간이 되신다면 위 출처 링크를 타고 들어가셔서 나머지 부분을 읽어보시면 도움이 많이 되실 것 같습니다.)   어떻게 C++로 프로그램을 작성할 수 있나요?   C++로 프로그램을 작성하기 위해서는 여러분의 컴퓨터에 몇 가지 소프트웨어를 설치해야하지만 사실 이것을 설명하다보면 배보다 배꼽이 더 커지는 격이 되버리기 때문에 이것에 대한 설명은 별도의 포스팅이나 유튜브 영상으로 대체하도록 하겠습니다.   요즘에는 온라인 상에서도 손쉽게 코드를 작성할 수 있으므로 필자는 이곳을 이용하도록 하겠습니다.   접속을 해보시면 왼쪽 분할된 영역에 이미 코드가 다음과 같이 작성되어 있음을 확인하실 수 있으실 겁니다.   // Online C++ compiler to run C++ program online #include &lt;iostream&gt;  int main() {     // Write C++ code here     std::cout &lt;&lt; \"Hello world!\";      return 0; }   그리고 Run이라고 적혀있는 파란색 버튼을 눌러보시면 오른쪽 분할된 영역에 Hello world!라는 문자열이 화면에 출력됨을 확인하실 수 있으실 겁니다.   아니 그래서 이게 뭐하는건데요?   여러분은 이미 프로그램 하나를 완성하셨습니다. 축하드립니다~!      아니 아직 뭐 작성한것도 없는데 프로그램을 완성했다니요!?    방금 여러분은 미리 작성되어 있던 코드를 Run이라는 버튼을 누름으로써 컴파일이라는 과정을 통해 C++ 코드가 기계어로 변환되었으며 실행결과로 Hello world!라는 문자열이 오른쪽 화면에 출력되는 하나의 프로그램이 완성되는 일련의 과정을 보신거랍니다. 즉, 여러분은 C++로 프로그램 하나를 완성한 것이나 다름 없는것이죠.      그럼 앞으로 그냥 사이트만 다시 들어와서 Run 버튼만 누르면 되는건가요?    아니죠! 여러분은 C++의 문법들을 조합하여 컴퓨터에게 일련의 과정이 명시된 명령들을 내려줘야 합니다.   C++의 문법들을 배워보기 전에 우선은 C++의 기본 문법부터 하나씩 살펴보자구요.   C++의 기본 문법   왼쪽에 분할된 영역에 있었던 코드에서 확인하셨다시피 C++은 다음과 같은 기본 꼴을 지니고 있습니다.   #include &lt;iostream&gt;  int main() {   std::cout&lt;&lt;\"\";    return 0; }   기본 문법이기 때문에 지금 잘 숙지해두시면 앞으로도 계속 반복되는 패턴이 보이실테니 공부하실 때 조금은 편하실 겁니다.   코드에서 첫번째 줄을 보시면  #include &lt;iostream&gt;   이는 iostream이라는 헤더파일을 포함하라는 의미입니다.      헤더파일이요? 그건 뭐고 왜 포함을 해야하나요?…    여러분의 질문에 대한 답변은 뒤에서 드리도록 하겠습니다.   그 다음 줄에는 다음과 같은 코드가 있습니다.   (다음 줄에는 int main()만 있지만, main의 한 몸체가 중괄호의 시작부터 끝이기 때문에 하나로 묶었습니다.)   int main() {  }   이는 main 함수로서 운영체제가 C++ 프로그램을 실행시킬 때 가장 먼저 찾는 함수이며 가장 먼저 실행시키는 함수입니다.   그러므로 반드시 C++로 작성된 프로그램이라면 main함수가 존재해야 합니다.   그 다음 줄에는  std::cout&lt;&lt;\"\";  이 있으며, 이는 화면에 큰 따옴표 내에 있는 문자열을 출력하라는 의미의 함수입니다.   (cout가 함수이며, std는 이름공간입니다. 이름공간은 뒤에서 자세히 다룰 예정)      우리가 함수를 정의하지도 않았는데 어떻게 cout라는 함수를 사용할 수 있는것인가요?    이는 여러분께서 주셨던 헤더파일에 대한 질문의 답이 될 수 있을 것 같습니다.   아마 대부분 눈치 채셨겠지만, 우리가 iostream이라는 헤더파일을 포함시킬 수 밖에 없었던 이유는 바로 cout라는 함수를 사용하기 위해서입니다.   cout는 우리가 직접 만들지 않은 이미 만들어져 나온 함수로서 iostream에 정의가 되어있습니다. 즉, 우리는 그냥 iostream만 포함시키면 cout라는 함수 외에도 그 안에 들어있는 여러 가지 함수들을 사용할 수 있는것이죠.      그럼 헤더파일도 종류가 엄청 많겠군요.    그렇습니다.   그 기능과 종류별로 다양한 헤더파일이 존재하는 것이죠.   뒤에서 더 자세히 알아보겠지만(미리 스포를 하자면) 우리가 직접 헤더파일을 만들 수도 있습니다.   즉, 어떤 기능을 담은 헤더파일 하나를 만들어서 공유를 하게 된다면 다른 사람들이 직접 그 기능을 만들 필요없이 그냥 그 파일만 다운 받아서 include만 시킨다면 곧바로 사용할 수 있으니 엄청 편한 것이라 할 수 있겠습니다.   마지막으로   return 0;      0을 왜 반환해야 하나요?    이는 메인 함수에서 프로그램이 종료되거나 반환할 때 프로그램이 정상적으로 실행되었음을 알리기 위해서입니다. 그래서 0이라는 정수 대신에 EXIT_SUCCESS라는 매크로를 입력해서 다음과 같이 코드를 작성하셔도 무리가 없습니다.(매크로도 추후 설명 예정)   return EXIT_SUCCESS;  // EXIT_SUCCESS는 0을 나타냄.   그렇다면 1을 반환하게 되면 어떻게 될까요?   return 1;  위 코드는 0을 반환했을 때와는 반대로 프로그램이 정상적으로 실행되지 않았음을 알리기 위한 목적을 지니고 있으며, 보통은 컴파일러가 지나치는 경우가 대부분이지만 표준 C라든지 일부 민감한 컴파일러에서는 경고 메시지를 띄울 수도 있습니다.   위 코드는 다음과 같이 작성할 수도 있습니다.   return EXIT_FAILURE;  ","categories": ["C++"],
        "tags": ["Programming"],
        "url": "http://localhost:4000/c++/Cpp-Tutorial-1/",
        "teaser": null
      },{
        "title": "Cpp Tutorial #1.1",
        "excerpt":"기본문법 부연   지난 시간에 C++의 기본 문법에 대해서 알아보았습니다.   하지만 아직 여러 가지 의문점이 남아있으실 듯 하여 조금 더 부연설명을 드리고자 이 강좌를 준비해보았습니다.      제가 C언어를 공부했을 때는 #include 문에서 헤더파일 확장자에 .h를 붙였는 데 왜 C++에서는 확장자를 붙이지 않는 것인가요?    C++에서는 표준 헤더파일의 선언에서 확장자를 생략하기로 약속을 했기 때문에 별도의 확장자를 헤더파일의 끝에 붙이지 않아도 되는 것입니다.      표준 헤더파일이요? 그게 뭐죠?    단순히 말씀드리면 표준 라이브러리 내에 들어있는 헤더파일을 표준 헤더파일이라고 합니다.   표준 라이브러리에 대해서 조금 더 궁금하신 분이 계실 듯 하여 설명을 드리겠습니다. 이를 위해 위키백과에서 일부 내용을 발췌하였습니다.   In the C++ programming language, the C++ Standard Library is a collection of classes and functions, which are written in the core language and part of the C++ ISO Standard itself.   C++ 프로그래밍 언어에서 C++ 표준 라이브러리는 클래스와 함수들의 집합인데 이는 핵심 언어 내부에 작성되며 C++ ISO 표준의 일부이다.   즉, 표준 라이브러리는 C++ ISO 표준의 일부로서 사전에 제공되는 클래스와 함수들의 집합입니다.   단순하게 표준 라이브러리는 사전에 미리 제공되는 헤더파일이라는 책들이 구비되어 있는 커다란 도서관이라고 생각하시면 될 것 같습니다.      std::cout« 에서 «은 무엇인가요?    «은 스트림 출력을 의미하는 streaming 연산자입니다.   사실 이것에 대해서 뒤에서 더 자세히 설명을 드리려 했지만 여기서 간략히만 말씀을 드리도록 하겠습니다.   C언어에서 «은 비트 단위 시프트 연산자로서 그 역할을 충분히 해내고 있습니다.   그런데 참 이상합니다.   그럼 C++에서는 왜 이것을 cout라는 함수와 같이 사용을 하는 것일까요?   여기서도 비트 단위 시프트 연산자의 역할을 그대로 수행하고 있는 것인지 의문이 생깁니다.   그런데 사실 이에 대한 답은 연산자 오버로딩과 관련이 있습니다.   (오버로딩에 대해서는 추후 설명 예정)   즉, cout 함수를 개발한 개발자들은 입력 함수인 cout에 비트 단위 연산자의 역할 대신 출력할 때 사용하는 새로운 역할을 부여해 놓은 것입니다.   그런데 왜 이러한 기능들이 필요한 것인지에 대해서 의문이 생깁니다.   하지만 이에 대한 답은 잠시 연산자 오버로딩 강좌로 미뤄두도록 하겠습니다.      다음과 같이 여러 개로 cout 함수를 나눠서 출력하는 것이 너무 불편한 데 이에 대한 해결책이 있나요?    #include &lt;iostream&gt;  int main() {   std::cout&lt;&lt;\"Hello \";   std::cout&lt;&lt;\"World! \";   std::cout&lt;&lt;\"Hello \";   std::cout&lt;&lt;\"Cpp!\";    return 0;   }   네 있습니다.   다음처럼 « 연산자를 연이어서 사용할 수 있습니다.   #include &lt;iostream&gt;  int main() {   std::cout&lt;&lt;\"Hello \"&lt;&lt;\"World! \"&lt;&lt;\"Hello \"&lt;&lt;\"Cpp!\";    return 0; }  ","categories": ["C++"],
        "tags": ["Programming"],
        "url": "http://localhost:4000/c++/Cpp-Tutorial-2/",
        "teaser": null
      },{
        "title": "Double Integrals in Polar Coordinates",
        "excerpt":"본 게시물은 개인적으로 미분적분학을 공부하기 위해 포스팅함을 사전에 말씀드립니다. (오류가 있을 시 댓글로 말씀해주시면 감사드리겠습니다.)   Example 1   Evaluate \\(\\iint_R (3x+4y^2) \\,dA\\), where R is the region in the upper half-plane bounded by the circles \\(x^2+y^2=1\\) and \\(x^2+y^2=4\\)         Example 2   Find the volume of the solid bounded by the plane \\(z=0\\) and the parabo-loid \\(z=1-x^2-y^2\\)            Example 3   Use a double integral to find the area enclosed by one loop of the four-leaved rose \\(r=\\cos(2\\theta)\\)         Example 4   Find the volume of the solid that lies under the paraboloid \\(z=x^2+y^2\\), above the xy-plane, and inside the cylinder \\(x^2+y^2=2x\\)            ","categories": ["Calculus"],
        "tags": ["Calculus"],
        "url": "http://localhost:4000/calculus/Double-Integrals-in-Polar-Coordinates/",
        "teaser": null
      },{
        "title": "gotoxy(), clrscr(), getch(), and getche() functions for GCC Linux.",
        "excerpt":"gotoxy() for GCC Linux  // gotoxy() function definition void gotoxy(int x, int y) {   printf(\"%c[%d;%df\", 0x1B, y, x); }   #include &lt;stdio.h&gt;  // gotoxy() function definition void gotoxy(int x, int y) {     printf(\"%c[%d;%df\", 0x1B, y, x); }  int main() {     int x=10, y=20;     gotoxy(x, y); // move cursor position      printf(\"Hello World!!!\"); // print message     return 0; }   clrscr() for GCC Linux   // clrscr() function definition void clsrscr(void) {   system(\"clear\"); }   #include &lt;stdio.h&gt;  // clrscr() function definition void clrscr(void) {   system(\"clear\"); }  int main() {   clrscr();   printf(\"Hello World!!!\");    return 0; }   getch() and getche() for GCC Linux   #include &lt;termios.h&gt; #include &lt;stdio.h&gt;  static struct termios old, new;  void initTermios(int echo) {   tcgetattr(0, &amp;old);   new = old;   new.c_lflag &amp;= ~ICANON;   new.c_lflag &amp;= echo ? ECHO : ~ECHO;   tcsetattr(0, TCSANOW, &amp;new); }  void resetTermios(void) {   tcsetattr(0, TCSANOW, &amp;old); }  char getch_(int echo) {   char ch;   initTermios(echo);   ch = getchar();   resetTermios();    return ch; }  char getch(void) {   return getch_(0); }  char getche(void) {   return getch_(1); }  int main(void) {   char c;   printf(\"(getche example) Please enter a character: \");   c = getche();   printf(\"\\nYou entered: %c\\n\", c);   printf(\"(getch example) Please enter a character: \");   c = getch();   printf(\"\\nYou entered: %c\\n\", c);    return 0; }   출처: includehelp   ","categories": ["C"],
        "tags": ["Programming"],
        "url": "http://localhost:4000/c/FromTurboCToGCC/",
        "teaser": null
      },{
        "title": "C언어 과제: 평균 구하는 함수 작성",
        "excerpt":"문제   괄호 안에 알맞은 코드를 작성하시오.   double average() {   ();    t = (a+b) / (2*1.0);    return t; }  int main() {   int a, b, tot;   double avg;    avg = average(a, b);    printf(); }   아래의 해설을 보지 마시고, 최대한 고민해서 이 문제를 풀어보시기 바랍니다.   해설   이 문제에서처럼 코드가 사전에 작성되어 있는 문제의 경우에는 다음의 사실(fact)을 알고 접근하시면   실제 시험에 이 문제가 출제되었을 때 신속하게 문제풀이를 진행하실 수 있습니다.      “C언어에서 코드 실행의 시발점은 main 함수이기 때문에, 가장 먼저 main 함수 내의 코드부터 위에서 아래로 차근차근 분석해나가야 한다.”       위에서 아래로 분석을 하는 이유는 C언어가 절차적인 특성을 지니기 때문입니다.   언뜻 보기엔 특별해보일 것이 없음에도 사실 가장 중요한 지침이라 할 수 있습니다.   그러므로 main 함\b수부터 살펴봅시다.   int main() {   int a, b, tot;   double avg;    avg = average(a, b);    printf(); }   main 함수에는 처음에 다음의 코드가 등장합니다.   int a, b, tot;   이 코드는 3개의 정수형 변수 a, b, tot를 선언하는 문장이며,   변수의 이름과 자료형만 확인하시고 바로 아래 코드로 내려가시면 되겠습니다.   그 아래 코드는 다음과 같으며,   double avg;   자료형은 double이고 변수의 이름은 avg인 실수형 변수를 선언하는 구문입니다.   avg = average(a, b);   위 코드부터 본격적으로 main 함수에서 하나의 기능을 수행하는 함수 average로의 이동이 수반되므로, 이전 코드들에 비해 그 중요도가 상승한다고 볼 수 있겠습니다.   위 코드에서 먼저 average(a, b);의 구문부터 수행하는 데,   double average() {  }   average 함수에 인자를 전달받을 수 있는 매개변수의 선언이 존재하지 않으므로, 먼저 매개변수부터 선언을 해줘야 합니다.   매개변수의 선언 역시 변수의 선언과 다르지 않기 때문에, 변수 선언과 동일한 방식으로 진행하시면 되겠습니다.           인자(Argument): 어떤 함수 호출 시 전달하는 값            매개변수(Parameter): 전달된 인자를 받아들이는 변수       단, 해당 함수에서 Call by Reference, Call by Value 중 어느 방식으로 인자를 전달받아 기능을 수행하였는지를 먼저 확인해야 하므로,   average 함수의 내부를 살펴볼 필요가 있습니다.   double average() {   ();    t = (a+b) / (2*1.0);    return t; }   위 코드를 보시면 아시겠지만, 함수 내부에서 포인터 연산이 진행되고 있지 않다는 사실로 미루어 보아 Call by Value로 인자를 전달받아 처리함을 알 수 있습니다.   그러므로 매개변수의 선언부는 다음과 같이 두 개의 정수형 인자(이름은 각각 a와 b)를 전달받을 수 있도록 작성해주시면 되겠습니다.      매개변수의 이름이 각각 a와 b여야 하는 이유는 average 함수 내에서 다음의 연산이 진행되고 있기 때문입니다.    t = (a+b) / (2*1.0);   위의 a와 b는 우리가 선언한 적이 없는 변수들이기 때문에 매개변수를 a, b로 각각 선언하게 되면 average 함수 내에서 이 변수들의 값들을 이용하게 될 것입니다.   또한 t 역시 우리가 선언하지 않은 변수이기 때문에 이것 역시 선언을 해줘야 합니다.   그런데 해당 코드의 위 코드를 보시면 괄호로 작성되어 있으므로, 이곳에 t 변수의 선언문이 위치하면 문제없이 해당 코드를 수행하게 될 것입니다.   t 변수는 정수형 변수 a와 b를 더한 후 (2*1.0)의 값으로 나눠주고 있는데, 나누는 값에 1.0이라는 실수가 들어있으므로 t 변수의 자료형은 실수형이 되어야 합니다.   실수 자료형의 대표격은 double이므로 이 자료형을 사용하여 t 변수의 선언문을 작성해주시면 되겠습니다.   그러므로 average 함수의 코드는 다음과 같습니다.   double average(int a, int b) {   double t;    t = (a+b) / (2*1.0);    return t; }   위의 average 함수에서 return 문을 제외한 나머지 구문들이 모두 정상 수행되었다는 가정 하에 마지막의 return 문을 수행하면,   t 값을 이 함수를 호출한 곳으로 보내면서 이 함수는 종료가 됩니다.   이 함수를 호출한 곳은 main 함수이므로 t에 저장되어 있는 값을 가지고 다시 main 함수로 이동하시면 됩니다.   main 함수에서는 다음의 구문이 존재하므로,   avg = average(a, b);   average에서 반환한 t 값은 avg라는 변수에 저장될 것입니다.   이제 마지막으로 아래의 괄호 안에 내용을 작성해주시면 되는데, average라는 함수는 인자로 보낸 두 값의 평균을 산출하여 그 값을 반환하였고,   결국에 avg에 그 값이 들어갔으므로 이 avg 값을 출력해주면 평균 값을 확인할 수 있을 것입니다.   그런데 avg 역시 double형이므로 서식문자인 %f를 사용하여 값을 출력해주면 되겠습니다.   printf(\"%f\\n\", avg);   코드의 잘못된 부분이나, 궁금한 점이 있으시다면 댓글 남겨주시면 감사드리겠습니다.  ","categories": ["C"],
        "tags": ["Programming"],
        "url": "http://localhost:4000/c/Problem-Solving-in-C-1/",
        "teaser": null
      },{
        "title": "Python 과제: 입력 및 출력",
        "excerpt":"문제   실행결과가 다음과 같이 되도록 프로그램을 작성하시오.      아래의 해설을 보지 마시고, 최대한 고민해서 이 문제를 풀어보시기 바랍니다.   해설   우선 직관적으로 이 문제를 보신 후에는 반자동적으로 파란색 박스와 빨간색 박스가 무엇을 의미하는지를 파악하셔야 합니다.   또한 파란색 박스와 빨간색 박스 각각에 동일한 문법(Syntax)이 들어가는지도 파악하셔야 합니다.   여기까지 문제에서 필요한 부분들을 추출하셨다면, 바로 문제풀이에 들어가시면 됩니다.   먼저 파란색 박스를 보시면 아시겠지만, 물음에 대한 답변을 해야합니다.   그런데 그 답변은 딱 정해진 답이 아닌 사용자에 따라서 천차만별로 달라질 수 있는 답입니다.   그러므로 답변에 대한 답을 얻을 때는 사용자가 그 답을 입력하는 방식으로 진행하는 것이 좋을것 같습니다.      파이썬에서 입력을 받기 위해서는 어떤 문법을 사용해야할까요?    input() 함수를 사용해야 하며, 문법 구조는 다음과 같습니다.   Syntax     input(prompt)           여기서 prompt는 사용자로부터 입력을 받기 전에 기본적으로 표시되는 메시지 즉, 문자열입니다.            문법 구조에서 명시되지는 않았지만, 사용자로부터 입력을 받았다면 입력 받은 값을 저장할 변수가 필요합니다. 왜냐하면 사용자로부터 입력 받은 값을 변수를 통해서 이용할 수 있기 때문입니다.       그러므로 다음과 같이 변수도 함께 작성해주셔야 합니다.   x = input()   여기까지 기본적인 input 함수 사용법에 대해서 알아보았습니다.   그럼 이제 문제를 풀어보면서 위의 설명이 의미하는 바를 이해해봅시다.   먼저 문제를 보시면, 문제의 첫번째 줄에서 ““당신의 이름은 무엇인가요?”“가 화면에 출력되어야 하고, 그 이후에 사용자로부터 입력을 받아야 함을 알 수 있습니다.   그런데 출력에 필요한 별도의 함수(print())를 이용해서 화면에 출력할 수도 있지만, 위의 설명에서처럼 input 함수의 인자로 건네준 문자열이 사용자로부터 입력을 받기 전에 기본적으로 표시되므로 다음처럼 작성하면 됨을 알 수 있습니다.   input(\"당신의 이름은 무엇인가요?\")   또한, 위의 설명에서처럼 사용자로부터 입력받은 값을 별도의 변수에 저장해야 이를 이용할 수 있으므로, 변수도 함께 작성해주셔야 합니다.   변수의 이름은 아무래도 의미있는 이름이면 좋겠죠?   그러므로 저는 변수명을 name으로 작성하겠습니다.   name = input(\"당신의 이름은 무엇인가요?\")   여기까지 하셨다면, 문제의 첫 번째 줄은 해결하였습니다.   이번에는 두 번째 줄로 넘어가봅시다.   빨간색 네모 박스를 보시면 아시겠지만 이는 사용자로부터 입력받은 사용자의 이름을 출력해줘야 함을 알 수 있습니다.   그런데 우리는 위에서 사용자로부터 입력받은 이름 값을 name이라는 변수에 저장하였으므로, 이 변수의 값을 단순히 불러들여서 출력만 해주면 됨을 알 수 있습니다.      파이썬에서 출력을 담당하는 문법은 무엇일까요?    이는 print() 함수이며, 문법 구조는 다음과 같습니다.   Syntax   print(object(s), sep=separator, end=end, file=file, flush=flush)           여기서 object(s)는 필수적으로 전달하여야 하는 인자이며, 그 이름이 의미하듯이 어떠한 객체든 그 수에 상관없이 전달할 수 있으며, 이러한 객체들은 출력되기 전에 모두 문자열로 변환됩니다.            sep=’separator’는 선택적이며, 객체들이 2개 이상이라면 이들을 구분짓는 방법을 명시한다. 기본값은 ‘ ‘이다.            end=’end’는 선택적이며, 끝에 무엇을 출력할지를 명시한다. 기본값은 ‘\\n’(개행)이다.            file은 선택적이며, 쓰기 메소드를 가진 객체이다. 기본값은 sys.stdout이다.            flush는 선택적이며, 부울 값인데 True는 flushed를 False는 buffered를 의미한다. 기본값은 False이다.       이 문제를 풀이하는 데 있어서 객체와 구분자를 제외한 다른 인자들은 필요치 않으므로, 다른 강좌에서 이들을 설명하고자 합니다.   print 함수를 이용하여 name 변수의 값을 여러 방법으로 출력할 수 있는데 다음과 같습니다.   방법 1   print(\"%s씨는 로또를 사려고 하는군요. 1등 당첨될 확률을 알려드리겠습니다.\" % (name))   방법 2   print(name, \"씨는 로또를 사려고 하는군요. 1등 당첨될 확률을 알려드리겠습니다.\")   방법 3   print(\"{}씨는 로또를 사려고 하는군요. 1등 당첨될 확률을 알려드리겠습니다.\".format(name))   방법 4   print(name + \"씨는 로또를 사려고 하는군요. 1등 당첨될 확률을 알려드리겠습니다.\")   방법 5   print(f\"{name}씨는 로또를 사려고 하는군요. 1등 당첨될 확률을 알려드리겠습니다.\")   이 중에서 여러분의 입맛에 맞는 방식을 선택하면 됩니다.   여기까지 하셨다면, 이 문제의 두 번째 줄도 해결하셨습니다. :grin:   세 번째 줄과 네 번째 줄은 동일한 방식으로 작성하므로 한 번에 다루도록 하겠습니다.   세 번째 줄과 네 번째 줄 모두 변수명과 프롬프트만 수정해주시면 되는데, 이번에는 한 가지 사실을 아셔야 합니다.   그것은 바로 input 함수가 반환하는 값이 string 즉, 문자열이라는 것입니다.   그런데 도대체 이게 왜 중요한 것일까요?   이 물음에 대한 답을 찾기 위해 다섯 번째 줄로 가봅시다.   다섯 번째 줄의 두 번째 빈칸에서는 확률을 출력하고 있는데, 이는 세 번째 줄과 네 번째 줄에서 입력한 값들을 이용하여 연산을 진행하고 그 연산 결과를 출력해주면 해결할 수 있습니다.   그런데 문자열끼리 나눗셈을 진행할 수 있을까요?   불가능한 연산입니다.   문자열을 나눈다니요…   그렇기 때문에 우리는 input 함수에서 반환한 값을 형 변환해줘야 합니다.   즉, 기존 str 자료형을 숫자로 말이죠.   파이썬에서 형 변환을 하기 위해서는 다음의 형태로 작성하시면 됩니다.   Type Casting Form   type()      여기서 type은 자료형을 의미합니다. 즉 소괄호 안에 있는 값을 type에 지정한 자료형으로 변환하라는 의미입니다.   이것을 input에 활용해보면 다음과 같습니다.   Type Casting Application   type(input(prompt))   이렇게 작성을 하시면 input으로부터 반환된 값이 type에 지정한 자료형으로 변환이 됩니다.   마지막으로 변환된 값을 변수에 넣어주기만 하면 되겠죠?   Final Type Casting Application   variable = type(input(prompt))   설명한 내용을 바탕으로 세 번째 줄을 작성하면,   total_number_count = int(input('전체 숫자의 갯수는 몇개입니까?'))           type은 int로 작성을 하였는데, 갯수는 소수점이 없는 정수이기 때문입니다.            변수명은 꼭 total_number_count가 아니어도 되지만, 의미있는 이름으로 지어주세요. :blush:       마찬가지로 네 번째 줄 역시,   all_match_count = int(input('1등 당첨되기 위해 모두 맞아야 하는 숫자는 몇개인가요?'))           이것 역시 들어맞는 수가 소수점이 없는 정수이기 때문에 type을 int로 작성하였습니다.            변수명은 꼭 all_match_count가 아니어도 되지만, 의미있는 이름으로 지어주세요. :blush:       여기까지 하셨다면, 이 문제의 네 번째 줄까지 모두 해결하셨습니다. :clap::clap:   다섯 번째 줄로 넘어가봅시다.   이것 역시 두 번째 줄과 동일한 방식으로 작성을 해주시면 됩니다.   단, 이번에는 확률을 구하는 식을 작성해주고, 필요한 경우 서식문자까지 추가해주면 되겠군요.   방법 1   print(\"%s씨가 로또 1장을 샀을 때 1등에 당첨될 확률은 %f%%입니다.\" % (name, float(all_match_count)/total_number_count*100))           all_match_count 변수를 float로 형 변환을 시켜준 이유는 all_match_count와 total_number_count가 모두 정수형이기 때문에 나눗셈 연산의 결과가 정수형으로 나오기 때문입니다. 즉, 소수점 아래의 숫자들이 모두 날아가 버리는 것이죠. 그렇기에 all_match_count나 total_number_count 중 하나를 float로 형 변환을 해주게 되면 나눗셈 연산을 진행할 때 인터프리터가 float로 명시적 형 변환한 변수 외의 기존의 정수형 변수를 float로 자동 형 변환하여 나눗셈 연산의 결과가 float형이 될 수 있습니다. 즉, 소수점 아래의 숫자들이 보존될 수 있는 것이죠.            계산 결과가 실수이므로 서식문자 %f를 사용하였으며, 출력을 위한 %와 서식문자 앞의 %를 interpreter가 동일한 것으로 간주하기 때문에 %를 단순히 출력할 때에는 %를 두 번 작성하여야 합니다. 즉, %%       방법 2   print(name, \"씨가 로또 1장을 샀을 때 1등에 당첨될 확률은\", float(all_match_count)/total_number_count*100, \"%입니다.\")   방법 3   print(\"{}씨가 로또 1장을 샀을 때 1등에 당첨될 확률은 {}%입니다.\".format(name, float(all_match_count)/total_number_count*100))   방법 4   print(name + \"씨가 로또 1장을 샀을 때 1등에 당첨될 확률은 \" + str(float(all_match_count)/total_number_count*100) + \"%입니다.\")      이번에는 str로 형 변환을 해주었는데, 왜 이렇게 할 수 밖에 없었을까요? 왜냐하면 문자열과 문자열 사이의 +는 문자열끼리의 결합을 의미하는 데, str로 형 변환을 하지 않았을 경우 float 즉, 실수와 문자열에 대해서 + 연산을 진행한다는 것은 인터프리터 입장에서는 이해할 수 없었을 것입니다. 그렇기에 우리는 다시 한번 str로 형 변환을 진행하여 인터프리터가 + 연산의 의미를 이해할 수 있도록 해주어야 합니다.   방법 5   print(f\"{name}씨가 로또 1장을 샀을 때 1등에 당첨될 확률은 {float(all_match_count)/total_number_count*100}%입니다.\")   부족한 제 글 읽어주셔서 감사드립니다.   코드의 잘못된 부분이나, 궁금한 점이 있으시다면 댓글 남겨주시면 감사드리겠습니다.   ","categories": ["Python"],
        "tags": ["Programming","Python"],
        "url": "http://localhost:4000/python/Problem-Solving-in-C-2/",
        "teaser": null
      }]
