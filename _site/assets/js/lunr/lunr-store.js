var store = [{
        "title": "gotoxy(), clrscr(), getch(), and getche() functions for GCC Linux.",
        "excerpt":"gotoxy() for GCC Linux  // gotoxy() function definition void gotoxy(int x, int y) {   printf(\"%c[%d;%df\", 0x1B, y, x); }   #include &lt;stdio.h&gt;  // gotoxy() function definition void gotoxy(int x, int y) {     printf(\"%c[%d;%df\", 0x1B, y, x); }  int main() {     int x=10, y=20;     gotoxy(x, y); // move cursor position      printf(\"Hello World!!!\"); // print message     return 0; }   clrscr() for GCC Linux   // clrscr() function definition void clsrscr(void) {   system(\"clear\"); }   #include &lt;stdio.h&gt;  // clrscr() function definition void clrscr(void) {   system(\"clear\"); }  int main() {   clrscr();   printf(\"Hello World!!!\");    return 0; }   getch() and getche() for GCC Linux   #include &lt;termios.h&gt; #include &lt;stdio.h&gt;  static struct termios old, new;  void initTermios(int echo) {   tcgetattr(0, &amp;old);   new = old;   new.c_lflag &amp;= ~ICANON;   new.c_lflag &amp;= echo ? ECHO : ~ECHO;   tcsetattr(0, TCSANOW, &amp;new); }  void resetTermios(void) {   tcsetattr(0, TCSANOW, &amp;old); }  char getch_(int echo) {   char ch;   initTermios(echo);   ch = getchar();   resetTermios();    return ch; }  char getch(void) {   return getch_(0); }  char getche(void) {   return getch_(1); }  int main(void) {   char c;   printf(\"(getche example) Please enter a character: \");   c = getche();   printf(\"\\nYou entered: %c\\n\", c);   printf(\"(getch example) Please enter a character: \");   c = getch();   printf(\"\\nYou entered: %c\\n\", c);    return 0; }   출처: includehelp   ","categories": ["C"],
        "tags": ["Programming"],
        "url": "http://localhost:4000/c/FromTurboCToGCC/",
        "teaser": null
      },{
        "title": "C 과제: 평균 구하는 함수 작성",
        "excerpt":"문제   괄호 안에 알맞은 코드를 작성하시오.   double average() {   ();    t = (a+b) / (2*1.0);    return t; }  int main() {   int a, b, tot;   double avg;    avg = average(a, b);    printf(); }   아래의 해설을 보지 마시고, 최대한 고민해서 이 문제를 풀어보시기 바랍니다.   해설   이 문제에서처럼 코드가 사전에 작성되어 있는 문제의 경우에는 다음의 사실(fact)을 알고 접근하시면   실제 시험에 이 문제가 출제되었을 때 신속하게 문제풀이를 진행하실 수 있습니다.      “C언어에서 코드 실행의 시발점은 main 함수이기 때문에, 가장 먼저 main 함수 내의 코드부터 위에서 아래로 차근차근 분석해나가야 한다.”       위에서 아래로 분석을 하는 이유는 C언어가 절차적인 특성을 지니기 때문입니다.   언뜻 보기엔 특별해보일 것이 없음에도 사실 가장 중요한 지침이라 할 수 있습니다.   그러므로 main 함수부터 살펴봅시다.   int main() {   int a, b, tot;   double avg;    avg = average(a, b);    printf(); }   main 함수에는 처음에 다음의 코드가 등장합니다.   int a, b, tot;   이 코드는 3개의 정수형 변수 a, b, tot를 선언하는 문장이며,   변수의 이름과 자료형만 확인하시고 바로 아래 코드로 내려가시면 되겠습니다.   그 아래 코드는 다음과 같으며,   double avg;   자료형은 double이고 변수의 이름은 avg인 실수형 변수를 선언하는 구문입니다.   avg = average(a, b);   위 코드부터 본격적으로 main 함수에서 하나의 기능을 수행하는 함수 average로의 이동이 수반되므로, 이전 코드들에 비해 그 중요도가 상승한다고 볼 수 있겠습니다.   위 코드에서 먼저 c average(a, b);의 구문부터 수행하는 데,   double average() {  }   average 함수에 인자를 전달받을 수 있는 매개변수의 선언이 존재하지 않으므로, 먼저 매개변수부터 선언을 해줘야 합니다.   매개변수의 선언 역시 변수의 선언과 다르지 않기 때문에, 변수 선언과 동일한 방식으로 진행하시면 되겠습니다.           인자(Argument): 어떤 함수 호출 시 전달하는 값            매개변수(Parameter): 전달된 인자를 받아들이는 변수       단, 해당 함수에서 Call by Reference, Call by Value 중 어느 방식으로 인자를 전달받아 기능을 수행하였는지를 먼저 확인해야 하므로,   average 함수의 내부를 살펴볼 필요가 있습니다.   double average() {   ();    t = (a+b) / (2*1.0);    return t; }   위 코드를 보시면 아시겠지만, 함수 내부에서 포인터 연산이 진행되고 있지 않다는 사실로 미루어 보아 Call by Value로 인자를 전달받아 처리함을 알 수 있습니다.   그러므로 매개변수의 선언부는 다음과 같이 두 개의 정수형 인자(이름은 각각 a와 b)를 전달받을 수 있도록 작성해주시면 되겠습니다.      매개변수의 이름이 각각 a와 b여야 하는 이유는 average 함수 내에서 다음의 연산이 진행되고 있기 때문입니다.    t = (a+b) / (2*1.0);   위의 a와 b는 우리가 선언한 적이 없는 변수들이기 때문에 매개변수를 a, b로 각각 선언하게 되면 average 함수 내에서 이 변수들의 값들을 이용하게 될 것입니다.   또한 t 역시 우리가 선언하지 않은 변수이기 때문에 이것 역시 선언을 해줘야 합니다.   그런데 해당 코드의 위 코드를 보시면 괄호로 작성되어 있으므로, 이곳에 t 변수의 선언문이 위치하면 문제없이 해당 코드를 수행하게 될 것입니다.   t 변수는 정수형 변수 a와 b를 더한 후 (2*1.0)의 값으로 나눠주고 있는데, 나누는 값에 1.0이라는 실수가 들어있으므로 t 변수의 자료형은 실수형이 되어야 합니다.   실수 자료형의 대표격은 double이므로 이 자료형을 사용하여 t 변수의 선언문을 작성해주시면 되겠습니다.   그러므로 average 함수의 코드는 다음과 같습니다.   double average(int a, int b) {   double t;    t = (a+b) / (2*1.0);    return t; }   위의 average 함수에서 return 문을 제외한 나머지 구문들이 모두 정상 수행되었다는 가정 하에 마지막의 return 문을 수행하면,   t 값을 이 함수를 호출한 곳으로 보내면서 이 함수는 종료가 됩니다.   이 함수를 호출한 곳은 main 함수이므로 t에 저장되어 있는 값을 가지고 다시 main 함수로 이동하시면 됩니다.   main 함수에서는 다음의 구문이 존재하므로,   avg = average(a, b);   average에서 반환한 t 값은 avg라는 변수에 저장될 것입니다.   이제 마지막으로 아래의 괄호 안에 내용을 작성해주시면 되는데, average라는 함수는 인자로 보낸 두 값의 평균을 산출하여 그 값을 반환하였고,   결국에 avg에 그 값이 들어갔으므로 이 avg 값을 출력해주면 평균 값을 확인할 수 있을 것입니다.   그런데 avg 역시 double형이므로 서식문자인 %f를 사용하여 값을 출력해주면 되겠습니다.   printf(\"%f\\n\", avg);   코드의 잘못된 부분이나, 궁금한 점이 있으시다면 댓글 남겨주시면 감사드리겠습니다.  ","categories": ["C","Algorithms"],
        "tags": ["C","Algorithms","Programming"],
        "url": "http://localhost:4000/c/algorithms/Assign-C-1/",
        "teaser": null
      },{
        "title": "Python 과제: 입력 및 출력",
        "excerpt":"문제   실행결과가 다음과 같이 되도록 프로그램을 작성하시오.      아래의 해설을 보지 마시고, 최대한 고민해서 이 문제를 풀어보시기 바랍니다.   해설   우선 직관적으로 이 문제를 보신 후에는 반자동적으로 파란색 박스와 빨간색 박스가 무엇을 의미하는지를 파악하셔야 합니다.   또한 파란색 박스와 빨간색 박스 각각에 동일한 문법(Syntax)이 들어가는지도 파악하셔야 합니다.   여기까지 문제에서 필요한 부분들을 추출하셨다면, 바로 문제풀이에 들어가시면 됩니다.   먼저 파란색 박스를 보시면 아시겠지만, 물음에 대한 답변을 해야합니다.   그런데 그 답변은 딱 정해진 답이 아닌 사용자에 따라서 천차만별로 달라질 수 있는 답입니다.   그러므로 답변에 대한 답을 얻을 때는 사용자가 그 답을 입력하는 방식으로 진행하는 것이 좋을것 같습니다.      파이썬에서 입력을 받기 위해서는 어떤 문법을 사용해야할까요?    input() 함수를 사용해야 하며, 문법 구조는 다음과 같습니다.   Syntax     input(prompt)           여기서 prompt는 사용자로부터 입력을 받기 전에 기본적으로 표시되는 메시지 즉, 문자열입니다.            문법 구조에서 명시되지는 않았지만, 사용자로부터 입력을 받았다면 입력 받은 값을 저장할 변수가 필요합니다. 왜냐하면 사용자로부터 입력 받은 값을 변수를 통해서 이용할 수 있기 때문입니다.       그러므로 다음과 같이 변수도 함께 작성해주셔야 합니다.   x = input()   여기까지 기본적인 input 함수 사용법에 대해서 알아보았습니다.   그럼 이제 문제를 풀어보면서 위의 설명이 의미하는 바를 이해해봅시다.   먼저 문제를 보시면, 문제의 첫번째 줄에서 ““당신의 이름은 무엇인가요?”“가 화면에 출력되어야 하고, 그 이후에 사용자로부터 입력을 받아야 함을 알 수 있습니다.   그런데 출력에 필요한 별도의 함수(print())를 이용해서 화면에 출력할 수도 있지만, 위의 설명에서처럼 input 함수의 인자로 건네준 문자열이 사용자로부터 입력을 받기 전에 기본적으로 표시되므로 다음처럼 작성하면 됨을 알 수 있습니다.   input(\"당신의 이름은 무엇인가요?\")   또한, 위의 설명에서처럼 사용자로부터 입력받은 값을 별도의 변수에 저장해야 이를 이용할 수 있으므로, 변수도 함께 작성해주셔야 합니다.   변수의 이름은 아무래도 의미있는 이름이면 좋겠죠?   그러므로 저는 변수명을 name으로 작성하겠습니다.   name = input(\"당신의 이름은 무엇인가요?\")   여기까지 하셨다면, 문제의 첫 번째 줄은 해결하였습니다.   이번에는 두 번째 줄로 넘어가봅시다.   빨간색 네모 박스를 보시면 아시겠지만 이는 사용자로부터 입력받은 사용자의 이름을 출력해줘야 함을 알 수 있습니다.   그런데 우리는 위에서 사용자로부터 입력받은 이름 값을 name이라는 변수에 저장하였으므로, 이 변수의 값을 단순히 불러들여서 출력만 해주면 됨을 알 수 있습니다.      파이썬에서 출력을 담당하는 문법은 무엇일까요?    이는 print() 함수이며, 문법 구조는 다음과 같습니다.   Syntax   print(object(s), sep=separator, end=end, file=file, flush=flush)           여기서 object(s)는 필수적으로 전달하여야 하는 인자이며, 그 이름이 의미하듯이 어떠한 객체든 그 수에 상관없이 전달할 수 있으며, 이러한 객체들은 출력되기 전에 모두 문자열로 변환됩니다.            sep=’separator’는 선택적이며, 객체들이 2개 이상이라면 이들을 구분짓는 방법을 명시한다. 기본값은 ‘ ‘이다.            end=’end’는 선택적이며, 끝에 무엇을 출력할지를 명시한다. 기본값은 ‘\\n’(개행)이다.            file은 선택적이며, 쓰기 메소드를 가진 객체이다. 기본값은 sys.stdout이다.            flush는 선택적이며, 부울 값인데 True는 flushed를 False는 buffered를 의미한다. 기본값은 False이다.       이 문제를 풀이하는 데 있어서 객체와 구분자를 제외한 다른 인자들은 필요치 않으므로, 다른 강좌에서 이들을 설명하고자 합니다.   print 함수를 이용하여 name 변수의 값을 여러 방법으로 출력할 수 있는데 다음과 같습니다.   방법 1   print(\"%s씨는 로또를 사려고 하는군요. 1등 당첨될 확률을 알려드리겠습니다.\" % (name))   방법 2   print(name, \"씨는 로또를 사려고 하는군요. 1등 당첨될 확률을 알려드리겠습니다.\")   방법 3   print(\"{}씨는 로또를 사려고 하는군요. 1등 당첨될 확률을 알려드리겠습니다.\".format(name))   방법 4   print(name + \"씨는 로또를 사려고 하는군요. 1등 당첨될 확률을 알려드리겠습니다.\")   방법 5   print(f\"{name}씨는 로또를 사려고 하는군요. 1등 당첨될 확률을 알려드리겠습니다.\")   이 중에서 여러분의 입맛에 맞는 방식을 선택하면 됩니다.   여기까지 하셨다면, 이 문제의 두 번째 줄도 해결하셨습니다. :grin:   세 번째 줄과 네 번째 줄은 동일한 방식으로 작성하므로 한 번에 다루도록 하겠습니다.   세 번째 줄과 네 번째 줄 모두 변수명과 프롬프트만 수정해주시면 되는데, 이번에는 한 가지 사실을 아셔야 합니다.   그것은 바로 input 함수가 반환하는 값이 string 즉, 문자열이라는 것입니다.   그런데 도대체 이게 왜 중요한 것일까요?   이 물음에 대한 답을 찾기 위해 다섯 번째 줄로 가봅시다.   다섯 번째 줄의 두 번째 빈칸에서는 확률을 출력하고 있는데, 이는 세 번째 줄과 네 번째 줄에서 입력한 값들을 이용하여 연산을 진행하고 그 연산 결과를 출력해주면 해결할 수 있습니다.   그런데 문자열끼리 나눗셈을 진행할 수 있을까요?   불가능한 연산입니다.   문자열을 나눈다니요…   그렇기 때문에 우리는 input 함수에서 반환한 값을 형 변환해줘야 합니다.   즉, 기존 str 자료형을 숫자로 말이죠.   파이썬에서 형 변환을 하기 위해서는 다음의 형태로 작성하시면 됩니다.   Type Casting Form   type()      여기서 type은 자료형을 의미합니다. 즉 소괄호 안에 있는 값을 type에 지정한 자료형으로 변환하라는 의미입니다.   이것을 input에 활용해보면 다음과 같습니다.   Type Casting Application   type(input(prompt))   이렇게 작성을 하시면 input으로부터 반환된 값이 type에 지정한 자료형으로 변환이 됩니다.   마지막으로 변환된 값을 변수에 넣어주기만 하면 되겠죠?   Final Type Casting Application   variable = type(input(prompt))   설명한 내용을 바탕으로 세 번째 줄을 작성하면,   total_number_count = int(input('전체 숫자의 갯수는 몇개입니까?'))           type은 int로 작성을 하였는데, 갯수는 소수점이 없는 정수이기 때문입니다.            변수명은 꼭 total_number_count가 아니어도 되지만, 의미있는 이름으로 지어주세요. :blush:       마찬가지로 네 번째 줄 역시,   all_match_count = int(input('1등 당첨되기 위해 모두 맞아야 하는 숫자는 몇개인가요?'))           이것 역시 들어맞는 수가 소수점이 없는 정수이기 때문에 type을 int로 작성하였습니다.            변수명은 꼭 all_match_count가 아니어도 되지만, 의미있는 이름으로 지어주세요. :blush:       여기까지 하셨다면, 이 문제의 네 번째 줄까지 모두 해결하셨습니다. :clap::clap:   다섯 번째 줄로 넘어가봅시다.   이것 역시 두 번째 줄과 동일한 방식으로 작성을 해주시면 됩니다.   단, 이번에는 확률을 구하는 식을 작성해주고, 필요한 경우 서식문자까지 추가해주면 되겠군요.   방법 1   print(\"%s씨가 로또 1장을 샀을 때 1등에 당첨될 확률은 %f%%입니다.\" % (name, float(all_match_count)/total_number_count*100))           all_match_count 변수를 float로 형 변환을 시켜준 이유는 all_match_count와 total_number_count가 모두 정수형이기 때문에 나눗셈 연산의 결과가 정수형으로 나오기 때문입니다. 즉, 소수점 아래의 숫자들이 모두 날아가 버리는 것이죠. 그렇기에 all_match_count나 total_number_count 중 하나를 float로 형 변환을 해주게 되면 나눗셈 연산을 진행할 때 인터프리터가 float로 명시적 형 변환한 변수 외의 기존의 정수형 변수를 float로 자동 형 변환하여 나눗셈 연산의 결과가 float형이 될 수 있습니다. 즉, 소수점 아래의 숫자들이 보존될 수 있는 것이죠.            계산 결과가 실수이므로 서식문자 %f를 사용하였으며, 출력을 위한 %와 서식문자 앞의 %를 interpreter가 동일한 것으로 간주하기 때문에 %를 단순히 출력할 때에는 %를 두 번 작성하여야 합니다. 즉, %%       방법 2   print(name, \"씨가 로또 1장을 샀을 때 1등에 당첨될 확률은\", float(all_match_count)/total_number_count*100, \"%입니다.\")   방법 3   print(\"{}씨가 로또 1장을 샀을 때 1등에 당첨될 확률은 {}%입니다.\".format(name, float(all_match_count)/total_number_count*100))   방법 4   print(name + \"씨가 로또 1장을 샀을 때 1등에 당첨될 확률은 \" + str(float(all_match_count)/total_number_count*100) + \"%입니다.\")      이번에는 str로 형 변환을 해주었는데, 왜 이렇게 할 수 밖에 없었을까요? 왜냐하면 문자열과 문자열 사이의 +는 문자열끼리의 결합을 의미하는 데, str로 형 변환을 하지 않았을 경우 float 즉, 실수와 문자열에 대해서 + 연산을 진행한다는 것은 인터프리터 입장에서는 이해할 수 없었을 것입니다. 그렇기에 우리는 다시 한번 str로 형 변환을 진행하여 인터프리터가 + 연산의 의미를 이해할 수 있도록 해주어야 합니다.   방법 5   print(f\"{name}씨가 로또 1장을 샀을 때 1등에 당첨될 확률은 {float(all_match_count)/total_number_count*100}%입니다.\")   부족한 제 글 읽어주셔서 감사드립니다.   코드의 잘못된 부분이나, 궁금한 점이 있으시다면 댓글 남겨주시면 감사드리겠습니다.   ","categories": ["Python"],
        "tags": ["Programming","Python"],
        "url": "http://localhost:4000/python/Assign-C-2/",
        "teaser": null
      },{
        "title": "Ubuntu mod_jk Error",
        "excerpt":"Ubuntu mod_jk Error   Tomcat과 Apache를 연결시켜주는 다리 역할을 하는 mod_jk에서 계속된 오류가 발생하여,   결국 포기하고 Tomcat만을 돌리다가 주소에서 :8080을 떼어내고 싶어 /var/log/apache2/mod_jk.log 파일을 분석하던 중 다음의 에러를 발견할 수 있었다.      에러는 다음과 같았으며,      Could not find worker with name ‘ajp13_worker’ in uri map post processing.    이에 대해 인터넷에 검색하던 중 다음의 게시글을 찾을 수 있었다.   Stack Overflow   해결방법은 /etc/apache2/mods-available 내에 있는 httpd-jk.conf 파일을 jk.conf 파일로 변경한 후, 원본 파일인 /etc/apache2/mods-available/jk.conf를 대상 파일인 /etc/libapache2-mod-jk/httpd-jk.conf에 대해 심볼릭 링크 파일을 생성해주면 된다.   예전에는 이러한 과정을 거치지 않았던 것 같은데…  ","categories": ["Linux"],
        "tags": ["Linux","Ubuntu","Apache","Server","Tomcat"],
        "url": "http://localhost:4000/linux/Ubuntu-Mod-Jk-Error-1/",
        "teaser": null
      },{
        "title": "The Stellar Project",
        "excerpt":"The Stellar Project   1월 25일 날 The Stellar Project Beta v1.0이 출시되었다. (The Stellar Project는 Open Source Project이다. 이에 관심이 있다면 아래 링크에 접속해보자.)   Link: Stellar   이름을 Stellar로 지은 이유는 우주의 미지성이라는 속성을 이 프로젝트에 녹여내고 싶었으며, 본 단어가 그러한 우주를 연상케 하기 때문이었다.   우리가 지금 진행하고 있는 프로젝트들은 1일 1커밋이라는 패러다임에서 도출된 아이디어들을 기반으로 하고 있는데, 사실 이 기반 위에서 어떤 아이디어가 더 튀어나올지 알 수 없어서이기도 하다.   그만큼 나올 수 있는 아이디어의 가짓수가 셀 수 없이 많으며, 그 나온 아이디어들이 또 새로운 기반을 다질 수도 있기 때문이다.      이는 마치 작은 우주인듯 하다.    암튼 첫 시작이 되게 좋았던, 그래서 뜻이 맞는 사람들과 오래토록 함께 할 수 있었던 그런 프로젝트였다.   베타버전 출시 날, 나는 Github에서 Beta 버전을 마무리하고, War 파일까지 만들어놓은 상태에서 서버 구축을 진행하던 중 그만 문제가 발생하고야 말았다.   Apache 서버와 Tomcat 사이에 다리를 놓아주는 mod_jk가 말을 듣지 않아 한참을 고생한 것이다.   이 상황을 받아들이고 앞으로 나아가고자 하였으나, War 파일을 올리고 나서도 주소 끝에 :8080 즉, 포트 번호가 붙을 것을 생각하니 자꾸만 마음에 걸렸다.   예전에도 이와 관련된 경험이 있었기에 짧은 시간 안에 해결할 수 있겠다 싶어, 이를 해결하고자 마음 먹었다.   그런데 그만 상황이 더욱 더 악화되고야 말았다.   단순히 mod_jk의 문제가 아닌 Apache 서버의 문제라 생각하여 이를 재설치하는 과정에서 그만 패키지와 관련된 파일까지 전부 삭제하고 만 것이다.   나는 이것을 다음 명령어들을 입력하고나서야 깨달을 수 있었다.   sudo apt-get update sudo apt-get install apache2   그래… 너무도 뒤늦게 알아차린 탓에 결국 내가 할 수 있는 일은 그리 많지 않았다.   그 중간 과정이라도 조금이나마 기억해낼 수 있었다면, 역 발상을 통해서라도 뭐라도 했을텐데 말이다…      그렇지만 어쩌겠는가 다 까먹은것을…    나는 결국 Ubuntu Server를 재설치하기 위해 사무실로 멀고도 먼 여정을 떠나게 되었다.   막상 도착하고나서도 서버 내 파일들과 기존 Mysql 데이터, 그리고 설정들을 백업해야 했기 때문에 상당히 오랜 시간이 걸렸다.   그렇게 모든 설정을 마치고 집에 돌아와 mod_jk를 다시 시도해보았지만 똑같은 증상이 반복되었고, 나는 결국 Tomcat만 설정해둔 상태에서 War 파일을 올리게 되었다.   (아무래도 여러 날 동안 팀원분들과 고생했던 프로젝트다보니 최대한 빠르게 베타 버전을 올리고 싶었나보다…)   마음이 급하였는지 파일명을 ROOT.war로 설정하지도 않고 이클립스에서 갓 뽑아낸 이름 그대로 Stellar.war 파일을 올리게 되었다.   더군다나 ROOT.war로 바꾸고 나서도 기존 ROOT 디렉토리 내에 넣어버리고 말았다… (이런…)   마침내 모든 것을 정상적으로 설정하고 나서야 드디어.. 처음으로 The Stellar Project의 Beta 버전을 확인할 수 있었다..   그렇게 PSG 단톡방에 해당 프로젝트의 출시 소식을 알리게 되었고, 앞으로의 더 나은 Stellar를 위해, 또 오류 검출을 위해 팀원분들께 회원가입을 당부드렸다.   맨 처음 회원가입을 해주신 분은 정등x님이었다.   이렇게 힘들게 개발을 진행해서 그런지 맨 처음 회원가입해주신 그 분께 감사한 마음이 들었다.   더군다나 먼저 사용해보시면서 오류를 가장 먼저 보고해주신 덕분에 이후 다른 분들께서도 원활히 해당 기능을 사용하실 수 있게 되었다.   보고된 오류에 대해서 나는 곧바로 어느 부분에서 에러가 발생하는지를 확인할 수 있었고, script 태그 내의 오타로 인하여 발생한 문제임을 알 수 있었다.   원본 코드는 다음의 주소에서 확인할 수 있다.   Code   len_Chk라는 이름으로 함수를 작성해놓고선 그만 lenChk로 해당 함수를 호출하려 하였다.   사실 해당 오류를 접하고서 당황스럽기 그지 없었다.      오류가 발생할까봐 베타 출시전부터 꾸준히 오류 사항들을 점검하였는데, 이렇게 단순한 오타가 오류 사항이 되다니…    해당 오류를 해결하기 위해 나는 Hotfix 브런치를 생성하여 해당 오류를 해결할 수 있었으며, 해결한 코드에 대해 War 파일을 재생성하여 서버에 업로드하였다.   사이트의 기능이 정상작동하는 것을 보고선 그대로 잠에 들었다.   또 하루가 지나서야 나는 Admin Rest 설정에도 문제가 있음을 발견할 수 있었다.   아직 커밋 검사 기능이 개발되지 않아 Rest 설정은 무의미하지만, 그래도 곧 출시될 예정이기 때문에 이에 대해 오류 원인을 찾기 시작하였다.   그런데 참 아이러니하게도 코드 상에서의 오류는 전혀 발견되지 않았고, 심지어는 전자정부 내의 톰캣에서는 본 사이트가 정상 작동하는 것이었다.   그런데 한 가지 그전부터 짚이는 부분이 있었는데, 바로 DB 시간이었다.   언제부턴가 사이트의 등록 시간과 DB에 기록되는 시간이 달라졌던 것이었다.   그리고 또 내가 해당 데이터를 삭제하는 기준으로서 작성해두었던 디비 시간과 사이트에 노출된 시간을 비교하는 로직이 떠올랐다.   사실 이것이 문제였다.   사이트에 노출된 시간과 디비에 저장된 시간의 불일치로 인하여 해당 로직이 작동하지 않았기 때문이었다.   이 문제를 해결하고자 오랜 시간 고심하였고, 디비 시간대 설정부터 시작하여 톰캣 시간대 설정까지 참 힘들고 긴 시간을 인내한 후에야 본 문제를 해결할 수 있었다.   이렇듯 프로젝트 하나로도 정말 배울 점이 많은 것 같다.   협업부터 시작하여 개발 그리고 오류 개선까지…   협업이라는 것도 사실 그리 쉬운 일은 아닌 것 같다.   나와 의견이 다른 사람이 한 사람이라도 있다면, 그의 생각과 나의 생각 사이의 Gap 차이를 줄이기 위해서 프로젝트 외에도 별도의 노력을 쏟아부어야 한다.   그렇지만 이러한 과정에서도 분명 배울 점은 있다.   생각해보자.   사실 우리 주변에서 흔히 볼 수 있는 물건들은 요즘와서야 기계가 개발한다지만, 불과 그리 오래되지 않은 시점에는 사람들이 하나 둘 모여 하나의 물건에 대해 여러 부분을 맡아 그것을 완성하곤 하였다.   그렇다.   사실 아직도 대개의 Task들은 한 명의 사람이 아닌 여러 사람이 함께 모여 진행한다.   그만큼 인적자원이란 중요한 것이며, 사회성을 기르는 것도 개인이 커다란 발전을 추구할 수 있는 가능성을 마련해준다고 생각한다.   나 혼자 잘나서 하는 Task는 그 자체로 분명 어느 한계선이 존재할 수밖에 없다는 것이다.   그렇기에 이러한 협업 능력의 배양도 한 편으로는 되게 중요한 경험임에 틀림없다.   더군다나 사회를 살아가는 한 인간으로서도…   암튼 프로젝트를 진행하면서 배울 점은 정말 많다.   그리고 이에 대해서 한 가지 고백할 것이 있다.   나는 어떠한 강의도, 어떠한 설명도 없이 혼자서, 때로는 고심하며, 인내하며 필요에 따라 원서를 발굴하여 이를 읽었을 때도 있었으며, 하나의 Fact, 하나의 Mechanism을 찾아내기 위해 눈에 불을 켜고 밤을 샐 때도 많았다.   그렇게 얻은 하나의 Fact, Mechanism들이 모여서 하나의 작품을 완성시킬 수 있었는데, 그것이 바로 이번에 출시한 The Stellar Project였다.   그러한 과정은 마치 하나의 거대한 산을 오르는 것과 같은 기분을 들게 해주며, 그에 따르는 성취는 마치 그 산의 정상에 오른 것과 같은 기분이 들게 해준다.   내가 뭐라도 되는 것 마냥 지금껏 글을 작성하였지만, 단순히 나의 생각을 서술한 것이므로 불편하신 분들은 그냥 넘기시면 되겠다.   사실 비전공자가 아님에도 이렇게 뭔가를 해낼 수 있었다는 것은 전공자면 누구나 할 수 있다는 사실이다.   나는 취미생활 그 이상도 그 이하도 아닌 지금 그 마음가짐 그대로 열심히 이를 즐기고자 한다.   그것이 내가 앞으로 살아가는 하나의 방향이라 생각한다.   긴 글 읽어주셔서 감사드립니다.  ","categories": ["Exhibition"],
        "tags": ["Linux","Ubuntu","Apache","Server","Tomcat","Programming","Coding","PSG"],
        "url": "http://localhost:4000/exhibition/The-Stellar-Project-1/",
        "teaser": null
      },{
        "title": "C 자주 범할 수 있는 실수 #1",
        "excerpt":"질문   상위 10%까지 A, 30%까지는 B … 이런식으로 나오게끔 작성하고 싶은데, 의도한 대로 결과가 나오지 않습니다.   문제 코드   #define _CRT_SECURE_NO_WARNINGS  #include &lt;stdio.h&gt;  int main(void) {     int ranking = 0;     int whole = 0;     int score = 0;      printf(\"등수?\");     scanf_s(\"%d\", &amp;ranking);      printf(\"전체 인원수? \");     scanf_s(\"%d\", &amp;whole);      score = ranking / whole * 100;      if(score &lt;= 10)         printf(\"A\\n\");     else if(10 &lt;= score &lt;= 30)         printf(\"B\\n\");     else if(30 &lt;= score &lt;= 60)         printf(\"C\\n\");     else if(60 &lt;= score &lt;= 90)         printf(\"D\\n\");     else         printf(\"F\\n\");      return 0; }   답변   Python의 경우와는 달리 C에서는 다음의 조건을 이어지는 문법으로 만족시킬 수 없습니다.   조건      score는 10 이상이고 30 이하이다.    10 &lt;= score &lt;= 30     그러므로 C에서 위의 조건을 만족시키기 위해서는 다음과 같은 조건식을 구성해야 합니다.   10 &lt;= score &amp;&amp; score &lt;= 30     또한, 이 경우에 관계 연산자와 논리 연산자의 혼용없이 조건식을 간결하게 구성할 수도 있습니다.   다음은 이러한 Concept을 반영한 코드입니다.   #define _CRT_SECURE_NO_WARNINGS  #include &lt;stdio.h&gt;  int main(void) {     int ranking = 0;     int whole = 0;     int score = 0;      printf(\"등수?\");     scanf_s(\"%d\", &amp;ranking);      printf(\"전체 인원수? \");     scanf_s(\"%d\", &amp;whole);      score = ranking / whole * 100;      if(score &lt;= 10)         printf(\"A\\n\");     else if(score &lt;= 30)         printf(\"B\\n\");     else if(score &lt;= 60)         printf(\"C\\n\");     else if(score &lt;= 90)         printf(\"D\\n\");     else         printf(\"F\\n\");      return 0; }  ","categories": ["C"],
        "tags": ["Programming","Coding"],
        "url": "http://localhost:4000/c/Tip-C-1/",
        "teaser": null
      },{
        "title": "C 과제: 숫자 맞추기 게임",
        "excerpt":"질문   내용   ‘미니 숫자 맞추기’ 게임입니다.   com = 10이 저장되었다고 할 때, 정적변수 count를 활용하여 3번의 기회를 주는 프로그램을 작성하시오.   의사코드      com &lt;- 10 저장   count &lt;- 0으로 초기화   ans &lt;- 키보드 입력(예를 들어, 5)            count 1 증가       만약 count가 3보다 크면 “게임 실패”, 종료(exit(1))       맞추었으면 (if com == ans)                 프로그램 종료(exit(1);)     + 그렇지 않으면       다시 입력(3번 반복)           답변   내용   exit 함수를 호출하여 프로그램을 종료해도 되지만, 별도의 헤더파일(stdlib.h)을 선언해야 하므로   return 0;    구문으로 이를 대체하였습니다.   즉, 여기서 사용된 Idea는 main 함수의 종료 == 프로그램의 종료입니다.   코드   #include &lt;stdio.h&gt;  int main() {    int ans;    int com = 10;    static int count = 0;        while (1) {              if (count == 3) {           printf(\"게임실패\\n\");           return 0;        }                     printf(\"숫자를 입력하시오:\");       scanf(\"%d\", &amp;ans);        if (ans != com) {            count++;            continue;       }else{           printf(\"성공\\n\");           return 0;       }          } }  ","categories": ["C","Algorithms"],
        "tags": ["C","Algorithms","Programming","Coding"],
        "url": "http://localhost:4000/c/algorithms/Assign-C-3/",
        "teaser": null
      },{
        "title": "MFC Fundamentals of Windows 응용",
        "excerpt":"내용   MFC Fundamentals of Windows에 대한 개념을 공부한 후, 이를 용용하여 20개의 창을 띄워주는 프로그램을 작성함.   Delay를 주지 않았을 경우, 한 번에 20개의 창이 뜨므로,   다음처럼 0.1초의 delay를 줌.   Sleep(100);   코드   #include &lt;afxwin.h&gt; #include &lt;Windows.h&gt;   class CMyFrame : public CFrameWnd { public:     CMyFrame(POINT p, SIZE s) {         Create(NULL, _T(\"MFC Application Tutorial\"), NULL, CRect(p, s));     } };   class CExample : public CWinApp {     BOOL InitInstance() {         int x = 0, y = 0;         int cx = 0, cy = 0;           POINT p;         SIZE s;           for (int i = 0; i &lt; 20; i++) {             p.x = (x += 25);             p.y = (y += 25);               s.cx = (cx += 40);             s.cy = (cy += 40);               CMyFrame* Frame = new CMyFrame(p, s);             m_pMainWnd = Frame;               Frame-&gt;ShowWindow(SW_NORMAL);             Frame-&gt;UpdateWindow();               Sleep(100);                      }           return TRUE;     }   };   CExample theApp;  ","categories": ["MFC"],
        "tags": ["MFC","Programming","Coding"],
        "url": "http://localhost:4000/mfc/Application_MFC-1/",
        "teaser": null
      },{
        "title": "C 정렬 응용 - 사전식 정렬",
        "excerpt":"질문   내용   5개의 문자를 입력받아 사전순으로 정렬하는 프로그램을 작성하시오.   해결   내용   아래의 코드에는 중복된 코드가 많이 보인다.   가독성을 위해서라도 아래의 코드를 함수화하는 것이 더 좋을것이다.   코드   #include &lt;stdio.h&gt; #include &lt;string.h&gt;   int main(void) {     int i, j, k, t;     char input[10][15];     char cpr[50];     int arrlen[10];          for(i=0;i&lt;5;i++)     {         printf(\"%d번째? \", i+1);         scanf(\"%s\", input[i]);         arrlen[i] = strlen(input);     }          for(i=0;i&lt;5;i++)         printf(\"%s \", input[i]);          printf(\"\\n\");          for(i=0;i&lt;5;i++)     {         for(j=0;j&lt;4;j++)         {             if(j==i)                 continue;              if(i==0)             {                 if(strcmp(input[i], input[j]) &lt; 0)                 {                                                               t=0;                     while(input[i][t] != NULL)                     {                         cpr[t] = input[i][t];                         t++;                     }                     cpr[t]=0;                     t=0;                     while(input[j][t] != NULL)                     {                         input[i][t] = input[j][t];                         t++;                     }                     input[i][t] = 0;                     t=0;                     while(cpr[t] != NULL)                     {                         input[j][t] = cpr[t];                         t++;                     }                     input[j][t]=0;                 }             }             else             {                 if(i&lt;j)                 {                     if(strcmp(input[i], input[j]) &lt; 0)                     {                         t=0;                         while(input[i][t] != NULL)                         {                             cpr[t] = input[i][t];                             t++;                         }                         cpr[t]=0;                         t=0;                         while(input[j][t] != NULL)                         {                             input[i][t] = input[j][t];                             t++;                         }                         input[i][t]=0;                         t=0;                         while(cpr[t] != NULL)                         {                             input[j][t] = cpr[t];                             t++;                         }                         input[j][t]=0;                     }                 }                 else                 {                     if(strcmp(input[i], input[j]) &lt; 0)                     {                         t=0;                         while(input[i][t] != NULL)                         {                             cpr[t] = input[i][t];                             t++;                         }                         cpr[t]=0;                         t=0;                         while(input[j][t] != NULL)                         {                             input[i][t] = input[j][t];                             t++;                         }                         input[i][t]=0;                         t=0;                         while(cpr[t] != NULL)                         {                             input[j][t] = cpr[t];                             t++;                         }                         input[j][t]=0;                     }                 }                              }         }     }          for(i=0;i&lt;5;i++)         printf(\"%s \", input[i]);          return 0; }  ","categories": ["C","Algorithms"],
        "tags": ["C","Algorithms","Programming","Coding"],
        "url": "http://localhost:4000/c/algorithms/Application_Sort/",
        "teaser": null
      },{
        "title": "C 야구 게임",
        "excerpt":"야구 게임(숫자 맞추기 게임과 비슷)   컴퓨터는 0에서 9사이의 숫자 중에서 서로 다른 세 개의 숫자를 고르고, 사용자는 이것을 맞춰야 한다.   중요한 것은 숫자의 순서까지 정확히 맞춰야 한다는 것이다.   단, 사용자가 예상한 숫자를 입력할 때마다 컴퓨터는 입력된 숫자와 컴퓨터 자신이 생각한 숫자가 얼마나 비슷한지를 알려줘야 한다.   예를 들어, 컴퓨터가 고른 숫자가 1 4 9 이고, 사용자가 입력한 숫자가 4 0 9 이면, 두 개의 숫자 4와 9가 일치한다.   9는 숫자와 위치까지 일치하지만(1 strike), 4는 숫자만 일치한다(1 ball).   이런 경우 컴퓨터는 다음과 같은 메시지를 출력해 준다.   1strike, 1ball   만약에 사용자가 1 4 9를 입력하였다면 “3strike, 0ball”이 되어서 프로그램은 종료가 된다.      코드   #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;   int main(void) {     int arr[3];     int input[3];     int i=0;     int j=0;     int count=0;     int strike=0;     int ball=0;          printf(\"Start Game\\n\\n\");          srand((int)time(NULL));          for(i=0;i&lt;3;i++)     {         arr[i] = rand() % 10;                  for(j=0;j&lt;i;j++)         {             if(arr[j] == arr[i])             {                 i--;                 break;             }             else                 continue;         }     }          printf(\"\\n\\n\");          while(1)     {         printf(\"\\n3개의 숫자 선택: \");                  for(i=0;i&lt;3;i++)             scanf(\"%d\", &amp;input[i]);                  strike = 0;         ball = 0;                  for(i=0;i&lt;3;i++)         {             for(j=0;j&lt;3;j++)             {                 if(arr[i] == input[j])                 {                     if(i == j)                         strike++;                     else                         ball++;                 }             }         }                  count++;                  printf(\"%d번째 도전 결과: %dstrike, %dball\\n\", count, strike, ball);                      if(strike == 3)             break;         }           return 0; }  ","categories": ["C","Algorithms"],
        "tags": ["C","Algorithms","Programming","Coding"],
        "url": "http://localhost:4000/c/algorithms/Ball_Game_in_C/",
        "teaser": null
      },{
        "title": "C 경우의 수",
        "excerpt":"문제   필자가 좋아하는 것 중 하나가 금요일 저녁 퇴근길에 DVD나 만화책을 잔뜩 빌리고, 동네 슈퍼에 들려서 군것질거리를 사가지고 집에 들어가는 것이다. 오늘은 금요일이다. 현재 필자의 주머니에는 5천원이 있다. DVD 한편을 빌리면 3,500원이 남는다. 슈퍼에 들려서 크림빵(500원), 새우깡(700원), 콜라(400원)을 사려한다. 잔돈을 하나도 남기지 않고 이 세가지 물건을 하나 이상 반드시 구매하려면 어떻게 구매를 진행해야 하겠는가? 물론 여기에는 여러 가지 경우의 수가 있을 것이다. 필자가 어떠한 선택을 할 수 있는지 여러분이 제시해 주기 바란다.   실행 결과   현재 당신이 소유하고 있는 금액 : 3500 크림빵 1개, 새우깡 2개, 콜라 4개 크림빵 2개, 새우깡 3개, 콜라 1개 크림빵 4개, 새우깡 1개, 콜라 2개 어떻게 구입하시겠습니까?   해결   내용   이러한 문제는 재귀함수와 static 혹은 전역변수를 이용한 메모리 사용을 추가하여 푸는 방식이 일반적이다.   아래의 내가 푼 방법은 한 가지 해를 찾는 상황에서 신속하고 빠르지만 조건이 붙어있는 경우 재탐색이 매우 많아지게 되므로 비효율적이다.   코드   #include &lt;stdio.h&gt;   int main(void) {     int x=1, y=1, z=1;     int p, q, r;     int result;     int result1, result2, result3;          printf(\"현재 당신이 소유하고 있는 금액: \");     scanf(\"%d\", &amp;result);          result -= (500 + 700 + 400);          p = result / 700;          for(; p&gt;=0; p--)     {         result1 = result - 700 * p;         q = result1 / 500;                  for(; q&gt;=0; q--)         {             if(q==1 &amp;&amp; (result1 % 500) == 0){                 ++x;                 y += p;                                  printf(\"크림빵 %d개, 새우깡 %d개, 콜라 %d개\\n\", x, y, z);                 x = 1;                 y = 1;                 z = 1;                 break;             }              result2 = result1 - 500 * q;             r = result2 / 400;                          for(; r&gt;=0; r--)             {                 result3 = result2 - 400 * r;                                  if((result3 % 400) != 0)                 {                     continue;                 }                 else                 {                     z += r;                     x += q;                     y += p;                                          printf(\"크림빵 %d개, 새우깡 %d개, 콜라 %d개\\n\", x, y, z);                     x = 1;                     y = 1;                     z = 1;                     break;                 }             }         }     }          return 0; }  ","categories": ["C","Algorithms"],
        "tags": ["C","Algorithms","Programming","Coding"],
        "url": "http://localhost:4000/c/algorithms/Case/",
        "teaser": null
      },{
        "title": "C 유클리드 호제법",
        "excerpt":"문제   내용   유클리드 호제법을 이용하여 최대 공약수를 구하는 프로그램을 작성하시오.   유클리드 호제법   정리   \\(a, b \\in Z\\)이고, a를 b로 나눈 나머지가 \\(r\\)이라고 하자. (여기서 \\(a \\geq b\\)이고, \\(r\\)은 \\(0 \\leq r &lt; b\\)인 정수.)   \\(a\\)와 \\(b\\)의 최대공약수를 \\((a, b)\\)라고 하면, 다음이 성립한다.   \\((a, b) = (b, r)\\).   증명   \\(a, b \\in Z\\)이고, \\(a \\geq b\\)라고 하자.   그러면, \\(a = bq + r\\)을 만족하는 유일한 정수 \\(q, r\\)이 존재한다.   이때, \\(0 \\leq r &lt; b\\)이다.   \\((a, b) = d, a = d\\alpha, b=d\\beta\\)라고 하자. 즉, \\(\\alpha\\)와 \\(\\beta\\)는 서로소이다.   \\[a = bq + r\\]  \\[d\\alpha = d\\beta q + r\\]  \\[d\\mid r.\\]  즉, \\(r\\)은 \\(d\\)의 배수이다.   \\[\\because r = d\\alpha - d\\beta q\\]  이제, \\(r = d\\rho.\\) 라고 하자.   만약 \\((\\beta, \\rho) = d\\prime &gt; 1\\)라면,   \\(\\beta = d\\prime \\beta\\prime, \\rho = d\\prime \\rho\\prime\\)으로 두었을 때,   \\[a = bq + r.\\]  \\[d\\alpha = d\\beta q + d\\rho = dd\\prime\\beta\\prime q + dd\\prime\\rho\\prime = dd\\prime(\\beta\\prime q + \\rho\\prime).\\]  \\[\\alpha = d\\prime(\\beta\\prime q + \\rho\\prime).\\]  이 되므로, \\(d\\prime\\mid\\alpha\\)이다.   즉, \\(\\alpha\\)는 \\(d\\prime\\)의 배수이다.   즉, \\(d\\prime\\mid\\alpha\\), \\(d\\prime\\mid\\beta\\)가 되어 \\(\\alpha\\)와 \\(\\beta\\)는 서로소라는 것에 모순이다.   이는 \\((\\beta, \\rho) = d\\prime &gt; 1\\)라는 가정에서 나타나는 모순이므로 \\((\\beta, \\rho) = 1\\)이다.   \\(\\therefore (b, r) = d\\)이다.   해결   코드   #include &lt;stdio.h&gt;   int main(void) {     int i, j, k;          printf(\"두 정수 입력(처음에 입력한 수가 더 커야 함): \");     scanf(\"%d %d\", &amp;i, &amp;j);          if(i&gt;j)     {         k=i%j;                  while(k!=0)         {             i=j; j=k; k=i%j;         }                  printf(\"최대 공약수: %d \\n\", j);     }     else         printf(\"처음에 입력한 수가 더 커야 합니다.\\n\");          return 0; }    참고문헌   Wikipedia  ","categories": ["C","Algorithms"],
        "tags": ["C","Algorithms","Programming","Coding"],
        "url": "http://localhost:4000/c/algorithms/Euclidean_Algorithm_in_C-1/",
        "teaser": null
      },{
        "title": "C 피보나치 수열",
        "excerpt":"문제   피보나치 수열을 구현하시오.   해결   코드   #include &lt;stdio.h&gt;   void fibonacci(int, int, int, int);   int main(void) {     int input = 0;          printf(\"몇 개월?: \");     scanf(\"%d\", &amp;input);          if(input &lt;= 1)         printf(\"%d \", 1);     else     {         printf(\"%d \", 1);         fibonacci(input, 1, 1, 1);     }              return 0; }   void fibonacci(int n, int y, int t, int k) {          if(n&gt;t)     {         printf(\"%d \", y);         fibonacci(n,y+k,t+1,y);     }     else         return;       }  ","categories": ["C","Algorithms"],
        "tags": ["C","Algorithms","Programming","Coding"],
        "url": "http://localhost:4000/c/algorithms/Fibonacci_in_C-1/",
        "teaser": null
      },{
        "title": "C 구구단 파일 저장",
        "excerpt":"문제   내용   프로그램 상에서 파일 99.txt를 만들어서 구구단을 저장하는 프로그램을 작성하시오.   단, fputc() 함수만 사용해서 구현해야 합니다.   해결   내용      2단부터 9단까지의 결과값들이 모두 두 자리 자연수여서 10으로 나눈 몫과 10으로 나눈 나머지 값들을 활용함.   배열의 다음 인덱스에는 문자 c를 삽입하여 반복문의 조건으로 활용함.   파일 열기 실패나 갖가지 에러에 대한 조건문들은 모두 제외함. (문제 풀이에 더 집중하기 위함.)   코드   #include &lt;stdio.h&gt;   int main(void) {     FILE* stream;     int i, j;     int k=0;     char result[10]={};     int s;          stream = fopen(\"99.txt\", \"w\");          for(i=2;i&lt;=9;i++)     {         for(j=1;j&lt;=9;j++)         {             s = i*j;             if(s&lt;10)             {                 fputc(i+48, stream);                 fputc(42, stream);                 fputc(j+48, stream);                 fputc(61, stream);                 fputc(s+48, stream);                 fputc(10, stream);                  continue;             }             else             {                 k=0;                  fputc(i+48, stream);                 fputc(42, stream);                 fputc(j+48, stream);                 fputc(61, stream);                                  result[k] = (s)/10 + 48;                 result[k+1] = (s)%10 + 48;                 result[k+2] = 'c';             }                          while(result[k] != 'c')             {                 fputc(result[k], stream);                 k++;             }                              fputc(10, stream);         }     }          fclose(stream);          return 0; }  ","categories": ["C","Algorithms"],
        "tags": ["C","Algorithms","Programming","Coding"],
        "url": "http://localhost:4000/c/algorithms/File-GuGu-1/",
        "teaser": null
      },{
        "title": "C 달팽이 배열",
        "excerpt":"문제   다음처럼 출력되는 프로그램을 작성하시오.   실행의 예   수 입력: 5  1   2   3   4   5 16  17  18  19   6 15  24  25  20   7 14  23  22  21   8 13  12  11  10   9   해결   코드   #include &lt;stdio.h&gt;   int main(void) {     int arr[10][10]={};     int i, j;     int p=-1;     int k=0;     int input=0;     int check=0;     int count=0;     int save=0;          printf(\"수 입력: \");     scanf(\"%d\", &amp;input);          save = input;          while(input&gt;0)     {         if((check % 2) == 0)         {                          for(i=0;i&lt;input;i++)             {                 p++;                 arr[k][p] = (++count);             }               for(j=0;j&lt;input-1;j++)             {                 k++;                 arr[k][p] = (++count);             }                          check++;         }         else         {             for(i=0;i&lt;input;i++)             {                 p--;                 arr[k][p] = (++count);             }                          for(j=0;j&lt;input-1;j++)             {                 k--;                 arr[k][p] = (++count);             }             check++;         }                  input--;     }          for(i=0;i&lt;save;i++)     {         for(j=0;j&lt;save;j++)         {             printf(\"%3d \", arr[i][j]);         }         printf(\"\\n\");     }          return 0; }  ","categories": ["C","Algorithms"],
        "tags": ["C","Algorithms","Programming","Coding"],
        "url": "http://localhost:4000/c/algorithms/Snail_Arr/",
        "teaser": null
      },{
        "title": "C 이중 포인터 변수의 활용",
        "excerpt":"문제   다음과 같이 두 개의 int형 포인터 변수와 길이가 5인 int형 배열을 선언한다.   int * maxPtr; int * minPtr; int arr[5];   그리고 MaxAndMin이란 이름의 함수를 정의하고 이를 호출하면서 위의 배열과 두 포인터 변수에 대한 정보를 전달하자.   어떠한 정보를 어떻게 전달할지는 여러분이 결정할 몫이다.   그리고 함수호출이 완료되면, 포인터 변수 maxPtr에는 가장 큰 값이 저장된 배열요소의 주소 값이, minPtr에는 가장 작은 값이 저장된 배열요소의 주소 값이 저장되어야 한다.   해결   코드   #include &lt;stdio.h&gt;   void MaxAndMin(int**, int**, int []); void Compare(int [], int);   int main(void) {     int * maxPtr=NULL;     int * minPtr=NULL;     int max=0;     int min=0;     int arr[5];     int i;          maxPtr = &amp;max;     minPtr = &amp;min;          for(i=0;i&lt;5;i++)         scanf(\"%d\", &amp;arr[i]);          MaxAndMin(&amp;maxPtr, &amp;minPtr, arr);          printf(\"Max: %d Min: %d\\n\", *maxPtr, *minPtr);          return 0; }   void MaxAndMin(int** dptr, int** pptr, int ptr[]) {     int k;          for(k=0;k&lt;4;k++)     {         if(k==0)         {             Compare(ptr, k);             *dptr = &amp;ptr[k+1];             *pptr = &amp;ptr[k];         }         else         {             Compare(ptr, k);             *dptr = &amp;ptr[k+1];                          if(**pptr &gt; ptr[k])                 *pptr = &amp;ptr[k];         }     } }   void Compare(int ptr[], int k) {     int temp=0;          if(ptr[k+1] &lt; ptr[k])     {         temp = ptr[k];         ptr[k] = ptr[k+1];         ptr[k+1] = temp;     } }  ","categories": ["C"],
        "tags": ["C","Programming","Coding"],
        "url": "http://localhost:4000/c/Studying_C-2/",
        "teaser": null
      },{
        "title": "C++ 상속 관계의 확장과 추상 클래스",
        "excerpt":"문제   예제 EmployeeManager4.cpp를 확장하여 다음 특성에 해당하는 ForeignSalesWorker 클래스를 추가로 정의해보자.   “영업직 직원 중 일부는 오지산간으로 시장개척을 진행하고 있다. 일부는 아마존에서, 또 일부는 테러의 위험이 있는 지역에서 영업활동을 진행 중에 있다. 따라서 이러한 직원들을 대상으로 별도의 위험수당을 지급하고자 한다.”   위험수당의 지급방식은 ‘위험의 노출도’ 에 따라서 다음과 같이 나뉘며, 한번 결정된 직원의 ‘위험 노출도’ 는 변경되지 않는다고 가정한다(이는 const 멤버변수의 선언을 유도하는 것이다).      리스크 A: 영업직의 기본급여와 인센티브 합계 총액의 30%를 추가로 지급한다.   리스크 B: 영업직의 기본급여와 인센티브 합계 총액의 20%를 추가로 지급한다.   리스크 C: 영업직의 기본급여와 인센티브 합계 총액의 10%를 추가로 지급한다.   다음 main 함수와 함께 동작하도록 ForeignSalesWorker 클래스를 정의하기 바라며, Employee 클래스는 객체 생성이 불가능한 추상 클래스로 정의하기 바란다.   main 함수   int main(void) {     EmployeeHandler handler;      ForeignSalesWorker* fseller1 = new ForeignSalesWorker(\"Hong\", 1000, 0.1, RISK_LEVEL::RISK_A);      fseller1 -&gt; AddSalesResult(7000);      handler.AddEmployee(fseller1);      ForeignSalesWorker* fseller2 = new ForeignSalesWorker(\"Yoon\", 1000, 0.1, RISK_LEVEL::RISK_B);      fseller2-&gt;AddSalesResult(7000);      handler.AddEmployee(fseller2);      ForeignSalesWorker* fseller3 = new ForeignSalesWorker(\"Lee\", 1000, 0.1, RISK_LEVEL::RISK_C);      fseller3-&gt;AddSalesResult(7000);      handler.AddEmployee(fseller3);     handler.ShowAllSalaryInfo();      return 0; }   위의 main 함수에서 보이는 RISK_LEVEL 이름공간의 RISK_A, RISK_B, RISK_C는 enum형으로 선언된 상수이다. 그럼 이어서 실행결과를 보이겠다.   실행의 예      위의 실행결과에서 salary 내역은 일반 영업직 직원의 급여 계산결과이며(기본금에 상여금을 더한 결과), risk pay가 위험수당에 속한다.   EmployeeManager4.cpp 코드   #include &lt;iostream&gt; #include &lt;cstring&gt;  using namespace std;  class Employee { private:     char name[100];  public:     Employee(char* name)     {         strcpy(this-&gt;name, name);     }      void ShowYourName() const     {         cout&lt;&lt;\"name: \"&lt;&lt;name&lt;&lt;endl;     }      virtual int GetPay() const     {         return 0;     }      virtual void ShowSalaryInfo() const {} };  class TemporaryWorker : public Employee { private:     int workTime;     int payPerHour;  public:     TemporaryWorker(char* name, int pay) : Employee(name), workTime(0), payPerHour(pay) {}      void AddWorkTime(int time)     {         workTime += time;     }      int GetPay() const     {         return workTime*payPerHour;     }      void ShowSalaryInfo() const     {         ShowYourName();         cout&lt;&lt;\"salary: \"&lt;&lt;GetPay()&lt;&lt;endl&lt;&lt;endl;     } };  class PermanentWorker: public Employee { private:     int salary;  public:     PermanentWorker(char* name, int money) : Employee(name), salary(money)     {}      int GetPay() const     {         return salary;     }      void ShowSalaryInfo() const     {         ShowYourName();         cout&lt;&lt;\"salary: \"&lt;&lt;GetPay()&lt;&lt;endl&lt;&lt;endl;     } };  class SalesWorker: public PermanentWorker { private:     int salesResult;     double bonusRatio;  public:     SalesWorker(char* name, int money, double ratio) : PermanentWorker(name, money), salesResult(0), bonusRatio(ratio) {}      void AddSalesResult(int value)     {         salesResult += value;     }      int GetPay() const     {         return PermanentWorker::GetPay() + (int)(salesResult*bonusRatio);     }      void ShowSalaryInfo() const     {         ShowYourName();         cout&lt;&lt;\"salary: \"&lt;&lt;GetPay()&lt;&lt;endl&lt;&lt;endl;     } };  class EmployeeHandler { private:     Employee* empList[50];     int empNum;  public:     EmployeeHandler() : empNum(0)     {}      void AddEmployee(Employee* emp)     {         empList[empNum++]=emp;     }      void ShowAllSalaryInfo() const     {         for(int i=0; i&lt;empNum; i++)             empList[i]-&gt;ShowSalaryInfo();     }      void ShowTotalSalary() const     {         int sum=0;          for(int i=0; i&lt;empNum; i++)             sum += empList[i]-&gt;GetPay();          cout&lt;&lt;\"salary sum: \"&lt;&lt;sum&lt;&lt;endl;     }      ~EmployeeHandler()     {         for(int i=0; i&lt;empNum; i++)             delete empList[i];     } };  int main(void) {     EmployeeHandler handler;      handler.AddEmployee(new PermanentWorker(\"KIM\", 1000));     handler.AddEmployee(new PermanentWorker(\"LEE\", 1500));      TemporaryWorker * alba = new TemporaryWorker(\"Jung\", 700);      alba-&gt;AddWorkTime(5);      handler.AddEmployee(alba);      SalesWorker * seller = new SalesWorker(\"Hong\", 1000, 0.1);      seller-&gt;AddSalesResult(7000);      handler.AddEmployee(seller);     handler.ShowAllSalaryInfo();     handler.ShowTotalSalary();      return 0; }   풀이 코드   #include &lt;iostream&gt; #include &lt;cstring&gt;  using namespace std;  namespace RISK_LEVEL {     enum     {         RISK_A,         RISK_B,         RISK_C     }; }  class Employee { private:     char name[100];  public:     Employee(char* name)     {         strcpy(this-&gt;name, name);     }      void ShowYourName() const     {         cout&lt;&lt;\"name: \"&lt;&lt;name&lt;&lt;endl;     }      virtual int GetPay() const = 0;     virtual void ShowSalaryInfo() const = 0; };  class TemporaryWorker : public Employee { private:     int workTime;     int payPerHour;  public:     TemporaryWorker(char* name, int pay) : Employee(name), workTime(0), payPerHour(pay) {}      void AddWorkTime(int time)     {         workTime += time;     }      int GetPay() const     {         return workTime*payPerHour;     }      void ShowSalaryInfo() const     {         ShowYourName();         cout&lt;&lt;\"salary: \"&lt;&lt;GetPay()&lt;&lt;endl&lt;&lt;endl;     } };  class PermanentWorker: public Employee { private:     int salary;  public:     PermanentWorker(char* name, int money) : Employee(name), salary(money) {}      int GetPay() const     {         return salary;     }      void ShowSalaryInfo() const     {         ShowYourName();         cout&lt;&lt;\"salary: \"&lt;&lt;GetPay()&lt;&lt;endl&lt;&lt;endl;     } };  class SalesWorker: public PermanentWorker { private:     int salesResult;     double bonusRatio;  public:     SalesWorker(char* name, int money, double ratio) : PermanentWorker(name, money), salesResult(0), bonusRatio(ratio) {}      void AddSalesResult(int value)     {         salesResult += value;     }      int GetPay() const     {         return PermanentWorker::GetPay() + (int)(salesResult*bonusRatio);     }      void ShowSalaryInfo() const     {         ShowYourName();         cout&lt;&lt;\"salary: \"&lt;&lt;GetPay()&lt;&lt;endl&lt;&lt;endl;     } };  class ForeignSalesWorker: public SalesWorker { private:     const int risk;  public:     ForeignSalesWorker(char* name, int money, double ratio, int risk) : SalesWorker(name, money, ratio), risk(risk) {}      int GetPay() const     {         switch(risk)         {             case 0:                 return SalesWorker::GetPay() * 0.3;                 break;              case 1:                 return SalesWorker::GetPay() * 0.2;                 break;                              case 2:                 return SalesWorker::GetPay() * 0.1;                 break;              default:                 return 0;         }     }      void ShowSalaryInfo() const     {         ShowYourName();          cout&lt;&lt;\"salary: \"&lt;&lt;SalesWorker::GetPay()&lt;&lt;endl;         cout&lt;&lt;\"risk pay: \"&lt;&lt;GetPay()&lt;&lt;endl;         cout&lt;&lt;\"sum: \"&lt;&lt;SalesWorker::GetPay()+GetPay()&lt;&lt;endl&lt;&lt;endl;     }                                 };  class EmployeeHandler { private:     Employee* empList[50];     int empNum;  public:     EmployeeHandler() : empNum(0) {}      void AddEmployee(Employee* emp)     {         empList[empNum++]=emp;     }      void ShowAllSalaryInfo() const     {         for(int i=0; i&lt;empNum; i++)             empList[i]-&gt;ShowSalaryInfo();     }      void ShowTotalSalary() const     {         int sum=0;          for(int i=0; i&lt;empNum; i++)             sum += empList[i]-&gt;GetPay();          cout&lt;&lt;\"salary sum: \"&lt;&lt;sum&lt;&lt;endl;     }      ~EmployeeHandler()     {         for(int i=0; i&lt;empNum; i++)             delete empList[i];     } };  int main(void) {     EmployeeHandler handler;      ForeignSalesWorker* fseller1 = new ForeignSalesWorker(\"Hong\", 1000, 0.1, RISK_LEVEL::RISK_A);      fseller1 -&gt; AddSalesResult(7000);      handler.AddEmployee(fseller1);      ForeignSalesWorker* fseller2 = new ForeignSalesWorker(\"Yoon\", 1000, 0.1, RISK_LEVEL::RISK_B);      fseller2-&gt;AddSalesResult(7000);      handler.AddEmployee(fseller2);      ForeignSalesWorker* fseller3 = new ForeignSalesWorker(\"Lee\", 1000, 0.1, RISK_LEVEL::RISK_C);      fseller3-&gt;AddSalesResult(7000);      handler.AddEmployee(fseller3);     handler.ShowAllSalaryInfo();      return 0; }  ","categories": ["Cpp"],
        "tags": ["C++","Programming","Coding"],
        "url": "http://localhost:4000/cpp/Studying_Cpp-1/",
        "teaser": null
      },{
        "title": "C++ 연산자 오버로딩",
        "excerpt":"문제   C++ 기반의 데이터 입출력 문제   이번에는 재미 삼아서(정말로 재미 삼아서) 2차원 배열접근에 대한 연산자 오버로딩을 진행하고자 한다. 실제로 이렇게까지 연산자를 직접 오버로딩 하는 경우는 거의 없다. 다만, 필자는 호기심을 유발 및 충족시킨다는 측면에서 이 문제를 제시하는 것이다. 그러니 여러분도 이 문제에 단순한 호기심과 즐거움을 느꼈으면 좋겠다. 그럼 문제를 제시하겠다. 다음의 이름으로 클래스를 정의하자.   class BoundCheck2DIntArray { .... }   이 클래스는 BoundCheckIntArray 클래스의 2차원 배열 버전이다. 따라서 다음과 같이 객체를 생성하면,   BoundCheck2DIntArray arr2d(3, 4);   세로와 가로의 길이가 각각 3과 4인, int형 2차원 배열처럼 동작하는 arr2d 객체가 생성되어, 다음의 형태로 데이터를 저장 및 참조할 수 있어야 한다.   for(int n=0; n&lt;3; n++)     for(int m=0; m&lt;4; m++)         arr2d[n][m] = n+m;  for(int n=0; n&lt;3; n++) {     for(int m=0; m&lt;4; m++)         cout&lt;&lt;arr2d[n][m]&lt;&lt;' ';     cout&lt;&lt;endl; }   참고로 두 개의 [] 연산자를 동시에 오버로딩 하는 것은 허용되지 않기 때문에, 위의 다음 문장은,   arr2d[n][m];   두 번의 [] 연산자 호출을 동반하게끔 구현해야 한다. 즉, 첫 번째 [] 연산에 의해서 위의 문장은 다음과 같이 해석되어야 하며,   (arr2d.operator[](n))[m];   그리고 arr2d.operator 연산의 반환 값을 이용해서 두 번째 [] 연산은 다음과 같이 해석되어야 한다.   ((반환 값).operator[])(m);   참고로 이는 호기심 유발 이상의 의미를 갖지는 않지만, 제법 수준이 높은 문제이니(본서의 검토 과정에서 제법 수준이 높은 게 아니고 많이 수준이 높다는 의견이 있었다), 풀지 못했다고 해서 실망할 필요는 없다.   풀이   코드   #include &lt;iostream&gt; #include &lt;cstdlib&gt;   using namespace std;   class BoundCheck2DIntArray { private:     int *arr;       int arrlen[2];     int value[2];     int p;       BoundCheck2DIntArray(const BoundCheck2DIntArray&amp; arr) {}     BoundCheck2DIntArray&amp; operator=(const BoundCheck2DIntArray&amp; arr) {}   public:     BoundCheck2DIntArray(int i, int j)     {         arr = new int[i*j];         arrlen[0] = i;         arrlen[1] = j;         p = 0;     }       BoundCheck2DIntArray&amp; operator[] (int idx)     {         if (p == 2)             p = 0;           if (idx &lt; 0 || idx &gt;= arrlen[p])         {             cout &lt;&lt; \"Array index out of bound exception\" &lt;&lt; endl;             exit(1);         }           value[p++] = idx;           return *this;     }       void operator=(int result)     {         if (p != 2)         {             cout &lt;&lt; \"not [][]\" &lt;&lt; endl;             exit(1);         }           arr[arrlen[1] * value[0] + value[1]] = result;     }       int GetArr() const { return *arr; }     ~BoundCheck2DIntArray() { delete[] arr; }     friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const BoundCheck2DIntArray&amp; pos); };   ostream&amp; operator&lt;&lt;(ostream&amp; os, const BoundCheck2DIntArray&amp; pos) {     if (pos.p != 2)     {         cout &lt;&lt; \"not [][]\" &lt;&lt; endl;         exit(1);     }       os &lt;&lt; pos.arr[pos.arrlen[1] * pos.value[0] + pos.value[1]];       return os; }   int main(void) {     BoundCheck2DIntArray arr2d(3, 4);     BoundCheck2DIntArray arr3d(9, 10);       for (int n = 0; n &lt; 3; n++)         for (int m = 0; m &lt; 4; m++)             arr2d[n][m] = n + m;       for (int n = 0; n &lt; 3; n++)     {         for (int m = 0; m &lt; 4; m++)             cout &lt;&lt; arr2d[n][m] &lt;&lt; ' ';         cout &lt;&lt; endl;     }       cout &lt;&lt; endl;       for (int n = 0; n &lt; 9; n++)         for (int m = 0; m &lt; 10; m++)             arr3d[n][m] = n + m;       for (int n = 0; n &lt; 9; n++)     {         for (int m = 0; m &lt; 10; m++)             cout &lt;&lt; arr3d[n][m] &lt;&lt; ' ';         cout &lt;&lt; endl;     }       return 0; }    ","categories": ["Cpp"],
        "tags": ["C++","Programming","Coding"],
        "url": "http://localhost:4000/cpp/Studying_Cpp-2/",
        "teaser": null
      },{
        "title": "C++ IS-A 관계의 상속",
        "excerpt":"문제   ‘책’ 을 의미하는 Book 클래스와 ‘전자 책’ 을 의미하는 EBook 클래스를 정의하고자 한다.   그런데 ‘전자 책’도 ‘책’의 일종이므로, 다음의 형태로 클래스의 상속 관계를 구성하고자 한다.   (클래스에 선언되어야 할 멤버변수만 제시하였다.)   class Book { private:     char* title;     char * isbn;     int price;     ... };  class EBook : public Book { private:         char* DRMKey;     ... };   위의 EBook 클래스에 선언된 멤버 DRMKey는 전자 책에 삽입이 되는 보안관련 키(key)의 정보를 의미한다. 그럼 다음 main 함수와 함께 실행이 가능하도록 위의 클래스를 완성해보자.   main 함수   int main(void) {     Book book(\"좋은 C++\", \"555-12345-890-0\", 20000);     book.ShowBookInfo();     cout&lt;&lt;endl;      EBook ebook(\"좋은 C++ ebook\", \"555-12345-890-1\", 10000, \"fdx9w0i8kiw\");     ebook.ShowEBookInfo();      return 0; }   실행의 예   제목: 좋은 C++ ISBN: 555-12345-890-0 가격: 20000   제목: 좋은 C++ ebook ISBN: 555-12345-890-1 가격: 10000 인증키: fdx9w0i9kiw   해결   코드   #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt;   using namespace std;   class Book { private:     char* title;     char* isbn;     int price;   public:     Book(char* my_title, char* my_isbn, int my_price) : price(my_price)     {         title = new char[strlen(my_title) + 1];         strcpy(title, my_title);           isbn = new char[strlen(my_isbn) + 1];         strcpy(isbn, my_isbn);     }       void ShowBookInfo()     {         cout &lt;&lt; \"제목: \" &lt;&lt; title &lt;&lt; endl;         cout &lt;&lt; \"ISBN: \" &lt;&lt; isbn &lt;&lt; endl;         cout &lt;&lt; \"가격: \" &lt;&lt; price &lt;&lt; endl;     }       ~Book()     {         delete[]title;         delete[]isbn;     } };   class EBook : public Book { private:     char* DRMKey;      public:     EBook(char* my_title, char* my_isbn, int my_price, char* my_drm) : Book(my_title, my_isbn, my_price)     {         DRMKey = new char[strlen(my_drm) + 1];         strcpy(DRMKey, my_drm);     }       void ShowEBookInfo()     {         ShowBookInfo();         cout &lt;&lt; \"인증키: \" &lt;&lt; DRMKey &lt;&lt; endl;         cout &lt;&lt; endl;     }       ~EBook()     {         delete[]DRMKey;     } };   int main(void) {       Book book(\"좋은 C++\", \"555-12345-890-0\", 20000);     book.ShowBookInfo();     cout &lt;&lt; endl;     cout &lt;&lt; endl;       EBook ebook(\"좋은 C++ ebook\", \"555-12345-890-1\", 10000, \"fdx9w0i8kiw\");     ebook.ShowEBookInfo();       return 0; }  ","categories": ["Cpp"],
        "tags": ["C++","Programming","Coding"],
        "url": "http://localhost:4000/cpp/Studying_Cpp-3/",
        "teaser": null
      },{
        "title": "C++ IS-A 관계의 상속, 두 번째",
        "excerpt":"문제   정사각형을 의미하는 Square 클래스와 직사각형을 의미하는 Rectangle 클래스를 정의하고자 한다.   그런데 정사각형은 직사각형의 일종이므로, 다음의 형태로 클래스의 상속 관계를 구성하고자 한다.   class Rectangle {     ... };  class Square : public Rectangle {     ... };    이에 다음 main 함수와 함께 실행이 가능하도록 위의 클래스를 완성해보자. 참고로 상속을 한다고 해서 유도 클래스에 무엇인가를 많이 담아야 한다는 생각을 버리자!   main 함수   int main(void) {     Rectangle rec(4, 3);     rec.ShowAreaInfo();      Square sqr(7);     sqr.ShowAreaInfo();      return 0; }   실행의 예   면적: 12 면적: 49   해결   코드   #include &lt;iostream&gt;   using namespace std;   class Rectangle { private:     int hor;     int ver;     int area;   public:     Rectangle(int my_hor, int my_ver) : hor(my_hor), ver(my_ver)     {         area = hor*ver;     }       void ShowAreaInfo()     {         cout &lt;&lt; \"면적: \" &lt;&lt; area &lt;&lt; endl;     } };   class Square : public Rectangle { private:     int line;   public:     Square(int my_line) : Rectangle(my_line, my_line)     {} };   int main(void) {     Rectangle rec(4, 3);     rec.ShowAreaInfo();       Square sqr(7);     sqr.ShowAreaInfo();       return 0; }   ","categories": ["Cpp"],
        "tags": ["C++","Programming","Coding"],
        "url": "http://localhost:4000/cpp/Studying_Cpp-4/",
        "teaser": null
      },{
        "title": "C++ 상속과 생성자의 호출",
        "excerpt":"문제   다음 클래스에 적절한 생성자를 삽입해보자.   그리고 이의 확인을 위한 main 함수를 적절히 정의해 보자.   #include &lt;iostream&gt;   using namespace std;   class Car { private:     int gasolineGauge;   public:     int GetGasGauge()     {         return gasolineGauge;     } };   class HybridCar : public Car { private:     int electricGauge;   public:     int GetElecGauge()     {         return electricGauge;     } };   class HybridWaterCar : public HybridCar { private:     int waterGauge;   public:     void ShowCurrentGauge()     {         cout&lt;&lt;\"잔여 가솔린: \"&lt;&lt;GetGasGauge()&lt;&lt;endl;         cout&lt;&lt;\"잔여 전기량: \"&lt;&lt;GetElecGauge()&lt;&lt;endl;         cout&lt;&lt;\"잔여 워터량: \"&lt;&lt;waterGauge&lt;&lt;endl;     } };   해결   코드   #include &lt;iostream&gt;   using namespace std;   class Car { private:     int gasolineGauge;   public:     Car(int gasoline) : gasolineGauge(gasoline) {}     int GetGasGauge()     {         return gasolineGauge;     } };   class HybridCar : public Car { private:     int electricGauge;   public:     HybridCar(int elec, int gasoline) : Car(gasoline), electricGauge(elec) {}       int GetElecGauge()     {         return electricGauge;     } };   class HybridWaterCar : public HybridCar { private:     int waterGauge;   public:     HybridWaterCar(int gasoline, int elec, int water) : HybridCar(elec, gasoline), waterGauge(water) {}       void ShowCurrentGauge()     {         cout&lt;&lt;\"잔여 가솔린: \"&lt;&lt;GetGasGauge()&lt;&lt;endl;         cout&lt;&lt;\"잔여 전기량: \"&lt;&lt;GetElecGauge()&lt;&lt;endl;         cout&lt;&lt;\"잔여 워터량: \"&lt;&lt;waterGauge&lt;&lt;endl;     } };   int main(void) {     HybridWaterCar ts(100, 100, 100);       ts.ShowCurrentGauge();       return 0; }  ","categories": ["Cpp"],
        "tags": ["C++","Programming","Coding"],
        "url": "http://localhost:4000/cpp/Studying_Cpp-5/",
        "teaser": null
      },{
        "title": "C++ 다형성",
        "excerpt":"개념   ‘다형성’ 이란 ‘동질이상’ 을 의미한다.   즉, “모습은 같은데 형태는 다르다.”   이를 C++에 적용하면, “문장은 같은데 결과는 다르다.”는 것이다.   코드   #include &lt;iostream&gt;   using namespace std;   class First { public:     virtual void SimpleFunc() { cout &lt;&lt; \"First\" &lt;&lt; endl; } };   class Second : public First { public:     virtual void SimpleFunc() { cout &lt;&lt; \"Second\" &lt;&lt; endl; } };   int main(void) {     First* ptr = new First();     ptr-&gt;SimpleFunc();     delete ptr;       ptr = new Second();     ptr-&gt;SimpleFunc();     delete ptr;       return 0; }   상속관계에 놓여있는 First와 Second 클래스를 보면,      위와 같은 관계인데,   main 함수 내부를 잘 살펴보면,   동적 할당의 형태로 First 객체를 하나 생성시키고,   SimpleFunc() 이라는 함수를 호출 및 객체를 소멸시키는 것을 확인할 수 있다.   또한 First형에 Second 객체를 생성시키고 있는데,   이는 First가 기초(기반, Base) 클래스이므로 가능한 연산이다.   그리고 이것 역시 SimpleFunc() 이라는 함수를 호출 및 객체 소멸을 진행하고 있다.   만약에 virtual로 함수를 선언하지 않았다면,   First형으로 선언된 포인터 변수에 First 객체를 담든, Second 객체를 담든 (상속 관계에 놓여있는 기초 클래스 외에 어떤 유도(파생, Derived) 클래스의 객체를 담더라도) First 클래스 내부에 있는 SimpleFunc() 함수만 호출될 것이다.   그런데 virtual 선언을 해줌으로써 First형의 포인터 변수에 Second 객체를 담게 되면 Second 클래스 내부에 있는 동일한 이름의 SimpleFunc 함수가 호출이 된다.   이것이 바로 C++에서의 ‘다형성’의 예시이다.   ","categories": ["Cpp"],
        "tags": ["C++","Programming","Coding"],
        "url": "http://localhost:4000/cpp/Studying_Cpp-6/",
        "teaser": null
      },{
        "title": "C++ 함수 템플릿의 정의",
        "excerpt":"문제   인자로 전달되는 두 변수에 저장된 값을 서로 교환하는 SwapData라는 이름의 함수를 템플릿으로 정의해보자.   그리고 다음 Point 클래스를 대상으로 값의 교환이 이뤄짐을 확인할 수 있도록 main 함수를 구성해보자.   class Point { private:     int xpos, ypos;  public:     Point(int x=0, int y=0) : xpos(x), ypos(y) { }      void ShowPosition() const     {         cout&lt;&lt;'['&lt;&lt;xpos&lt;&lt;\", \"&lt;&lt;ypos&lt;&lt;']'&lt;&lt;endl;     } };   해결   코드   #include &lt;iostream&gt;   using namespace std;   template &lt;typename T&gt;   void SwapData(T num1, T num2) {     int temp = *num1;     *num1 = *num2;     *num2 = temp; }   class Point { private:     int xpos, ypos;   public:     Point(int x=0, int y=0) : xpos(x), ypos(y) { }       void ShowPosition() const     {         cout &lt;&lt; '[' &lt;&lt; xpos &lt;&lt; \", \" &lt;&lt; ypos &lt;&lt; ']' &lt;&lt; endl;     }       int* GetX()     {         return &amp;xpos;     }       int* GetY()     {         return &amp;ypos;     } };   int main(void) {     Point pos(1, 2);          SwapData(pos.GetX(), pos.GetY());       pos.ShowPosition();       return 0; }  ","categories": ["Cpp"],
        "tags": ["C++","Programming","Coding"],
        "url": "http://localhost:4000/cpp/Studying_Cpp-7/",
        "teaser": null
      },{
        "title": "C++ 함수 템플릿의 정의, 두 번째",
        "excerpt":"문제   다음은 int형 배열에 저장된 값을 모두 더해서 그 결과를 반환하는 기능의 함수이다.   int SumArray(int arr[], int len) {     int sum=0;      for(int i=0; i&lt;len; i++)         sum+=arr[i];      return sum; }   이 함수를 템플릿으로 정의하여, 다양한 자료형의 배열을 대상으로 합을 계산하는 예제를 작성해보자.   해결   코드   #include &lt;iostream&gt;   using namespace std;   template &lt;typename T&gt;   T SumArray(T arr[], int len) {     T sum = 0;       for (int i = 0; i &lt; len; i++)         sum += arr[i];       return sum; }   int main(void) {     int arr[5] = { 1, 2, 3, 4, 5 };     double arr2[5] = { 1.1, 2.2, 3.3, 4.4, 5.5 };       cout&lt;&lt;\"int Value: \"&lt;&lt;SumArray(arr, 5)&lt;&lt;endl;     cout &lt;&lt; \"double Value: \" &lt;&lt; SumArray(arr2, 5) &lt;&lt; endl;       return 0; }  ","categories": ["Cpp"],
        "tags": ["C++","Programming","Coding"],
        "url": "http://localhost:4000/cpp/Studying_Cpp-8/",
        "teaser": null
      },{
        "title": "C++ mutable 키워드, 그리고 그 외의 이야기들",
        "excerpt":"내용   Keyword mutable은 const 함수 내에서의 값의 변경을 예외적으로 허용해준다.   예제   코드   #include &lt;iostream&gt;   using namespace std;   class SoSimple {     private:     int num1;     mutable int num2;       public:     SoSimple(int n1, int n2) : num1(n1), num2(n2)     {}       void ShowSimpleData() const     {         cout&lt;&lt;num1&lt;&lt;\", \"&lt;&lt;num2&lt;&lt;endl;     }       void CopyToNum2() const     {         num2 = num1;     } };   int main(void) {     SoSimple sm(1, 2);     sm.ShowSimpleData();     sm.CopyToNum2();     sm.ShowSimpleData();       return 0; }   설명   9행을 보면 num2라는 변수 선언 앞에 mutable이라는 keyword가 붙은것을 볼 수 있다.   mutable int num2;   이 keyword가 붙는 순간 const로 선언된 함수 내부에서 num2의 값을 변경시키는 것이 가능해진다.   그러므로 20행에 정의된 CopyToNum2 이라는 const로 정의된 함수 내부에서 num2의 값을 num1의 값으로 변경시키는 것을 볼 수 있다. (그리고 이러한 변경은 컴파일러가 허용한다.)   void CopyToNum2() const {         num2 = num1; }   특히, C에서 전역변수를 많이 사용하게 될 경우 스파게티 코드가 되듯이, C++에서도 전역변수 외에 mutable keyword 과다 사용 시 스파게티 코드가 되므로 이것 역시 조심히 사용해야 한다.  ","categories": ["Cpp"],
        "tags": ["C++","Programming","Coding"],
        "url": "http://localhost:4000/cpp/Studying_Cpp-9/",
        "teaser": null
      },{
        "title": "List의 활용",
        "excerpt":"문제   자료구조는 구현도 중요하지만 이에 못지않게 활용도 중요하다.   실제로 이미 구현되어 있는 자료구조를 활용하는 것도 실력이다 !   따라서 다음 헤더파일에 정의된 구조체를 기반으로 List를 활용하는 예제를 작성해보기로 하겠다.   NameCard.h   #define NAME_LEN 30 #define PHONE_LEN 30  typedef struct __namecard {     char name[NAME_LEN];     char phone[PHONE_LEN];  } NameCard;  // NameCard 구조체 변수의 동적 할당 및 초기화 후 주소 값 반환 NameCard* MakeNameCard(char* name, char* phone);  // NameCard 구조체 변수의 정보 출력 void ShowNameCardInfo(NameCard* pcard);  // 이름이 같으면 0, 다르면 0이 아닌 값 반환 int NameCompare(NameCard* pcard, char* name);  // 전화번호 정보를 변경 void ChangePhoneNum(NameCard* pcard, char* phone);   위의 헤더파일에 대응하는 소스파일 NameCard.c를 작성하자 !   그리고 아래에 나열된 순서대로 일을 진행하도록 main 함수를 정의하자.   물론 이를 위해서 앞서 구현한 리스트를 활용해야 한다.      총 3명의 전화번호 정보를, 앞서 우리가 구현한 List에 저장한다.   특정 이름을 대상으로 탐색을 진행하여, 그 사람의 정보를 출력한다.   특정 이름을 대상으로 탐색을 진행하여, 그 사람의 전화번호 정보를 변경한다.   특정 이름을 대상으로 탐색을 진행하여, 그 사람의 정보를 삭제한다.   끝으로 남아있는 모든 사람의 전화번호 정보를 출력한다.   더불어 저장의 형태는 NameCard 구조체 변수의 주소 값이어야 하며, 위에서 언급하는 특정 이름은 임의로 지정하되 서로 다른 이름으로 저장하기로 하자.   해결   ArrayList.h   #ifndef ArrayList_h #define ArrayList_h  #include \"NameCard.h\"  #define TRUE    1   // '참'을 표현하기 위한 매크로 정의 #define FALSE   0   // '거짓'을 표현하기 위한 매크로 정의 #define LIST_LEN    100  typedef NameCard* LData;  // NameCard에 대한 typedef 선언  typedef struct __ArrayList  // 배열기반 리스트를 정의한 구조체 {     LData arr[LIST_LEN];    // 리스트의 저장소인 배열     int numOfData;          // 저장된 데이터의 수     int curPosition;        // 데이터 참조위치를 기록 } ArrayList;  typedef ArrayList List;  void ListInit(List* plist);     // 초기화  void LInsert(List* plist, LData data);      // 데이터 저장  int LFirst(List* plist, LData* pdata);      // 첫 데이터 참조  int LNext(List* plist, LData* pdata);       // 두 번째 이후 데이터 참조  LData LRemove(List* plist);     // 참조한 데이터 삭제  int LCount(List* plist);        // 저장된 데이터의 수 반환  #endif /* ArrayList_h */   ArrayList.c   #include &lt;stdio.h&gt; #include \"ArrayList.h\"  void ListInit(List* plist) {     (plist-&gt;numOfData) = 0;      (plist-&gt;curPosition) = -1; }  void LInsert(List* plist, LData data) {     if(plist-&gt;numOfData &gt;= LIST_LEN)     {         puts(\"저장이 불가능합니다.\");          return;      }          plist-&gt;arr[plist-&gt;numOfData] = data;      (plist-&gt;numOfData)++;  }  int LFirst(List* plist, LData* pdata) {     if(plist-&gt;numOfData == 0)         return FALSE;      (plist-&gt;curPosition) = 0;      *pdata = plist-&gt;arr[0];      return TRUE; }  int LNext(List* plist, LData* pdata) {      if(plist-&gt;curPosition &gt;= (plist-&gt;numOfData)-1)         return FALSE;       (plist-&gt;curPosition)++;      *pdata = plist-&gt;arr[plist-&gt;curPosition];      return TRUE;  }  LData LRemove(List* plist) {     int rpos = plist-&gt;curPosition;     int num = plist-&gt;numOfData;     int i;     LData rdata = plist-&gt;arr[rpos];      for(i=rpos; i&lt;num-1; i++)         plist-&gt;arr[i] = plist-&gt;arr[i+1];      (plist-&gt;numOfData)--;     (plist-&gt;curPosition)--;      return rdata;  }  int LCount(List* plist) {     return plist-&gt;numOfData; }   NameCard.h   #ifndef NameCard_h  #define NameCard_h #define NAME_LEN    30 #define PHONE_LEN   30  typedef struct __namecard {     char name[NAME_LEN];     char phone[PHONE_LEN]; } NameCard;  NameCard* MakeNameCard(char* name, char* phone);  void ShowNameCardInfo(NameCard* pcard);  int NameCompare(NameCard* pcard, char* name);  void ChangePhoneNum(NameCard* pcard, char* phone);  #endif /* NameCard_h */   NameCard.c   #include \"NameCard.h\" #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;  NameCard* MakeNameCard(char* name, char* phone) {     NameCard* nc = (NameCard*)malloc(sizeof(NameCard));      strcpy(nc-&gt;name, name);     strcpy(nc-&gt;phone, phone);      return nc; }  void ShowNameCardInfo(NameCard* pcard) {     printf(\"이름: %s\\n\", pcard-&gt;name);     printf(\"전화번호: %s\\n\", pcard-&gt;phone); }  int NameCompare(NameCard* pcard, char* name) {     if(!strcmp(pcard-&gt;name, name))         return 0;      else         return 1; }  void ChangePhoneNum(NameCard* pcard, char* phone) {     strcpy(pcard-&gt;phone, phone); }   main.c   #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include \"NameCard.h\" #include \"ArrayList.h\"  int main(void) {     List list;     ListInit(&amp;list);     NameCard* nc1;     NameCard* nc2;      nc1 = (NameCard*)malloc(sizeof(NameCard));     nc2 = (NameCard*)malloc(sizeof(NameCard));      int i;      for(i=0; i&lt;3; i++)     {         printf(\"이름 입력: \");         scanf(\"%s\", nc1-&gt;name);          printf(\"전화번호 입력: \");         scanf(\"%s\", nc1-&gt;phone);          LInsert(&amp;list, MakeNameCard(nc1-&gt;name, nc1-&gt;phone));     }      printf(\"찾고자 하는 사람의 이름: \");     scanf(\"%s\", nc1-&gt;name);      if(LFirst(&amp;list, &amp;nc2))     {         if(!NameCompare(nc2, nc1-&gt;name))             ShowNameCardInfo(nc2);         else             while(LNext(&amp;list, &amp;nc2))                 if(!NameCompare(nc2, nc1-&gt;name))                     ShowNameCardInfo(nc2);     }      printf(\"찾고자 하는 사람의 이름: \");     scanf(\"%s\", nc1-&gt;name);      printf(\"바꾸고자 하는 전화번호: \");     scanf(\"%s\", nc1-&gt;phone);      if(LFirst(&amp;list, &amp;nc2))     {         if(!NameCompare(nc2, nc1-&gt;name))             ChangePhoneNum(nc2, nc1-&gt;phone);         else             while(LNext(&amp;list, &amp;nc2))                 if(!NameCompare(nc2, nc1-&gt;name))                     ChangePhoneNum(nc2, nc1-&gt;phone);     }      printf(\"찾고자 하는 사람의 이름: \");     scanf(\"%s\", nc1-&gt;name);      if(LFirst(&amp;list, &amp;nc2))     {         if(!NameCompare(nc2, nc1-&gt;name))             LRemove(&amp;list);         else         {             while(LNext(&amp;list, &amp;nc2))             {                 if(!NameCompare(nc2, nc1-&gt;name))                 {                     LRemove(&amp;list);                  }             }         }     }      if(LFirst(&amp;list, &amp;nc2))     {         ShowNameCardInfo(nc2);          while(LNext(&amp;list, &amp;nc2))             ShowNameCardInfo(nc2);     }      free(nc1);     free(nc2);      return 0; }  ","categories": ["Data Structures"],
        "tags": ["Data Structures","Programming","Coding"],
        "url": "http://localhost:4000/data%20structures/Studying_Data_Structures-1/",
        "teaser": null
      },{
        "title": "Recursion",
        "excerpt":"개념   정의   재귀함수란 함수 내에서 자기 자신을 호출하는 함수를,   재귀호출이란 자기 자신을 호출하는 행위를 일컫는다.   장점   재귀함수를 이용해서 자료구조나 알고리즘 분야에 적용하면 복잡하고 난해한 문제들을 비교적 쉽게 해결할 수 있다.   단점   계속적인 자기 자신의 함수 호출로 시간과 메모리 공간의 효율이 저하되는 문제가 있다.   그러므로 프로그램 개발 시 Recursion을 이용한다면, 신중해질 필요가 있다.   코드   return문을 이용한 재귀 호출   수학에서 \\(n!\\)은 \\(n*(n-1)*...*2*1\\)와 같은 표현이다.   또한 \\(n!\\)은 \\(n*(n-1)!\\)으로 다시 표현할 수 있다.   이것을 재귀함수로 구현해보면 factorial(n) 함수에서 다시 factorial(n-1)을 호출하면 된다.   #include &lt;stdio.h&gt;   void self_service(void);  int main(void) {     int a;     int result;       printf(\"정수 입력: \");     scanf(\"%d\", &amp;a);       result = factorial(a);     printf(\"%d 팩토리얼은 : %d입니다. \\n\", a, result);          return 0; }   int factorial(int n) {     if(n&lt;=1)         return 1;     else         return n * factorial(n-1); }   문제   다음은 문제가 있는 코드이다.   이 코드에서 문제를 찾아내어 이를 해결하시오.   #include &lt;stdio.h&gt;   void self_service(void);   int main(void) {     self_service();     return 0; }   void self_service()  {      printf(\"셀프 서비스\\n\");     self_service(); }   설명   위 코드는 메모리가 부족할 때까지 계속 self_service() 함수를 호출하여 실제로 메모리가 부족하면 실행이 끝난다.   구체적으로는 Runtime Error가 발생하여 함수가 무한 반복되는 상태로 진입하게 되고 결국 Memory Overflow가 발생하여 실행이 중단된다.   이러한 문제를 해결하려면 특정 조건이 참이 되었을 경우에 함수의 무한 반복 상태를 탈출하게끔 해줘야 한다.   즉, 이에 대한 별도의 조건문이 마련되어야 한다.   해결   코드   #include &lt;stdio.h&gt;   void self_service(void);   int main(void) {          self_service();     return 0; }   void self_service() {       static int i = 0;       if(i&gt;5)         return;       printf(\"셀프 서비스\\n\");     i++;     self_service();   }   설명   필자는 static keyword를 이용하여 정적 지역 변수를 선언한 이후에 조건을 걸어서 조건을 만족하면, 함수가 종료되게끔 코드를 작성하였다. (지역 변수를 사용하지 않고 정적 지역 변수를 사용한 이유는 재귀 호출이라는 것이 겉으로는 같은 함수를 호출하는 것처럼 보이지만 실제로는 원함수를 copy(복사)하는 concept이기 때문에 지역 변수를 사용하게 되면 count가 되지 않는 문제가 발생하여 무한 반복 상태에 빠지게 된다.)   하지만 정적 지역 변수 같은 경우에는 전역 변수를 보완했음에도 불구하고, 프로그램 종료시까지 메모리 상에 남아있기 때문에 남용 시 공유 자원에 대한 잘못된 접근으로 부작용을 낳을 수 있다.   그러므로 이것을 최대한 피하는 것이 바람직하다.   그러므로 이번에는 매개변수를 이용한 재귀호출을 보이고자 한다.   매개변수를 이용한 재귀 호출   #include &lt;stdio.h&gt;   void self_service(int);   int main(void) {     int a = 1;     self_service(a);     return 0; }   void self_service(int n) {     if(n&gt;5)         return;       printf(\"셀프 서비스 %d회 \\n\", n);     self_service(n+1); }   ","categories": ["Data Structures"],
        "tags": ["Data Structures","Programming","Coding"],
        "url": "http://localhost:4000/data%20structures/Studying_Data_Structures-2/",
        "teaser": null
      },{
        "title": "노트북 덮개 설정 - Ubuntu",
        "excerpt":"내용   이번 포스팅에서는 노트북 덮개를 덮은 상태에서 노트북을 사용할 수 있는 방법에 대해 알아보고자 한다.   먼저 우분투에서 터미널 실행 후 다음 명령어를 입력하자.   sudo vi /etc/systemd/logind.conf   i를 눌러 입력 모드(Insert mode)로 전환 후,   아래의 기본 설정을   #HandleLidSwitch=suspend   다음과 같이 변경한다.   #HandleLidSwitch=ignore   ESC 키를 누른 후 :wq 입력, 그리고 Enter 키를 눌러 변경한 설정을 저장한 후, 우분투를 재부팅해주면 된다.  ","categories": ["Linux"],
        "tags": ["Linux","Ubuntu","Apache","Server","Tomcat"],
        "url": "http://localhost:4000/linux/Laptop_Cover_Option/",
        "teaser": null
      },{
        "title": "Python 과제: 은행 문제",
        "excerpt":"질문   내용   실습   은행의 계좌 정보를 표현하는 Account 클래스와 이 클래스를 활용하는 프로그램     클래스 이름: Account   속성:            (1) 계좌소유주 이름(name): 공개,       (2) 계좌번호(accountNum: 000-0000-0000, 총 11자리 숫자와 2개의 ‘-‘): 비공개,       (3) 잔고(balance): 비공개           메소드:            (1) 입금(deposit) 메소드                    입력: 입금할 금액, 실행 후: 현재잔고+입금액                       (2) 출금(withdraw) 메소드                    입력: 출금할 금액, 실행 후: 현재잔고-출금액                       (3) 정보출력(print_accountInfo) 메소드                    소유주 이름, 계좌번호, 현재잔고 출력                           처리 시나리오      소유주 이름, 계좌번호, 잔고의 입력을 받아 3개의 Account 인스턴스 user1, user2, user3를 생성하고 그 내용을 출력            조건: 계좌번호는 000-0000-0000, 총 11자리 숫자와 2개의 ‘-‘에 맞는 형식인지 검사하고, 틀린 형식이면 맞는 형식으로 입력 받아야 함.           입력 예)      !! 잘못된 계좌의 입력 예, 계좌번호: 123-4567이면, 다시 입력 요구      user1에서 user2로 해당 금액을 이체하는 경우:            이체는 사용자의 잔고에서 이체금액 만큼 출금해서 다른 사용자의 잔고에 입금하면 됨       조건: 이체시, 현재 잔고가 출금할 금액보다 많은지를 확인하고, 현재 잔고가 출금액보다 적은 경우, 출금액을 새로 입력 받아야 함.           답변   내용   문제에서 제시된 조건들을 모두 만족시키는 코드를 작성하기 전에, 먼저 문제에 주어진 Account 클래스의 속성에 대한 조건을 살펴볼 필요가 있다.   조건은 다음과 같으며,      클래스 이름: Account   속성:            (1) 계좌소유주 이름(name): 공개,       (2) 계좌번호(accountNum: 000-0000-0000, 총 11자리 숫자와 2개의 ‘-‘): 비공개,       (3) 잔고(balance): 비공개           여기에서 눈여겨 보아야 할 점은, 멤버 변수 name과는 달리  멤버변수 accountNum, balance 등이 공개가 아닌 비공개라는 점이다.   이는 정보 은닉(Information Hiding)의 개념으로서, 이를 구현하기 위해서는 접근 제어자(Access Modifier)에 대한 개념을 사전에 숙지하고 있어야 한다.   그런데 타 언어와는 다르게 Python의 경우에는 별도의 접근 제어자를 사용하고 있지는 않아서 이러한 요구사항을 충족시키기 위해서는 Python만의 작명법(naming)을 알고 있어야 한다. :cry::cry:   먼저 public(공개)이다.   이것은 클래스의 외부에서도 접근할 수 있으며, 일반적으로 접근 제어자들 중 가장 넓은 범위(scope)를 가진다.   public의 경우에는 별도의 작명법이 존재하지는 않으나, 접미사에 2개 이상의 underscore를 사용하게 되면 public이 된다.   또한 파이썬에서는 클래스 내의 모든 멤버들에 기본적으로 public을 부여한다.   두 번째는 private(비공개)이다.   private의 경우에는 public과는 달리 별도의 작명법이 존재하고 있으며, 다음처럼 접두사로서 두 개의 underscore를 변수 혹은 메소드 앞에 붙여주면 된다.   self.__accountNum   def __inFunc(self):     pass   또한 접미사는 밑줄 한 개까지 허용된다.   다음을 살펴보자.   self.__accountNum_   def __inFunc_(self):     pass   이 때 접미사를 2개 이상 사용하게 되면 public이 됨에 주의하자.   파이썬은 이것에 대해 타 언어와 대비되는 특징도 지니고 있는데,   접두사로 두 개의 underscore를 가지는 모든 멤버들을 다음으로 변경해서   _object._class__variable   클래스의 외부에서도 이에 접근이 가능하다는 점이다.   물론 권고할 만한 사항은 아니므로, 가급적 그러한 사용을 자제하는 것이 좋겠다.   세 번째는 protected이다.   protected의 경우에는 private과는 달리 해당 클래스를 상속하는 하위 클래스에서도 접근이 가능하다.   protected의 경우에도 private과 마찬가지로 별도의 작명법이 존재하고 있으며, 다음처럼 접두사로서 한 개의 underscore를 변수 혹은 메소드 앞에 붙여주면 된다.   self._accountNum   def _inFunc(self):     pass   이 역시 private과 마찬가지로 접미사로 underscore 1개까지 허용된다.   그러므로 위의 정보들을 종합해보았을 때,   공개 처리된 멤버 변수에는 public의 작명법을,   비공개 처리된 멤버 변수에는 private의 작명법에 따라 작성해주면 된다.   또한 문제에서 이와 관련된 조건이 별도로 주어져 있지는 않으나, 개인적으로 인스턴스를 생성할 때 값들을 전달하여 이를 멤버 변수에 저장하고 싶기 때문에 필자는 생성자(Constructor)를 최대한 이용해보려 한다.   그러므로 필자의 경우에는 Account 클래스의 생성자(Constructor)를 다음과 같이 작성하였다.   class Account:     def __init__(self, name, accountNum, balance):         self.name = name         self.__accountNum = accountNum         self.__balance = balance   위의 코드를 이해하기 위해서는 먼저 생성자에 대한 이해와 self에 대한 이해가 선행되어야 하지만, 이에 대한 설명을 본 강좌에서 진행한다면 너무 길어져 프로그램의 논리 흐름에 집중하기 어렵기 때문에 이에 대해서는 따로 강좌로 빼내어 설명할 계획이다.   여기까지 속성에 대한 작성을 완료하였다면, 메소드에 대한 조건으로 내려가보자.   메소드에 대한 조건은 다음과 같다.      메소드:            (1) 입금(deposit) 메소드                    입력: 입금할 금액, 실행 후: 현재잔고+입금액                       (2) 출금(withdraw) 메소드                    입력: 출금할 금액, 실행 후: 현재잔고-출금액                       (3) 정보출력(print_accountInfo) 메소드                    소유주 이름, 계좌번호, 현재잔고 출력                           이 역시도 이미 주어진 조건으로 미루어 보아 독자분들께서 충분히 해결할 수 있을 것으로 판단하여 그나마 의미가 있을 법한 withdraw 메소드에 대해서만 설명을 하려 한다.   먼저 필자의 경우에는 withdraw 메소드를 작성하기 위해서 처리 시나리오 하에 있는 다음의 조건도 참고를 해보았는데, 이는 다음과 같다.      user1에서 user2로 해당 금액을 이체하는 경우:            이체는 사용자의 잔고에서 이체금액 만큼 출금해서 다른 사용자의 잔고에 입금하면 됨       조건: 이체시, 현재 잔고가 출금할 금액보다 많은지를 확인하고, 현재 잔고가 출금액보다 적은 경우, 출금액을 새로 입력 받아야 함.           이 중 조건 부분만 읽어보면,      조건: 이체시, 현재 잔고가 출금할 금액보다 많은지를 확인하고, 현재 잔고가 출금액보다 적은 경우, 출금액을 새로 입력 받아야 함.    이라고 작성이 되어있다.   즉, 현재 잔고가 출금할 금액보다 많은지/많지 않은지를 프로그램이 판단하게끔 하여 그에 맞는 로직을 실행하게끔 흐름을 분기시켜주면 되겠다.   필자는 이를 withdraw 메소드에서 처리하게끔 로직을 작성하였으며, 잔고가 출금액보다 적은 경우에는 1을 반환하고, 그렇지 않은 경우에는 현재잔고-출금액을 수행한 후 0을 반환하게끔 하였다.   즉, 코드는 다음과 같다.   def withdraw(self, amount):         if(self.__balance &lt; amount):             return 1         else:             self.__balance -= amount             return 0   이렇게 하였을 경우의 장점은 다음과 같이 조건문을 구성할 수 있다는 점이다.   if(~.withdraw(amount)):     # ~ 인스턴스의 amount를 인자로 받는 withdraw 메소드를 호출한 후, 잔고보다 출금액이 더 많다면 아래의 구문 실행     print(\"재입력\") else:       # 그렇지 않다면(잔고가 출금액보다 더 많거나 같다면) 아래의 구문 실행     ~.deposit(amount)   그러므로 문제에서 주어진 Account 클래스에 대한 조건들을 이용하여 아래와 같은 코드를 작성할 수 있다.   class Account:     def __init__(self, name, accountNum, balance):         self.name = name         self.__accountNum = accountNum         self.__balance = balance      def deposit(self, amount):         self.__balance += amount          def withdraw(self, amount):         if(self.__balance &lt; amount):             return 1         else:             self.__balance -= amount             return 0      def print_accountInfo(self):         return \"{:&gt;10} {:&gt;10} {:&gt;10}\".format(self.name, self.__accountNum, self.__balance)        여기까지 Account 클래스에 대한 코드는 모두 작성하였다.   지금부터는 이를 이용하여 문제에 명시되어 있는 시나리오를 처리하는 코드를 작성해볼 것이다.   먼저 처리 시나리오 1번은 다음과 같으며,      소유주 이름, 계좌번호, 잔고의 입력을 받아 3개의 Account 인스턴스 user1, user2, user3를 생성하고 그 내용을 출력            조건: 계좌번호는 000-0000-0000, 총 11자리 숫자와 2개의 ‘-‘에 맞는 형식인지 검사하고, 틀린 형식이면 맞는 형식으로 입력 받아야 함.           입력 예)      !! 잘못된 계좌의 입력 예, 계좌번호: 123-4567이면, 다시 입력 요구   1번 조건에 의하여 기본적으로 반복의 횟수를 3회로 제한하여도 되지만, 잘못된 계좌가 사용자로부터 입력되었을 경우 즉, 마지막 !! 에 명시되어 있는 조건에 대비하여 필자의 경우에는 기본 구성을 무한 Loop로 하였다.   그리하여 기본적으로 큰 틀은 무한반복이며,   while True:     # 무한 반복   특정 조건 즉, 정상적으로 3회를 입력하였을 경우에는 이를 탈출하게끔 구성하였다.   i = 0   # 정상적으로 입력한 횟수를 담는 변수  while True:     if(i == 3):     # 그 값이 3이라면(3회 모두 올바르게 입력하였다면)         break       # 탈출   또한, 계좌의 형식이 올바른 경우에는 인스턴스를 생성하여 곧바로 List 자료구조에 담기 위해 별도의 List 자료구조도 선언을 하였다.   my_objects = []     # List   여기까지가 기본 설정인 셈이고, 지금부터는 올바른 계좌 번호의 형식인지를 따지는 로직을 작성해보자.   먼저 사용자로부터 이름, 계좌번호, 잔고를 입력받기 위해서 적절히 출력문을 구성해준 후 이것들을 각각 변수 name, accountNum, balance에 담아주는 입력문도 작성을 해준다.   i = 0  number_count = 0  my_objects = []  while True:      if(i == 3):         break      print(\"{:&gt;10} {:&gt;10} {:&gt;10}\".format(\"이름\", \"계좌번호\", \"잔고\"))     print(\"user{}: \".format(i+1), end='')      name, accountNum, balance = input().split(' ')   그 후 accountNum이 숫자로 구성된 11자리의 계좌번호 형식을 만족하는지 검사하는 구문을 작성해주면 되는데, 이때 알아야 할 사실이 한 가지 있다.   바로 input의 반환형이 ‘str’ 이라는 점이다.   즉, 숫자를 입력하여도 문자열로 반환된다는 것이다.   그러므로 accountNum 변수에 들어간 값은 숫자가 아닌 문자열이다.   그리하여 필자는 우선 문자열에 대해 반복문을 구성하였으며, 반복을 진행하면서 문자열의 문자 하나하나가 숫자인지를 판단하는 조건식을 구성하고, 만약 숫자라면 그 숫자의 개수를 count해주는 별도의 변수를 마련하여 이를 처리하였다.   i = 0  number_count = 0        # 계좌 번호의 숫자 갯수를 저장하는 변수  my_objects = []  while True:      if(i == 3):         break      print(\"{:&gt;10} {:&gt;10} {:&gt;10}\".format(\"이름\", \"계좌번호\", \"잔고\"))     print(\"user{}: \".format(i+1), end='')      name, accountNum, balance = input().split(' ')      for k in accountNum:    # accountNum 문자열에 대해서 반복문을 구성한 후         if(k.isnumeric()):  # isnumeric() 함수를 이용하여 k에 담긴 문자가 숫자인지를 판단한다. 만약 그러하다면 isnumeric() 함수는 True를, 반대의 경우에는 False를 반환하여 해당 조건문의 실행 여부를 결정한다.                     number_count = number_count + 1     # k가 숫자라면 number_count의 값을 1만큼 증가   이렇게 count 해준 number_count의 값이 계좌번호의 숫자의 개수 11과 일치하고, accountNum의 길이가 13과 일치하며, 4번째와 9번째 문자가 ‘-‘로 같다면, Account 클래스의 인스턴스를 생성하여 이를 리스트에 담아주고, i의 값을 1만큼 count 해주었다. 조건을 만족하지 않았을 경우에는 재입력을 요구하였다.   i = 0  number_count = 0  my_objects = []  while True:      number_count = 0      if(i == 3):         break      print(\"{:&gt;10} {:&gt;10} {:&gt;10}\".format(\"이름\", \"계좌번호\", \"잔고\"))     print(\"user{}: \".format(i+1), end='')      name, accountNum, balance = input().split(' ')      for k in accountNum:         if(k.isnumeric()):             number_count = number_count + 1      if(len(accountNum) == 13 and number_count == 11 and accountNum[3] == '-' and accountNum[8] == '-'):     # accountNum의 길이가 13이고 number_count의 값이 11이며, accountNum[3] 즉, 4번째 문자가 '-'이고, accountNum[8] 즉, 9번째 문자가 '-'이라면,         my_objects.append(Account(name, accountNum, int(balance)))         i = i + 1     else:         print(\"재입력\")   조건문에서 accountNum의 길이가 13이 아닐 경우 단축평가(short circuit)에 의하여 나머지 조건은 검사하지 않으므로, 뒤의 조건 식에서의 값에 대한 인덱스 참조 시 다음 에러가 발생할 걱정은 하지 않아도 되겠다.   IndexError: list index out of range      이렇게 3회 모두 정상적으로 입력을 한 후에는 위의 그림에서와 같이 사용자로부터 입력받은 정보들을 모두 출력하게끔 작성하였다.   또한 이를 위해서는 Account 클래스 내의 멤버 함수 print_accountInfo()를 사전에 작성해놓았으니, 이를 활용하면 되겠다.   즉,   i = 0  number_count = 0  my_objects = []  while True:      number_count = 0      if(i == 3):         break      print(\"{:&gt;10} {:&gt;10} {:&gt;10}\".format(\"이름\", \"계좌번호\", \"잔고\"))     print(\"user{}: \".format(i+1), end='')      name, accountNum, balance = input().split(' ')      for k in accountNum:         if(k.isnumeric()):             number_count = number_count + 1      if(len(accountNum) == 13 and number_count == 11 and accountNum[3] == '-' and accountNum[8] == '-'):         my_objects.append(Account(name, accountNum, int(balance)))         i = i + 1     else:         print(\"재입력\")  for b in my_objects:    # List에 저장된 인스턴스들을 순차적으로 b에 담은 후,     print(b.print_accountInfo())    # 해당 인스턴스의 print_accountInfo() 메소드를 호출한다.       여기까지 완료하였다면, 마지막으로 출금과 입금에 대한 처리를 진행해보자.   두 번째 처리 시나리오는 다음과 같으며,      user1에서 user2로 해당 금액을 이체하는 경우:            이체는 사용자의 잔고에서 이체금액 만큼 출금해서 다른 사용자의 잔고에 입금하면 됨       조건: 이체시, 현재 잔고가 출금할 금액보다 많은지를 확인하고, 현재 잔고가 출금액보다 적은 경우, 출금액을 새로 입력 받아야 함.           먼저 위의 처리 시나리오 중 user1에서 user2로 해당 금액을 이체한다는 내용이 있는데, 이로 미루어보아 프로그램 사용자로부터 두 명의 사람을 입력받아 첫 번째에 입력한 사람으로부터 두 번째에 입력한 사람에게 금액을 이체해주면 된다는 것을 알 수 있다.      그런데 만약에 사용자로부터 입력받은 user1과 user2가 프로그램 상 존재하지 않는 사용자라면?    그래서 이에 대한 처리도 해줘야 한다.   이는 마치 계좌번호를 잘못 입력하였을 경우 다시 입력받게끔 하는것과 비슷한 방식으로 처리를 해주면 되겠다.   즉, 잘못 입력할 경우를 대비하여 무한 반복문으로 구성을 해준 후,   while True:   프로그램 상 존재하는 사람을 2회 모두 입력하였을 경우 반복문을 탈출하게끔 구성을 해주면 된다.   2회 처리를 위해 먼저 위에서 사용했었던 변수 i를 0으로 설정한 후, 조건문을 작성해준다.   i = 0  while True:     if(i == 2):         break   프로그램 사용자로부터 두 사람의 이름을 입력받도록 적절한 출력문을 구성해주고, 첫 번째 입력한 사람의 이름을 담는 변수 name1, 두 번째 입력한 사람의 이름을 담는 변수 name2를 이용하여 input문도 구성을 해준다.   i = 0  while True:      if(i == 2):         break      i = 0      print(\"사용자 이름 입력: \", end='')      name1, name2 = input().split(' ')   그 후 위에서 Account의 인스턴스를 담았던 List인 my_objects에서 해당 인스턴스의 인덱스 값과 인스턴스를 순차적으로 idx와 b에 담아 인스턴스 b가 가지고 있는 멤버 변수인 name이 사용자가 입력한 첫 번째 사람의 이름과 같은지 또는 두 번째 사람의 이름과 같은지를 검사한 후, 만약에 그러하다면(같다면) i를 count해주고, 인덱스 값을 담는 별도의 리스트를 마련하여 해당 인스턴스의 인덱스 값을 저장해준다.   순차적으로 인덱스 값과 리스트의 값을 변수에 저장하여 이를 처리하기 위해서는 별도의 처리 없이 다음과 같이 enumerate를 이용하면 된다.   for idx, b in enumerate(my_objects):    # idx에는 인덱스 값이, b에는 List인 my_objects의 값이 저장된다.    이 때, 리스트의 길이는 다음과 같이 2로 제한한다. (프로그램 사용자로부터 입력받는 사람의 수는 2명이기 때문.)   my_list = [0, 0]   위의 내용을 종합하여 다음의 코드를 작성할 수 있다.   i = 0  my_list = [0, 0]  while True:      if(i == 2):         break      print(\"사용자 이름 입력: \", end='')      name1, name2 = input().split(' ')      for idx, b in enumerate(my_objects):         if(b.name == name1):             i = i + 1             my_list[0] = idx         elif(b.name == name2):             i = i + 1             my_list[1] = idx   필자는 위의 계좌번호가 잘못 입력되었을 경우의 처리와는 다른 방식으로 i의 값이 2회가 아니었을 경우에는 사용자로부터 처음부터 두 사람을 다시 입력하게끔 로직을 작성하였다.   즉,   i = 0  my_list = [0, 0]  while True:      if(i == 2):         break      i = 0       # 처음부터 다시 입력받아야 하므로 i의 값을 0으로 설정      print(\"사용자 이름 입력: \", end='')      name1, name2 = input().split(' ')      for idx, b in enumerate(my_objects):         if(b.name == name1):             i = i + 1             my_list[0] = idx         elif(b.name == name2):             i = i + 1             my_list[1] = idx      if(i != 2):         print(\"사용자가 없습니다.\")         print(\"다시 입력\")         continue    # 아래 구문 실행 없이 다시 반복문의 조건부로 거슬러 올라간다.   만약 i가 2라면(즉, 프로그램 사용자가 입력한 사람이 모두 프로그램 상 존재하는 사용자였다면),   프로그램 사용자로부터 출금액을 입력받은 후, 정수 값으로 변환하여 이를 amount라는 출금액을 담는 변수에 저장해준 후,   첫 번째 입력한 사람에게서 사용자로부터 입력받은 출금액을 두 번째 입력한 사람에게 이체해주는 로직을 작성해주면 된다.   이 때 위의 Account 클래스의 withdraw 메소드에 대해 설명했던 바와 같이 출금액이 잔고보다 더 많다면 재입력을, 그렇지 않다면 이체를 해주면 되겠다.   즉,   i = 0  my_list = [0, 0]  while True:      if(i == 2):     # 이곳에 의하여         break       # 바깥쪽 반복문도 탈출      i = 0      print(\"사용자 이름 입력: \", end='')      name1, name2 = input().split(' ')      for idx, b in enumerate(my_objects):         if(b.name == name1):             i = i + 1             my_list[0] = idx         elif(b.name == name2):             i = i + 1             my_list[1] = idx      if(i != 2):         print(\"사용자가 없습니다.\")         print(\"다시 입력\")         continue      while True:         amount = int(input('출금액: '))          if(my_objects[my_list[0]].withdraw(amount)):    # my_objects List에서 my_list[0]에 담긴 인덱스값에 해당하는 인스턴스에 대하여 amount를 인자로 받는 withdraw 메소드를 호출한 후, True라면, 즉 잔고보다 출금액이 더 많다면,              print(\"재입력\")         else:       # 그렇지 않다면             my_objects[my_list[1]].deposit(amount)      # 두 번째 객체에 이체를 해주면 된다.             break   # 그 후 안쪽 반복문 탈출, 그 후 바깥쪽 반복문으로 거슬러 올라가나      else 구문을 실행할 때는 if문에 의하여 이미 다음 구문이 실행되므로, 첫 번째 사용자로부터 출금이 이루어진 상태다.    my_objects[my_list[0]].withdraw(amount)   이제 정말 마지막으로 첫 번째 입력한 사람의 정보와 두 번째 입력한 사람의 정보를 출력해주면 끝이다.   이를 위해 위에서 작성해둔 Account 클래스 내의 print_accountInfo() 메소드를 이용하여 반환 값을 출력만 해주면 된다.   print(my_objects[my_list[0]].print_accountInfo()) print(my_objects[my_list[1]].print_accountInfo())   다음은 최종 코드이다.   class Account:     def __init__(self, name, accountNum, balance):         self.name = name         self.__accountNum = accountNum         self.__balance = balance      def deposit(self, amount):         self.__balance += amount      def withdraw(self, amount):         if(self.__balance &lt; amount):             return 1         else:             self.__balance -= amount             return 0      def print_accountInfo(self):         return \"{:&gt;10} {:&gt;10} {:&gt;10}\".format(self.name, self.__accountNum, self.__balance)  i = 0  number_count = 0  my_objects = []  while True:      number_count = 0      if(i == 3):         break      print(\"{:&gt;10} {:&gt;10} {:&gt;10}\".format(\"이름\", \"계좌번호\", \"잔고\"))     print(\"user{}: \".format(i+1), end='')      name, accountNum, balance = input().split(' ')      for k in accountNum:         if(k.isnumeric()):             number_count = number_count + 1      if(len(accountNum) == 13 and number_count == 11 and accountNum[3] == '-' and accountNum[8] == '-'):         my_objects.append(Account(name, accountNum, int(balance)))         i = i + 1     else:         print(\"재입력\")  for b in my_objects:     print(b.print_accountInfo())  i = 0  my_list = [0, 0]  while True:      if(i == 2):         break      i = 0      print(\"사용자 이름 입력: \", end='')      name1, name2 = input().split(' ')      for idx, b in enumerate(my_objects):         if(b.name == name1):             i = i + 1             my_list[0] = idx         elif(b.name == name2):             i = i + 1             my_list[1] = idx      if(i != 2):         print(\"사용자가 없습니다.\")         print(\"다시 입력\")         continue      while True:         amount = int(input('출금액: '))          if(my_objects[my_list[0]].withdraw(amount)):             print(\"재입력\")         else:             my_objects[my_list[1]].deposit(amount)             break  print(my_objects[my_list[0]].print_accountInfo()) print(my_objects[my_list[1]].print_accountInfo())  ","categories": ["Python"],
        "tags": ["Programming","Python"],
        "url": "http://localhost:4000/python/Assign-Python-2/",
        "teaser": null
      },{
        "title": "C++ Pointer, Reference 사용 시 주의할 점(Information Hiding)",
        "excerpt":"내용   이번 포스팅에서는 C++에서 정보 은닉(Information Hiding)과 관련하여 Pointer, Reference Variable &amp; Return Type 사용 시 주의해야 할 점에 대해서 알아보고자 한다.   먼저 아래의 코드를 보자.   코드   #include &lt;iostream&gt;  using namespace std;  class Square { private:     double width;     double height;  public:     Square(double _width = 1.0, double _height = 1.0) {         this-&gt;width = _width;         this-&gt;height = _height;     }      double GetWidth() {         return width;     }      double GetHeight() {         return height;     }      void SetWidth(double _width) {         this-&gt;width = _width;     }      void SetHeight(double _height) {         this-&gt;height = _height;     }      double Area() {         return this-&gt;width * this-&gt;height;     } };  int main(void) {          Square obj(2.5);      cout&lt;&lt;obj.Area();      return 0; }   위 코드는 코드상 정보 은닉의 원칙(Principle)이 잘 반영된 코드이다.   그런데 필자는 여기에 약간의 변형을 가해보려 한다.   다음의 코드는 어떠한가?   #include &lt;iostream&gt;  using namespace std;  class Square { private:     double width;     double height;  public:     Square(double _width = 1.0, double _height = 1.0) {         this-&gt;width = _width;         this-&gt;height = _height;     }      double&amp; GetWidth() {         return width;     }      double&amp; GetHeight() {         return height;     }      void SetWidth(double _width) {         this-&gt;width = _width;     }      void SetHeight(double _height) {         this-&gt;height = _height;     }      double Area() {         return this-&gt;width * this-&gt;height;     } };  int main(void) {     Square obj(2.5);     double&amp; _height = obj.GetHeight();     double&amp; _width = obj.GetWidth();      _height = 20.5;     _width = 34.1;      cout&lt;&lt;obj.Area();      return 0; }      위 코드는 코드상 정보은닉의 원칙(Principle)이 잘 반영된 코드라고 말할 수 있겠는가?    절대 아니다.   함수의 반환형이 참조형이므로 이를 받아 private 처리된 데이터를 수정할 수 있는 가능성이 존재하기 때문이다.   이는 정보은닉의 원칙(Principle)을 깨뜨리는(Break) 또는 타협하는(Compromising) 가능성(Possibility)을 지니고 있다.   그럼 다음의 코드는 어떠한가?   #include &lt;iostream&gt;  using namespace std;  class Square { private:     double width;     double height;  public:     Square(double _width = 1.0, double _height = 1.0) {         this-&gt;width = _width;         this-&gt;height = _height;     }      double* GetWidth() {         return &amp;width;     }      double* GetHeight() {         return &amp;height;     }      void SetWidth(double _width) {         this-&gt;width = _width;     }      void SetHeight(double _height) {         this-&gt;height = _height;     }      double Area() {         return this-&gt;width * this-&gt;height;     } };  int main(void) {     Square obj(2.5);     double* _height = obj.GetHeight();     double* _width = obj.GetWidth();      *_height = 20.5;     *_width = 34.1;      cout&lt;&lt;obj.Area();      return 0; }   이 역시도 동일한 문제점을 내포하고 있다.   아마 눈치챈 독자도 있겠지만, 필자는 “코드상”이라는 말에 굵은 글씨로 강조 표시를 해놓았다.   다음 코드를 보자.   #include &lt;iostream&gt;  using namespace std;  class Square { private:     double width;     double height;  public:     Square(double _width = 1.0, double _height = 1.0) {         this-&gt;width = _width;         this-&gt;height = _height;     }      double GetWidth() {         return width;     }      double GetHeight() {         return height;     }      void SetWidth(double _width) {         this-&gt;width = _width;     }      void SetHeight(double _height) {         this-&gt;height = _height;     }      double Area() {         return this-&gt;width * this-&gt;height;     } };  int main(void) {          Square obj(2.5);      double* test = (double*)&amp;obj;      *test = 3.4;      *(++test) = 4.5;      cout&lt;&lt;obj.Area();      return 0; }   사실 이렇듯 코드상 정보 은닉의 원칙(Principle)이 잘 지켜졌다고 하더라도 위의 경우에서처럼 private 데이터를 수정할 수 있다.   그렇다면 이것이 C++에서 캡슐화(Encapsulation)가 작동하지 않는다는 것을 의미하는 것일까?   아니다. 캡슐화를 통한 정보 은닉이 필요한 이유를 생각해보자.   캡슐화를 통한 정보 은닉의 목적은 프로그래머에 의해 우발적으로(Accidentally) 발생할 수 있는 데이터의 손실이나 변경을 막기 위함이다.   즉, 위의 포인터 연산은 단순히 우발적으로(Accidentally) 일어난 일인가?   아니다. 이는 프로그래머가 의도적으로(Intentionally) 작성한 코드이다.   그러므로 캡슐화(Encapsulation)가 C++에서 작동하지 않는다는 말은 잘못된 주장이다.   하지만 위의 경우에서처럼 포인터를 이용하여 의도적으로(Intentionally) private 멤버에 접근하는 것은 권고 사항도 아닐 뿐더러 절대 사용하지 말아야 한다.   결론적으로 참조 변수와 포인터 변수 사용 시, 항상 신중하게 주의를 기울여 사용해야 함을 명심하자.  ","categories": ["Cpp"],
        "tags": ["C++","Programming","Coding"],
        "url": "http://localhost:4000/cpp/Studying_Cpp-10/",
        "teaser": null
      },{
        "title": "C/C++ main 함수의 크기",
        "excerpt":"내용   이번 포스팅에서는 의미가 있을까 싶지만, 한번쯤 궁금해 할 것 같은 내용을 다뤄보고자 한다.   바로 “main 함수의 크기”이다.   main 함수의 크기는 얼마일까?   코드(C)   #include &lt;stdio.h&gt;  int main(void) {      printf(\"%lu\\n\", sizeof(main()));      return 0; }   실행결과      C에서는 4Byte,   코드(C++)   #include &lt;iostream&gt;  using namespace std;  int main(void) {      cout&lt;&lt;sizeof(main())&lt;&lt;endl;      return 0; }   실행결과      C++에서도 4Byte이다.   ","categories": ["C","Cpp"],
        "tags": ["C","C++","Programming","Coding"],
        "url": "http://localhost:4000/c/cpp/Studying_in_C-3/",
        "teaser": null
      },{
        "title": "C++ Early Binding(Static Binding) & Late Binding(Dynamic Binding)",
        "excerpt":"내용   이번 포스팅에서는 Early Binding(Static Binding)과 Late Binding(Dynamic Binding)에 대해서 알아보고자 한다.   바인딩(Binding)이 생소할 수 있으니 먼저 이에 대해서 알아보자.   바인딩(Binding)   위키피디아에서는 바인딩을 다음과 같이 설명하고 있다.   프로그래밍 언어에서, 네임 바인딩(name binding)은 엔티티들(데이터 그리고/또는 코드)과 식별자들의 연관이다. 객체에 바운드되는 식별자는 객체를 참조한다고 불린다.  기계어는 식별자의 빌트인 개념을 갖진 않지만, 서비스로서 그리고 프로그래머를 위한 표기로서 네임-객체 바인딩을 가지며 이것은 프로그래밍 언어들에 의해서 구현된다. 바인딩은 스코핑(변수 영억)과 밀접하게 연결되는데, 스코핑은 어떤 네임들을 어떤 객체들에 바인드할 지를 결정한다 - 프로그램 코드의 어느 위치에서 그리고 가능한 실행 경로들 중 어느 곳에서. id를 위한 바인딩을 확립하는 문맥에서 식별자 id의 사용은 바인딩 발생이라고 불린다. 모든 다른 발생들(예를 들면 표현식들, 할당들 그리고 서브프로그램 호출들에서)에서 식별자는 무엇이 바운드되었는지를 나타낸다. 이러한 발생들은 적용된 발생이라고 불린다.   위의 정의만 읽고나서는 도통 무슨 말인지 이해할 수 없을 듯 하여 이에 대해 최대한 쉽게, 간략하게 설명을 해보고자 한다.   일반적으로 바인딩이란 하나의 것을 다른 것에(으로) 대입(대치)하는 것인데, 예를 들어 변수들에 값을 대입하는 것도 바인딩에 해당하고,   식별자들(예를 들면, 변수나 함수의 이름들)을 주소들로 변환하는 과정도 바인딩에 해당한다.   그리고 이러한 바인딩은 컴파일 시(at compile time)에 발생하는 바인딩과 런타임 시(at runtime)에 발생하는 바인딩으로 나눌 수 있다.   Early Binding(Static Binding)   컴파일 시(at compile time)에 발생하는 바인딩을 가리켜 Early Binding(Static Binding)이라 한다.   이는 컴파일러(compiler)나 링커(linker)에 의해 직접적으로 주소와 함수 호출간에 연관 관계가 만들어지며,   함수 호출은 기계어 지시문들로 대체된다.   또한, C++에서 기본적으로 발생하는 바인딩은 Early Binding(Static Binding)이다.   코드와 실행결과를 보자.   Code   #include &lt;iostream&gt;  using namespace std;  class Animal {     public:         void Eat() { cout&lt;&lt;\"동물이 밥을 먹는다.\"&lt;&lt;endl; } };  class Lion: public Animal {     public:         void Eat() { cout&lt;&lt;\"사자가 밥을 먹는다.\"&lt;&lt;endl; } };  int main(void) {     Animal* ani = new Lion;      ani-&gt;Eat();      return 0; }   Output   동물이 밥을 먹는다.   직관적으로 생각해보았을 때, 하위 클래스에 대한 객체를 생성한 후 해당 인스턴스를 상위 클래스 포인터 자료형에 대입하였으니 당연히 Eat()을 호출하였을 때, 하위 클래스의 Eat()이 실행될 것 같지만, 사실 상위 클래스인 Animal 내의 Eat()이 호출된다.   이는 Early Binding(Static Binding)의 경우에 컴파일러는 포인터의 자료형을 보기 때문에   Eat()을 호출하였을 때 해당 자료형 즉, 상위 클래스인 Animal 내의 Eat()이 호출되는 것이다.   그렇다면 필자의 직관적인 생각에 부합한 결과가 도출되기 위해서는 어떻게 해야할까?   아래에서 Late Binding(Dynamic Binding)에 대해 알아보자.   Late Binding(Dynamic Binding)   Late Binding(Dynamic Binding)은 Early Binding(Static Binding)과는 달리 런타임 시(at runtime)에 발생하는 바인딩을 말한다.   이는 컴파일러가 런타임 시 객체의 자료형을 식별하는 코드를 추가한 후, 올바른 함수 정의와 그것의 호출을 일치시킨다.   이러한 Late Binding(Dynamic Binding)은 C++에서 virtual keyword에 의해 구현될 수 있다.   아래에서 코드와 실행결과를 살펴보자.   Code   #include &lt;iostream&gt;  using namespace std;  class Animal {     public:         virtual void Eat() { cout&lt;&lt;\"동물이 밥을 먹는다.\"&lt;&lt;endl; } };  class Lion: public Animal {     public:         void Eat() { cout&lt;&lt;\"사자가 밥을 먹는다.\"&lt;&lt;endl; } };  int main(void) {     Animal* ani = new Lion;      ani-&gt;Eat();      return 0; }   Output   사자가 밥을 먹는다.   위의 실행결과는 필자의 직관적인 생각과 부합하는 결과임을 확인할 수 있다.   이렇듯 C++에서 Late Binding(Dynamic Binding)을 구현하기 위해 virtual keyword 붙이는 것을 잊지 말자.   또한, 아직 Early Binding(Static Binding)과 Late Binding(Dynamic Binding)에 대해 이해되지 않을 수 있다.   그래서 필자가 위 예제와 관련하여 여러분의 이해를 돕고자 다음의 필자의 생각을 준비해보았다.      Early Binding(Static Binding)의 경우에는 컴파일러가 포인터의 자료형에 집중한다면, Late Binding(Dynamic Binding)의 경우에는 컴파일러가 포인터의 자료형이 아닌 그것이 가지고 있는 값에 집중한다.    이는 절대적인 진리는 아니며, 위의 예제와 같이 상속 관계에 놓여있는 클래스에 대해서 활용할 수 있는 생각임을 밝혀둔다.   참고문헌   Wikipedia   ","categories": ["Cpp"],
        "tags": ["C++","Programming","Coding"],
        "url": "http://localhost:4000/cpp/Studying_Cpp-11/",
        "teaser": null
      },{
        "title": "Python 과제: Differently print contents of Dictionaries in List by conditions",
        "excerpt":"질문   내용   문제   딕셔너리와 리스트를 조합하여 다음 코드의 변수 pets처럼 다양한 정보를 축적할 수 있습니다.   이를 실행결과처럼 출력되도록 빈칸에 반복문과 print() 함수를 조합해 보세요.   # 딕셔너리를 선언합니다.  pets = [     {\"name\" : \"구름\", \"age\" : 5},     {\"name\" : \"초코\", \"age\" : 3},     {\"name\" : \"아지\", \"age\" : 1},     {\"name\" : \"호랑이\", \"age\" : 1} ]  print(\"# 우리 동네 애완 동물들\")   실행결과   # 우리 동네 애완 동물들  구름 5살 초코 3살 아지 1살 호랑이 1살      단, 숫자와 문자열 사이에 빈칸이 없게 출력하세요.   답변   내용   먼저 문제에 주어진 pets를 보면, 그 자체는 List인데 내용물로서 Dictionary를 지니고 있음을 알 수 있다.   그래서 필자는 이중 반복문을 이용하여 바깥쪽 반복문은 리스트를 기준으로 안쪽 내용물 즉, 딕셔너리 항목 하나하나에 대해서 순차적으로 접근하는 반복문으로 구성하였고,   안쪽 반복문은 딕셔너리를 기준으로 안쪽 내용물 즉, Key와 Value pairs 하나하나에 대해서 바깥쪽 반복문과 동일한 방식으로 순차적으로 접근하는 반복문으로 구성하였다.   특히 안쪽 반복문 내에서 key 값이 name일 경우와 age일 경우에 대해서 흐름을 분기시켜 그에 따른 적절한 출력이 이뤄지도록 작성하였다.   코드   먼저 필자는 한글이 깨질것을 우려하여 아래에 나오는 모든 문자열들이 UTF-8 형식이라는 것을 명시해주는 주석을 삽입하였다.   # -*- coding: utf-8 -*-   그 후 pets를 선언하고, 내용물을 삽입하였으며, 적절한 출력문도 구성해주었다.   pets = [     {\"name\": \"구름\", \"age\": 5},     {\"name\": \"초코\", \"age\": 3},     {\"name\": \"아지\", \"age\": 1},     {\"name\": \"호랑이\", \"age\": 1} ]  print(\"# 우리 동네 애완 동물들\")   마지막으로 이 문제의 핵심이 되는 아래 코드를 작성하였다.   for i in pets:     for key, value in i.items():         if(key == \"name\"):             print(\"%s\" % (value), end=' ')         else:             print(\"%s살\" % (value))   필자가 위에서 설명한 것처럼 먼저 pets 내의 내용물인 딕셔너리 항목 하나하나에 대해서 접근하는 반복문은 바깥쪽 반복문이다.   즉, 다음 구문이다.   for i in pets:   그 후 i에 들어간 값(List인 pets의 내용물)의 자료형이 dictionary이므로, Key와 Value 쌍들(pairs)을 리턴해주는 items() 함수를 호출하여   이 값들을 각각 변수 key와 value에 담았다.   즉, 이러한 설명은 다음의 구문으로 확인할 수 있다.   for key, value in i.items():   이렇게 함으로써 key 값이 name일 경우와 age일 경우에 흐름을 분기시킬 수 있는데   이 역시 코드로 보이면 다음과 같다.   if(key == \"name\"):      # key값이 name이면 아래 구문 실행     print(\"%s\" % (value), end=' ') else:                   # key값이 name이 아니면(즉, 이 경우에는 age이면) 아래 구문 실행     print(\"%s살\" % (value))            전체 코드   전체 코드를 보이면 다음과 같다.   # -*- coding: utf-8 -*- pets = [     {\"name\": \"구름\", \"age\": 5},     {\"name\": \"초코\", \"age\": 3},     {\"name\": \"아지\", \"age\": 1},     {\"name\": \"호랑이\", \"age\": 1} ]  print(\"# 우리 동네 애완 동물들\")  for i in pets:     for key, value in i.items():         if(key == \"name\"):             print(\"%s\" % (value), end=' ')         else:             print(\"%s살\" % (value))  ","categories": ["Python"],
        "tags": ["Programming","Python"],
        "url": "http://localhost:4000/python/Assign-Python-3/",
        "teaser": null
      },{
        "title": "C 과제: 매크로의 활용 #1",
        "excerpt":"질문   내용   int 배열의 원소를 출력하는 함수 매크로를 문자 배열이나 실수 배열의 원소도 출력할 수 있도록 수정하시오.   실행 결과   실수 배열의 초기값? 0.1 [x] 0.1 0.1 0.1 0.1 0.1 문자 배열의 초기값? @ [y] @ @ @ @ @   답변   내용   필자는 문제의 내용 중 자료형과 관계없이 배열의 원소를 출력하라는 조건을 통해 모든 자료형들을 문자열로 통일하여 사용자로부터 이를 입력받아 매크로로 처리하면 되겠다고 생각하였다.   그래서 일단 길이가 10인 문자 배열 하나를 main 함수 내에 선언하였으며,   int main(void) {     char input[10];      return 0; }   다음과 같이 문제에 주어진 실행결과와 동일한 출력 결과를 얻기 위해 적절한 출력문과 입력문도 함께 구성해주었다. (물론 printf()와 scanf() 함수를 사용하기 위해서는 이와 관련된 헤더파일(stdio.h) 선언도 잊지 말자.)   #include &lt;stdio.h&gt;  int main(void) {     char input[10];      printf(\"실수 배열의 초기값? \");     scanf(\"%s\", input);      return 0; }   이렇듯 input이라는 길이가 10인 1차원 배열에 사용자로부터 문자열을 입력받았다면,   입력받은 문자열들에 대해 총 5회 반복을 진행하는 함수 매크로만 작성해주면 된다.   함수 매크로는 다음과 같으며,   #define PRINT_INPUT(X) for(int i=0; i&lt;5; i++) printf(\"%s \", (X))    아래와 같은 구문이 있을 시   PRINT_INPUT(input);   이는 전처리기에 의해 다음 구문들로 변경된다.   for(int i=0; i&lt;5; i++) printf(\"%s \", input);   왜 필자가 매크로를 아래와 같이 작성하였는지 이해하였는가?   #define PRINT_INPUT(X) for(int i=0; i&lt;5; i++) printf(\"%s \", (X))   이를 본 코드에 결합시키고 실행 결과와 동일한 결과가 출력되게끔 적절한 출력문까지 작성해주면 다음과 같다.   #include &lt;stdio.h&gt;  #define PRINT_INPUT(X) for(int i=0; i&lt;5; i++) printf(\"%s \", (X))      // 총 5회의 출력을 위한 매크로  int main(void) {     char input[10];      printf(\"실수 배열의 초기값? \");     scanf(\"%s\", input);      printf(\"[x] \");     PRINT_INPUT(input);      return 0; }   여기까지 작성하였다면, 문자 배열에 대해서도 동일한 방식으로 코드를 작성해주면 되겠다.   아래에 전체 코드를 보였으니 이를 확인해보자.   전체 코드   #include &lt;stdio.h&gt;  #define PRINT_INPUT(X) for(int i=0; i&lt;5; i++) printf(\"%s \", (X))  int main(void) {     char input[10];      printf(\"실수 배열의 초기값? \");     scanf(\"%s\", input);      printf(\"[x] \");     PRINT_INPUT(input);      printf(\"\\n문자 배열의 초기값? \");     scanf(\"%s\", input);      printf(\"[y] \");     PRINT_INPUT(input);      return 0; }   한계   전체 코드를 보이기만 하고 이 포스팅을 마무리 짓는다면 별 의미 없는 포스팅이 될 듯 하여 필자가 독자 여러분께 질문 하나를 던지겠다.      위 코드의 한계는 무엇일까?       만약 길이가 10인 문자열이 사용자로부터 입력되어진다면, 어떠한 일이 발생하는가?    이는 오버플로우(overflow)의 발생으로 이어질 것이다. (널 문자(Null Character)까지 고려해보았을 때 총 길이가 11이므로)   이러한 한계를 극복하기 위해 필자는 여러분께 위 코드를 동적 메모리 할당(Dynamic Memory Allocation)이라는 개념을 이용하여 재작성해볼 것을 추천하는 바이다.   또한 매크로 함수 사용 관점에서 보면, 만약 지금과 같은 단순한 문제 상황이 아닌 조금만 복잡해지는 문제 상황이 주어진다면, 원하는 결과를 얻기 위한 매크로 함수의 구현이 더더욱 어려워진다는 점이다.   원하는 결과를 얻기 위해 보통 소괄호를 여러 번에 걸쳐 사용하는데, 이렇듯 과도한 소괄호 사용으로 인해 버그(Bug)를 찾고 수정하는 일(디버그(Debug))도 쉽지 않을 뿐만 아니라, 코드의 가독성도 떨어지게 된다.   그러므로 특수 상황을 제외한 함수 매크로의 사용은 최대한 지양하는 것이 좋다.   ","categories": ["C","Algorithms"],
        "tags": ["C","Algorithms","Programming","Coding"],
        "url": "http://localhost:4000/c/algorithms/Assign-C-4/",
        "teaser": null
      },{
        "title": "GIT 개념 이해",
        "excerpt":"내용   이번 포스팅에서는 단순히 영문도 모른채 GIT 명령어를 사용하시는 분들을 위해 필자가 직접 촬영한 영상을 준비해보았다.   이 영상을 통해 GIT의 개념을 파악해보길 바란다.   (실습 영상은 추후 녹화 예정.)   영상    ","categories": ["GIT"],
        "tags": ["Tool","GIT"],
        "url": "http://localhost:4000/git/Concept_Git-1/",
        "teaser": null
      },{
        "title": "C 과제: Swapping Array",
        "excerpt":"질문   내용   크기가 같은 2개의 정수형 배열을 매개변수로 전달받아 두 배열의 원소들의 값을 맞바꾸는 함수를 작성하시오.   이 함수를 이용해서 크기가 5인 두 배열의 값을 맞바꾸는 프로그램을 작성하시오.   배열은 다음과 같이 초기화해서 사용한다.   실행 결과   a 배열: 1 3 5 7 9 b 배열: 0 2 4 6 8 &lt;&lt; swap_array 호출 후 &gt;&gt; a 배열: 0 2 4 6 8 b 배열: 1 3 5 7 9   답변   내용   실행 결과를 통해 길이가 5인 두 개 배열 a, b를 선언한 후 각각 1 3 5 7 9와 0 2 4 6 8로 초기화(Initialization)하자.   int main(void) {     int a[5] = {1, 3, 5, 7, 9};     int b[5] = {0, 2, 4, 6, 8}; }   그 다음 실행 결과와 동일한 결과가 출력되게끔 적절한 출력문도 작성하자.   (a, b 배열의 길이는 5이고, Zero-based numbering에 의하여 인덱스 번호(Index Number)는 0부터 시작하므로 0부터 4까지 반복하는 반복문을 이용하자.)   또한, 출력을 위해 printf() 함수를 사용해야 하므로 헤더파일(stdio.h) 선언도 잊지 말자.   즉, 코드로 보이면 다음과 같다.   #include &lt;stdio.h&gt;  int main(void) {     int a[5] = {1, 3, 5, 7, 9};     int b[5] = {0, 2, 4, 6, 8};      printf(\"a 배열: \");          for(int i=0; i&lt;5; i++)         printf(\"%d \", a[i]);          printf(\"\\n\");      printf(\"b 배열: \");      for(int i=0; i&lt;5; i++)         printf(\"%d \", b[i]);          printf(\"\\n\\n\"); }   여기까지 작성 완료하였다면, 지금부터는 두 배열의 값을 서로 맞바꾸는 함수를 작성해보자.   이것의 작성이 이 문제의 출제 의도라 할 수 있는데, 문제에 정수형 배열을 매개변수로 전달받으라는 조건이 있으므로 이를 위해 먼저 매개변수의 형을 포인터 형으로 설정하자.   void swap_array(int* a, int* b) {  }   그 후 배열의 원소를 임시 저장할 수 있는 temp라는 변수를 하나 생성해준다.      temp 변수의 자료형은 무엇이어야 하는가?    당연히 배열의 원소의 값의 자료형이 int형이므로 int형이다.   (우리는 배열의 원소의 값을 서로 바꿔줘야 하므로)   void swap_array(int* a, int* b) {     int temp; }   a와 b 배열 모두 길이가 5이므로 5번 반복을 진행하면서 a 배열의 원소의 값을 b 배열의 원소의 값과 맞바꿔줘야 한다.   또한 위에서 설명했던 바와 같이 인덱스 번호는 0부터 시작하므로 0~4까지의 반복문으로 작성해주자.   이들을 코드로 보이면 다음과 같다.   void swap_array(int* a, int* b) {     int temp;      for(int i=0; i&lt;5; i++) {         temp = a[i];    // a[i]의 값을 temp에 저장한다.         a[i] = b[i];    // b[i]의 값을 a[i]에 저장한다.         b[i] = temp;    // 마지막으로 위에서 a[i]의 값을 저장해두었던 temp의 값을 b[i]에 저장한다.     } }   temp라는 변수를 설정한 이유가 이해가 가지 않을 수 있다.   이는 우리가 살고 있는 세상에 빗대어 이해하면 조금 더 쉽게 이해할 수 있는데, 예를 들어 우리가 a 접시의 음식과 b 접시의 음식을 서로 맞바꿔야 하는 문제 상황에 처했다고 가정해보자. (물론 이때 전제조건으로서 또 다른 접시의 사용이 가능하다.)   이에 대한 필자의 생각은 다음과 같다.      “또 다른 접시의 사용이 가능하므로 c라는 접시를 하나 더 마련하여 여기에 a, b 두 접시 중 하나의 음식을 c 접시에 먼저 담아두고 서로의 음식을 맞바꾼 뒤, 마지막으로 c의 접시의 음식을 남은 접시에 담는다.”       그러면 독자 여러분은 어떤 선택을 하겠는가? (더 좋은 생각을 가지고 계시다면 댓글 남겨주세요.)    마지막으로 main 함수에서 swap_array의 함수 호출문과 나머지 출력 결과에 대한 적절한 출력문까지 구성해주면 끝이다.   이를 전체 코드로 보이면 다음과 같다.   #include &lt;stdio.h&gt;  void swap_array(int* a, int* b) {     int temp;      for(int i=0; i&lt;5; i++) {         temp = a[i];         a[i] = b[i];         b[i] = temp;     } }  int main() {     int a[5] = {1, 3, 5, 7, 9};     int b[5] = {0, 2, 4, 6, 8};      printf(\"a 배열: \");      for(int i=0; i&lt;5; i++)         printf(\"%d \", a[i]);      printf(\"\\n\");      printf(\"b 배열: \");      for(int i=0; i&lt;5; i++)         printf(\"%d \", b[i]);      printf(\"\\n\\n\");      swap_array(a, b);      printf(\"&lt;&lt; swap_array 호출 후 &gt;&gt;\\n\");      printf(\"a 배열: \");      for(int i=0; i&lt;5; i++)         printf(\"%d \", a[i]);      printf(\"\\n\");      printf(\"b 배열: \");      for(int i=0; i&lt;5; i++)         printf(\"%d \", b[i]);      printf(\"\\n\");      return 0; }  ","categories": ["C","Algorithms"],
        "tags": ["C","Algorithms","Programming","Coding"],
        "url": "http://localhost:4000/c/algorithms/Assign-C-5/",
        "teaser": null
      },{
        "title": "Python 과제: For Loop + Slicing",
        "excerpt":"질문   내용   for문과 슬라이싱을 이용해서 문자열 “BINGO”를 아래와 같은 모양으로 출력하는 프로그램을 작성해 보세요.   실행 결과   BINGO  INGO   NGO    GO     O   답변   내용   먼저 필자는 다음과 같이 bingo라는 변수(Variable)를 하나 만들어 문자열 “BINGO”로 초기화하였다.   bingo = \"BINGO\"   그 후 이중 반복문을 구성하여 바깥쪽 반복문에서는 bingo의 값을 출력하게끔, 안쪽 반복문에서는 공백(Spacing)을 출력하게끔 해주었다.   그러므로 전체 틀을 다음과 같이 잡아준다.   for i in range(0, 5):            for j in range(1, i+1):      위 코드에서 먼저 바깥쪽 반복문부터 설명하면,   i의 값이 0부터 4까지 총 5회 반복되게끔 구성하였는데 이는 변수 bingo에 들어간 문자열(BINGO)의 길이가 5이기 때문이다.   (Python의 경우에는 C/C++과는 다르게 문자열의 마지막에 null 문자를 삽입하지 않으므로 널 문자(Null Character)를 고려하지 않아도 됨.)   (바깥쪽 반복문에 대해서 더 설명할 것은 없는 듯 하다…)   그 다음 안쪽 반복문에 대해 설명하면,   j 값의 범위를 1부터 i+1까지로 설정하였는데 이는 i 값에 따라 출력되는 공백(Spacing)의 수를 다르게 하기 위함이다.   즉, i의 값의 변화에 따른 반복 횟수만을 보이면 다음과 같다.   i의 값이 0일 때는 안쪽 반복문이 실행되지 않지만,   i의 값이 1일 때는 안쪽 반복문이 1회 실행,   i의 값이 2일 때는 안쪽 반복문이 2회 실행,   i의 값이 3일 때는 안쪽 반복문이 3회 실행,   마지막으로 i의 값이 4일 때는 안쪽 반복문이 4회 실행된다.   그러므로 안쪽 반복문 내에 공백(Spacing)을 출력하는 출력문만 작성해주면 되지 않을까?   for i in range(0, 5):            for j in range(1, i+1):         print(' ', end='')   따라서 위의 i 값의 변화에 따른 반복 횟수를 다음과 같이 바꾸어 말할 수 있다.   i의 값이 0일 때는 안쪽 반복문이 실행되지 않지만,   i의 값이 1일 때는 공백 1회 출력,   i의 값이 2일 때는 공백 2회 출력,   i의 값이 3일 때는 공백 3회 출력,   마지막으로 i의 값이 4일 때는 공백 4회 출력된다.   또한, print문을 보면,   print(' ', end='')   두번째 인자로 end=’ ‘를 삽입하였는데 이는 공백문자 출력 후 어느것도 출력하지 않음을 나타내는 것이다.   만약 이것을 설정하지 않는다면, 기본값이 ‘\\n’이어서 공백 출력 이후 자동적으로 개행이 이루어져 우리가 원하는 결과가 출력되지 않을 것이다.   이제 마지막으로 문자열 슬라이싱(Slicing)을 이용하여 BINGO를 출력해보자.      슬라이싱의 범위는 어떻게 구성하는게 좋을까?    바깥쪽 반복문 내 안쪽 반복문 아래에 출력문을 삽입한다면, 아무래도 i의 값을 이용하는 것이 좋지 않을까?   왜냐하면 i의 값이 0부터 4까지 순차적으로 반복하며 증가하기 때문이다.   그러므로 슬라이싱의 범위를 [i:5]로 설정해주자.   이는 다음과 같다.   for i in range(0, 5):            for j in range(1, i+1):         print(' ', end='')     print(bingo[i:5])   아래에 전체 코드를 보이면서 이번 포스팅을 마무리 짓겠다.   전체 코드   bingo = \"BINGO\"  for i in range(0, 5):  # BINGO의 길이가 5이므로 0~4까지 총 5회 반복하는 바깥쪽 반복문          for j in range(1, i+1):     # i의 값에 따라 출력되는 공백(Spacing)의 수가 달라지는 안쪽 반복문         print(' ', end='')     print(bingo[i:5])  ","categories": ["Python","Algorithms"],
        "tags": ["Programming","Implementation","Python"],
        "url": "http://localhost:4000/python/algorithms/Assign-Python-4/",
        "teaser": null
      },{
        "title": "OpenCV Installing & Settings for Mac",
        "excerpt":"내용   Mac에서 OpenCV 설치와 Xcode 설정법을 찾아보던 중 이에 대해 정리가 잘 되어있는 블로그를 발견하였다. (아래 링크 참고)   바로 가기   다만 설정을 다루는 내용에서 몇 가지 아쉬운 점이 있어 이번 포스팅에서는 그에 대한 보충을 해보고자 한다.   링커 플래그(Linker Flag) 추출할 때   위 블로그 포스팅에서는 링커 플래그(Linker Flag)를 추출하기 위해 다음의 명령어를 입력하였는데,   pkg-config --cflags --libs opencv   그러면 다음과 같은 에러 메시지가 뜬다.      그러므로 명령어를 다음으로 변경하여 입력하자.   pkg-config --cflags --libs opencv4   그러면 다음처럼 정상적으로 링커 플래그(Linker Flag)가 추출되는 것을 확인할 수 있다.      Xcode Header Search Paths 설정할 때   또한 위 블로그 포스팅에서는 다음의 경로만 추가해주었다.   /usr/local/include   이렇게 할 경우 헤더파일 선언문을 다음과 같이 작성해주어야 하는데,   #include &lt;opencv4/opencv2/opencv.hpp&gt;   이것 역시 컴파일 시 관련된 파일들을 찾을 수 없다는 에러(Not Found)로 이어지므로 다음 경로도 추가로 입력해주자.   /usr/local/include/opencv4   여기까지 하면 정상적으로 컴파일 되는 것을 확인할 수 있다.   ","categories": ["OpenCV"],
        "tags": ["OpenCV","Settings","Programming","Coding"],
        "url": "http://localhost:4000/opencv/OpenCV-Settings/",
        "teaser": null
      },{
        "title": "C++ 과제: Virtual Function in Inheritance",
        "excerpt":"질문   내용   다음의 상속 계층도를 참조하여 화면에서 student, salesman, housewife의 선택에 따라 파생 클래스의 가상 함수 behavior()가 수행되도록 프로그램을 작성하시오.      답변   내용   이 문제는 상속 계층도에서 클래스명, 함수명, 함수 내용 등 모든 조건이 사전에 주어져 있으므로 비교적 쉽게 풀이가 가능하다.   먼저 문제에 주어진 상속 계층도 내의 behavior 함수에서 출력 구문이 존재하므로 이와 관련 있는 헤더파일(iostream)을 선언하고, 편의를 위해 이름 공간인 std도 사용하자.   즉,   #include &lt;iostream&gt;  using namespace std;   이제 person 클래스를 작성해보자.   위 문제의 상속 계층도를 확인해보면, person 클래스 내에 behavior이라는 가상 함수(Virtual Function)가 존재한다.   그러므로 다음과 같이 코드를 작성해주자.   class person {     public:         virtual void behavior() {}; };   그 후 person 클래스를 부모 클래스로 하는 자식 클래스 student, salesman, housewife 클래스를 작성해주자. (person 클래스가 부모 클래스가 되어야 하므로 person 클래스를 상속해주면 된다.)   class student : public person {     public:         void behavior() {             cout&lt;&lt;\"공부하기\";         } };  class salesman : public person {     public:         void behavior() {             cout&lt;&lt;\"판매하기\";         } };  class housewife : public person {     public:         void behavior() {             cout&lt;&lt;\"집안일 하기\";         } };   이제 main 함수만 작성해주면 되는데, 지금까지 필자의 C++ 글을 모두 읽은 독자분들께 한 가지 질문을 드리겠다.      혹시 위의 코드와 문제를 통해서 뭔가 느껴지는 바가 있지 않던가?       필자가 전에 작성한 다음의 글이 떠오르지는 않았는가?    “C++ Early Binding(Static Binding) &amp; Late Binding(Dynamic Binding)”   아직 위 글을 읽지 않은 독자분들은 먼저 위 글을 읽은 후 main 함수를 어떻게 작성하면 좋을지에 대해 생각해보기 바란다.   필자는 독자 여러분께서 이러한 과정을 모두 거쳤다고 가정하고 이어서 이에 대한 풀이를 보이도록 하겠다.   사실 person 클래스 내의 behavior 함수에 접두사(Prefix)로 virtual 키워드(Keyword)가 붙었으므로, 동적 바인딩(Dynamic Binding) 개념을 이용하여 문제 풀이를 진행해야 한다.   필자가 위 글에서 필자의 생각을 다음과 같이 언급했었는데 이는 절대적인 진리는 아니나 지금과 같이 상속 관계에 놓여있는 클래스들에 대해서는 활용해볼 수 있는 Idea이다.      Early Binding(Static Binding)의 경우에는 컴파일러가 포인터의 자료형에 집중한다면, Late Binding(Dynamic Binding)의 경우에는 컴파일러가 포인터의 자료형이 아닌 그것이 가지고 있는 값에 집중한다.    또한 C++에서 동적 바인딩(Dynamic Binding) 개념을 이용하기 위해서는 멤버 함수(Member Function)에 접두사(Prefix)로 virtual 키워드(Keyword)를 작성해주어야 한다는 것도 위 글에서 설명했었다.   그러므로 지금처럼 문제의 조건에 의해 person 클래스 내의 behavior 함수(Function)에 접두사(Prefix)로 virtual 키워드(Keyword)를 작성해주었고(C++에서 동적 바인딩 개념 이용법), 자식 클래스들이 모두 person 클래스를 상속하므로 포인터형이 person인 포인터 변수를 하나 생성한 후 사용자의 입력에 따라 서로 다른 자식 클래스들(student, salesman, housewife) 중 하나에 대한 인스턴스를 생성하여 이에 대입한 다음, behavior 함수를 호출 해주면 된다.   먼저 다음처럼 main 함수 내에 NULL값을 가지는, 포인터형이 person인 포인터 변수를 선언해주고,   int main(void) {     person* p = NULL; }   사용자가 프로그램에 출력된 내용을 확인한 후, 제시된 메뉴(Menu)를 선택할 수 있도록 적절한 입출력문까지 작성해주자.   int main(void) {     person* p = NULL;      int sel;        // 사용자의 메뉴 선택에 따른 흐름 분기를 위해 정수를 입력받아 저장하기 위한 변수      cout&lt;&lt;\"1. student\"&lt;&lt;endl;     cout&lt;&lt;\"2. salesman\"&lt;&lt;endl;     cout&lt;&lt;\"3. housewife\"&lt;&lt;endl;     cout&lt;&lt;\"select: \";      cin&gt;&gt;sel;       // 사용자가 출력으로 제시된 사항들을 선택(입력)할 수 있는 입력문 작성 }   프로그램에서 사용자가 메뉴를 선택했다면 그에 따르는 기능이 동작해야할 것이다.   그러므로 sel의 값에 따라 흐름을 분기시켜 그에 해당하는 기능이 수행되게끔 해보자.   필자는 전체 틀을 다음과 같이 switch문으로 구성하였다.   switch(sel) {       // 사용자로부터 입력받은 sel의 값이     case 1:         // 1이면         break;     case 2:         // 2이면         break;     case 3:         // 3이면         break;     default:        // 그 외 }   이제 각각에 대해서 기능을 추가해보자.   먼저 1일 때는 student 클래스의 behavior 함수가 호출되어야 하므로 먼저 student 클래스의 인스턴스를 생성하여 다음과 같이 위에서 선언했던 포인터 변수 p에 대입해주자.   switch(sel) {     case 1:         p = new student();         break; }   그 후 behavior 함수를 호출해주자.   switch(sel) {     case 1:         p = new student();         p-&gt;behavior();         break; }   그런데 여기서 끝내면 안된다.   new 연산자를 사용하여 동적 메모리 할당(Dynamic Memory Allocation)을 한 후 모든 기능을 수행하였다면, 마지막에는 메모리를 해제해줘야 한다.   (이에 대해서는 추후에 별도의 강좌로 다룰 예정이다.)   그러므로 다음과 같이 delete 연산자를 사용하여 메모리를 해제해주자.   switch(sel) {     case 1:         p = new student();         p-&gt;behavior();         delete p;         break; }   나머지 기능에 대해서도 동일한 방식으로 작성해주면 된다.   그리고 마지막 default에는 해당 메뉴(Menu)가 없다는 메시지를 출력해주자.   아래에 전체 코드를 보이면서 이번 포스팅을 마무리 짓겠다.   전체 코드   #include &lt;iostream&gt;  using namespace std;  class person {     public:         virtual void behavior() {}; };  class student : public person {     public:         void behavior() {             cout&lt;&lt;\"공부하기\";         } };  class salesman : public person {     public:         void behavior() {             cout&lt;&lt;\"판매하기\";         } };  class housewife : public person {     public:         void behavior() {             cout&lt;&lt;\"집안일 하기\";         } };  int main(void) {     person* p = NULL;      int sel;      cout&lt;&lt;\"1. student\"&lt;&lt;endl;     cout&lt;&lt;\"2. salesman\"&lt;&lt;endl;     cout&lt;&lt;\"3. housewife\"&lt;&lt;endl;     cout&lt;&lt;\"select: \";      cin&gt;&gt;sel;      switch(sel) {         case 1:             p = new student();             p-&gt;behavior();             delete p;             break;         case 2:             p = new salesman();             p-&gt;behavior();             delete p;             break;         case 3:             p = new housewife();             p-&gt;behavior();             delete p;             break;         default:             cout&lt;&lt;\"해당 Menu 없음\";     }         return 0; }  ","categories": ["Cpp"],
        "tags": ["C++","Programming","Coding"],
        "url": "http://localhost:4000/cpp/Assign-Cpp-1/",
        "teaser": null
      },{
        "title": "정보 공유: Github VSCODE Online Editor",
        "excerpt":"내용   급할 때 Github에서 코드를 수정하는 것 대신에 VSCODE Online Editor로 즉시 수정해보자.   이를 위해 코드 수정을 원하는 Github Repository 접속 후 주소창에서 github.com을 github1s.com으로 변경하여 검색한다.   예를 들어, 다음의 Repository 주소를      다음으로 변경한 후,      검색해보면 VSCODE Online Editor가 열리는 것을 확인할 수 있다.      출처  Source  ","categories": ["Info"],
        "tags": ["Info","Programming","Coding"],
        "url": "http://localhost:4000/info/Info-Sharing-1/",
        "teaser": null
      },{
        "title": "Reversing: String Patching",
        "excerpt":"Contents   Prerequisite   이번 포스팅에서는 Radare2를 이용하여 String Patching을 진행해보고자 한다.   이를 위해 필자는 Linux x64 System에서 x64 Executable File을 Target으로 삼았으며,   또한, Example Code로서 이전에 업로드한 포스팅의 예제를 활용하였다.   참고   독자 여러분들은 필자와 동일한 환경을 구성하진 않더라도 비슷한 환경을 구성해주길 바란다.   Purpose   필자는 Compiled Example Code로부터 다음의 기존 출력결과를   1. student 2. salesman 3. housewife select:   다음과 같이 변경하려 한다.   1. test 2. salesman 3. housewife select:   String Patching   먼저 터미널을 실행한다.      Example Code가 있는 곳으로 이동하여,      해당 파일을 컴파일하자. (필자는 Example Code의 Filename을 virtual1.cpp로 작성하였다.)      수정하기 전 실행 결과는 다음과 같다.      Radare2를 본격적으로 사용해보자.   radare2 main     문자열 student이 있는 메모리 상의 위치를 검색해보자.   / student      다음과 같이 메모리 주소 0x00002033가 도출되었으므로,      해당 메모리 주소로 커서를 이동시키자.   s 0x00002033      해당 메모리 주소가 우리가 변경하기를 원하는 문자열이 있는 위치인지를 명확히 하기 위해 다음의 명령어를 입력하여 이를 확인해보자.   px      student와 다른 문자열들로 미루어보아 우리가 수정하고자하는 문자열의 메모리 주소에 위치해 있음을 확인할 수 있다.   또한, 문자열 student가 있는 위치로 커서가 이동한 것도 확인해볼 수 있다.   이제 해당 내용을 변경하기 위해 읽기-쓰기 모드로 전환하자.   oo+      이제 진짜 문자열을 변경해보자.   필자는 위에서 student를 test로 변경한다하였으므로 다음과 같이 입력해주었다.   w test\\x00         C/C++에서는 문자열의 끝을 NULL 문자로 식별하므로 \\x00 삽입을 잊어서는 안된다.    마지막으로 Radare2를 종료한 후,   q   컴파일한 파일을 다시 실행시켜보자.   ./main      기존 문자열 student가 test로 변경된 것을 확인할 수 있다.   ","categories": ["Reversing"],
        "tags": ["Reversing","Programming","Coding"],
        "url": "http://localhost:4000/reversing/Studying_Reversing-1/",
        "teaser": null
      },{
        "title": "C 과제: Finding the y value",
        "excerpt":"질문   내용   다음 함수의 y값을 구하는 프로그램을 작성하시오.   \\[y = 7x^3+6x^2+9ax^2+bx+c\\]  \\[a = 2, b = 3, c = 5, x = 2\\]  답변   내용   이 문제는 주어진 조건들을 식에 대입하여 계산한 후, y값을 찾기만 하면 되는 아주 단순하고 쉬운 문제이다.   먼저 다음의 문제 조건에 해당하는 정보들을 main 함수 내에 변수로 선언해주자.   (모두 정수형이므로 정수형 중 보편적으로 많이 사용되는 int형을 사용해주자.)   \\[a = 2, b = 3, c = 5, x = 2\\]  int main(void) {     int a = 2, b = 3, c = 5, x = 2;      return 0; }   동일한 방식으로 정수형 변수 y도 선언해주어, 다음의 식 계산 후 도출된 값을 저장해주자.   \\[y = 7x^3+6x^2+9ax^2+bx+c\\]  즉,   int main(void) {     int a = 2, b = 3, c = 5, x = 2;     int y = 7*x*x*x+6*x*x+9*a*x*x+b*x+c;      return 0; }   마지막으로 y값을 출력하기 위한 적절한 출력문과 이에 필요한 헤더파일(stdio.h) 선언도 해주자.   #include &lt;stdio.h&gt;  int main(void) {     int a = 2, b = 3, c = 5, x = 2;     int y = 7*x*x*x+6*x*x+9*a*x*x+b*x+c;      printf(\"y값: %d\\n\", y);      return 0; }   위의 방식으로 이 문제를 풀이해도 되지만, 필자는 여기서 한 가지 패턴(Pattern)을 발견하였다.   즉, 다음과 같이 식을 동류항끼리 묶어 정리해보면,   \\[y = 7x^3+(6+9a)x^2+bx+c\\]     주어진 식의 차수가 한 차수씩 작아진다.    그래서 필자는 먼저 주어진 식의 계수들을 배열에 담은 뒤, 반복문을 통해 x의 차수를 줄여나가면서 계산하는 방식으로 코드를 작성해보았다.   즉, 이를 코드로 보이면 다음과 같다.   #include &lt;stdio.h&gt;  // 아래의 a, b, c는 전처리기에 의하여 각각 2, 3, 5로 변경된다.  #define a 2     // 문제에 주어진 a 값은 2이므로 #define b 3     // 문제에 주어진 b 값은 3이므로 #define c 5     // 문제에 주어진 c 값은 5이므로  int main(void) {     int arr[4] = {7, 6+9*a, b, c};      // 전처리기에 의해 arr 배열은 {7, 24, 3, 5}로 초기화가 이루어진다.     int x=2;        // 문제에 주어진 x 값은 2이므로 2로 초기화     int y=0;        // y 값은 0으로 초기화      for(int i=0;i&lt;4;i++) {         // 식의 총 항의 개수(arr 배열의 길이): 0~3까지 총 4회 반복.         for(int j=3;j&gt;i;j--)       // 식의 x 차수: 3-&gt;2-&gt;1-&gt;0, x 차수가 0일 때는 x를 곱할 필요가 없으므로 반복문이 실행되지 않게끔 구성함.              arr[i] *= x;    // arr[0]에 x는 3번-&gt;arr[1]에 x는 2번-&gt;arr[2]에 x는 1번 곱한 후 다시 arr[i]에 저장.              y += arr[i];   // 그리고 arr[i]의 값을 y에 더한다. (주어진 식을 보면 각 항이 더해지고 있으므로)     }          printf(\"%d\\n\", y);      // y 값 출력      return 0; }  ","categories": ["C","Algorithms"],
        "tags": ["C","Algorithms","Programming","Coding"],
        "url": "http://localhost:4000/c/algorithms/Assign-C-6/",
        "teaser": null
      },{
        "title": "C 과제: Unit Conversion",
        "excerpt":"질문   내용   온도를 입력받아 섭씨 온도는 화씨 온도로, 화씨 온도는 섭씨 온도로 변환하는 프로그램을 작성하시오.   “27 C” 또는 “27 F”처럼 섭씨인지 화씨인지 구분할 수 있는 문자를 함께 입력받는다.   함께 입력된 문자가 ‘C’이면 섭씨 온도이므로 화씨 온도를 구해서 출력하고, 입력된 문자가 ‘F’면 화씨 온도이므로 섭씨 온도를 구해서 출력한다.   공식   섭씨 -&gt; 화씨   \\[\\frac{9}{5}C+32=F\\]  화씨 -&gt; 섭씨   \\[(F-32)\\frac{5}{9}=C\\]  실행 결과   온도? 27 C 27.00 C == 80.60 F   답변   내용   이 문제는 공식이 주어져 있어 쉽게 풀이가 가능하다.   먼저 printf, scanf 함수 사용에 필요한 헤더파일(stdio.h)을 선언해준 후, 사용자에게 입력을 요구하는, 실행 결과처럼 출력하는 출력문을 main 함수 내에 작성해주자.   #include &lt;stdio.h&gt;  int main(void) {     printf(\"온도? \");      return 0; }   출력문을 구성해주었으니 입력문을 구성해줄 차례인데 실행 결과부터 살펴보면, 사용자로부터 입력을 받을 때 온도와 그것의 단위 사이가 한 칸 떨어져 있는 것을 확인할 수 있다.   즉, 구분자(Separator) 역할을 하는 공백 문자 하나를 서식문자 사이에 삽입하여 온도와 단위의 입력을 구분해준 것이다.   또한, 정수 값의 온도 뿐 아니라 소수점이 있는 실수 값의 온도도 사용자가 입력할 수 있기 때문에 온도 값을 저장하는 변수를 선언할 때 이것의 자료형을 실수형으로 작성해주자. (이때 필자는 실수형에서 보편적으로 많이 사용되는 double형을 선택하였다.)   물론 단위도 사용자로부터 입력받아야 하므로 문자형 변수도 선언해주자.   #include &lt;stdio.h&gt;  int main(void) {     double temp;        // 사용자로부터 온도를 입력받아 저장하는 변수     char unit;          // 사용자로부터 단위를 입력받아 저장하는 변수      printf(\"온도? \");     scanf(\"%lf %c\", &amp;temp, &amp;unit);      // 사용자로부터 온도와 단위를 입력받음, 온도와 단위를 구분짓는 구분자(Separator)는 하나의 공백이다.      return 0; }   이제 입력한 단위에 대해 프로그램의 흐름을 분기시켜주면 된다.   즉, unit에 저장된 값이 C인 경우나 F인 경우, 또는 그 외의 경우에 대한 조건문을 작성해주자.   그러므로 전체적인 틀은 다음과 같다.   if(unit == 'C') {       // unit의 값이 C라면  }else if(unit == 'F') {         // unit의 값이 F라면  }else {     // 그 외  }   각 조건 내에 적절한 구문을 작성해주기 전에 실행 결과를 다시 살펴보면,   27.00 C == 80.60 F   사용자로부터 입력받은 온도값과 변환된 온도 값들이 모두 소수점 둘째자리까지 표현되어 있음을 확인할 수 있다.   그러므로 printf 함수의 첫 번째 인자 내에 실수형 서식문자 f를 다음처럼 작성해주자.   %.2f      이는 소수점 둘째자리까지의 실수 출력을 의미한다.    이러한 정보들을 종합하여 각 조건 내에 실행될 적절한 구문을 작성해주면 다음과 같다.   if(unit == 'C')     printf(\"%.2f %c == %.2f %c\\n\", temp, unit, (temp*9/5)+32, 'F'); else if(unit == 'F')     printf(\"%.2f %c == %.2f %c\\n\", temp, unit, (temp-32)*5/9, 'C'); else      printf(\"잘못된 문자 입력\\n\");   위 코드에서 unit이 C인 경우의 printf를 살펴보면,   printf(\"%.2f %c == %.2f %c\\n\", temp, unit, (temp*9/5)+32, 'F');   두 번째 인자와 세 번째 인자에는 온도 값을 저장하는 변수 temp와 단위 값을 저장하는 변수 unit이 위치하고, 네 번째와 다섯 번째 인자에는 섭씨 온도를 화씨 온도로 변환하는 식인 (temp*9/5)+32와 문자 ‘F’가 위치하고 있다.   즉, 두 번째 인자와 세 번째 인자는 첫 번째 인자인 문자열 내부의 서식문자 %.2f와 %c에  각각 대응되고 네 번째 인자와 다섯 번째 인자는 첫 번째 인자인 문자열 내부의 == 이후(오른쪽)의 %.2f와 %c에 각각 대응된다.   그러므로 실행 결과에서처럼 사용자가 온도로 27을 입력하고, 단위로 문자 ‘C’를 입력했다면, 다음과 같이 출력될 것이다.   27.00 C == 80.60 F   unit이 F일 때에도 unit이 C일 때와 동일한 방식으로 이해하면 되겠다.   마지막으로 전체 코드를 보이면서 이번 포스팅을 마무리 짓겠다.   전체 코드   #include &lt;stdio.h&gt;  int main(void) {     double temp;      char unit;         printf(\"온도? \");     scanf(\"%lf %c\", &amp;temp, &amp;unit);      if(unit == 'C')         printf(\"%.2f %c == %.2f %c\\n\", temp, unit, (temp*9/5)+32, 'F');     else if(unit == 'F')         printf(\"%.2f %c == %.2f %c\\n\", temp, unit, (temp-32)*5/9, 'C');     else                  printf(\"잘못된 문자 입력\\n\");          return 0; }  ","categories": ["C","Algorithms"],
        "tags": ["C","Algorithms","Programming","Coding"],
        "url": "http://localhost:4000/c/algorithms/Assign-C-7/",
        "teaser": null
      },{
        "title": "Linear Algebra: Matrices and Linear Equations - Matrices",
        "excerpt":"Questions   Question 1   Show that for any square matrix, the matrix \\(A + \\mathbf{A}^\\top\\) is symmetric.   Question 2   If \\(A = (a_{ij})\\) is a square matrix, then the elements \\(a_{ii}\\) are called the diagonal elements. How do the diagonal elements of \\(A\\) and \\(\\mathbf{A}^\\top\\) differ?   Question 3   Define a matrix \\(A\\) to be skew-symmetric if \\(\\mathbf{A}^\\top = -A\\). Show that for any square matrix \\(A\\), the matrix \\(A-\\mathbf{A}^\\top\\) is skew-symmetric.   Question 4   If a matrix is skew-symmetric, what can you say about its diagonal elements?       Answers   Answer 1   the matrix \\(A + \\mathbf{A}^\\top\\) is symmetric.   \\[\\because (A + \\mathbf{A}^\\top)^\\top = (\\mathbf{A}^\\top + A)\\]  \\[= (A+\\mathbf{A}^\\top)\\]  Answer 2   Same   \\[A_{i,j} =   \\begin{pmatrix}   \\color{green}{a_{1,1}} &amp; a_{1,2} &amp; \\cdots &amp; a_{1,j} \\\\   a_{2,1} &amp; \\color{green}{a_{2,2}} &amp; \\cdots &amp; a_{2,j} \\\\   \\vdots  &amp; \\vdots  &amp; \\ddots &amp; \\vdots  \\\\   a_{i,1} &amp; a_{i,2} &amp; \\cdots &amp; \\color{green}{a_{i,j}}   \\end{pmatrix}\\]  \\[\\mathbf{(A)}^\\top_{i,j} =   \\begin{pmatrix}   \\color{red}{a_{1,1}} &amp; a_{2,1} &amp; \\cdots &amp; a_{i,1} \\\\   a_{1,2} &amp; \\color{red}{a_{2,2}} &amp; \\cdots &amp; a_{i,2} \\\\   \\vdots  &amp; \\vdots  &amp; \\ddots &amp; \\vdots  \\\\   a_{1,j} &amp; a_{2,j} &amp; \\cdots &amp; \\color{red}{a_{i,j}}   \\end{pmatrix}\\]  Answer 3   The matrix \\(A - \\mathbf{A}^\\top\\) is a skew-symmetric.   \\[\\because \\mathbf{(A - \\mathbf{A}^\\top)}^\\top = \\mathbf{A}^\\top - A\\]  \\[= -(A - \\mathbf{A}^\\top)\\]  Answer 4   \\[\\text{By skew-symmetric}\\]  \\[a_{ii} = -a_{ii}\\]  \\[\\therefore a_{ii} = 0\\] ","categories": ["Linear Algebra"],
        "tags": ["Mathematics","Linear Algebra"],
        "url": "http://localhost:4000/linear%20algebra/Studying_Linear-1/",
        "teaser": null
      },{
        "title": "ShareLaTeX: Installing & Settings",
        "excerpt":"이번 포스팅에서는 ShareLaTeX를 서버에 설치하고 설정하는 방법에 대해서 알아보고자 한다.   Prerequisites   OS   Version      Ubuntu 20.04.1 (LTS)   Architecture      x86-64       Installing   Docker-CE   먼저 Docker-CE를 설치하자.   $ sudo apt-get update  $ sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common  $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -  $ sudo apt-key fingerprint 0EBFCD88  $ sudo add-apt-repository \\  \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\   $(lsb_release -cs) \\   stable\"  $ sudo apt-get update  $ sudo apt-get install docker-ce docker-ce-cli containerd.io   pip3   docker-compose를 설치하기 위해 pip3도 설치해주자.   sudo apt-get install python3-pip   Docker-Compose   docker-compose를 설치하자.   pip3 install docker-compose   Configuring ShareLaTeX   ShareLaTeX를 설정하자.   디렉토리 생성 및 파일 다운받기   mkdir /etc/sharelatex cd /etc/sharelatex wget https://raw.githubusercontent.com/sharelatex/sharelatex/master/docker-compose.yml   디렉토리 생성   mkdir /var/lib/sharelatex mkdir /var/lib/sharelatex/data mkdir /var/lib/sharelatex/mongodb mkdir /var/lib/sharelatex/redis   Editing a docker-compose.yml   vim docker-compose.yml   From   volumes:     - ~/sharelatex_data:/var/lib/sharelatex   To   volumes:     - /var/lib/sharelatex/data:/var/lib/sharelatex   From   volumes:     - ~/mongo_data:/data/db   To   volumes:     - /var/lib/sharelatex/mongodb:/data/db   From   volumes:     - ~/redis_data:/data   To   volumes:     - /var/lib/sharelatex/redis:/data   From   ports:     - 80:80   To   ports:     - 0.0.0.0:x:80  # x : Listening Port   From   environment:              SHARELATEX_APP_NAME: Overleaf Community Edition              SHARELATEX_MONGO_URL: mongodb://mongo/sharelatex              # Same property, unfortunately with different names in             # different locations             SHARELATEX_REDIS_HOST: redis             REDIS_HOST: redis              ENABLED_LINKED_FILE_TYPES: 'url,project_file'              # Enables Thumbnail generation using ImageMagick             ENABLE_CONVERSIONS: 'true'              # Disables email confirmation requirement             EMAIL_CONFIRMATION_DISABLED: 'true'              # temporary fix for LuaLaTex compiles             # see https://github.com/overleaf/overleaf/issues/695             TEXMFVAR: /var/lib/sharelatex/tmp/texmf-var              ## Set for SSL via nginx-proxy             #VIRTUAL_HOST: 103.112.212.22              # SHARELATEX_SITE_URL: http://sharelatex.mydomain.com             # SHARELATEX_NAV_TITLE: Our ShareLaTeX Instance             # SHARELATEX_HEADER_IMAGE_URL: http://somewhere.com/mylogo.png             # SHARELATEX_ADMIN_EMAIL: support@it.com              # SHARELATEX_LEFT_FOOTER: '[{\"text\": \"Powered by &lt;a href=\\\"https://www.sharelatex.com\\\"&gt;ShareLaTeX&lt;/a&gt; 2016\"},{\"text\": \"Another page I want to link to can be found &lt;a href=\\\"here\\\"&gt;here&lt;/a&gt;\"} ]'             # SHARELATEX_RIGHT_FOOTER: '[{\"text\": \"Hello I am on the Right\"} ]'              # SHARELATEX_EMAIL_FROM_ADDRESS: \"team@sharelatex.com\"              # SHARELATEX_EMAIL_AWS_SES_ACCESS_KEY_ID:             # SHARELATEX_EMAIL_AWS_SES_SECRET_KEY:              # SHARELATEX_EMAIL_SMTP_HOST: smtp.mydomain.com             # SHARELATEX_EMAIL_SMTP_PORT: 587             # SHARELATEX_EMAIL_SMTP_SECURE: false             # SHARELATEX_EMAIL_SMTP_USER:             # SHARELATEX_EMAIL_SMTP_PASS:             # SHARELATEX_EMAIL_SMTP_TLS_REJECT_UNAUTH: true             # SHARELATEX_EMAIL_SMTP_IGNORE_TLS: false             # SHARELATEX_CUSTOM_EMAIL_FOOTER: \"This system is run by department x\"    To   environment:           SHARELATEX_MONGO_URL: mongodb://mongo/sharelatex           SHARELATEX_REDIS_HOST: redis           SHARELATEX_APP_NAME: ShareLaTeX            # Put here the information about your ShareLaTeX site:           SHARELATEX_SITE_URL: https://my.sharelatex.tld           SHARELATEX_NAV_TITLE: ShareLaTeX - My beautiful ShareLaTeX Installation           # Uncomment the following line if you want to display a logo (i.e., of your school or university)           # SHARELATEX_HEADER_IMAGE_URL: http://somewhere.com/mylogo.png           # Put your email address here:           SHARELATEX_ADMIN_EMAIL: my@email.com            SHARELATEX_LEFT_FOOTER: '[{\"text\": \"Powered by &lt;a href=\\\"https://github.com/sharelatex/sharelatex\\\"&gt;ShareLaTeX&lt;/a&gt;\"}]'           SHARELATEX_RIGHT_FOOTER: '[{\"text\": \"Run your own instance on &lt;a href=\\\"https://scaleway.com\\\"&gt;Scaleway&lt;/a&gt;\"} ]'            # Configure the email address that will be displayed in emails sent by ShareLaTeX           SHARELATEX_EMAIL_FROM_ADDRESS: \"my@email.com\"            # Enable the installation behind a proxy           SHARELATEX_BEHIND_PROXY: 'true'           SHARELATEX_SECURE_COOKIE: 'true'            # Set the language of the installation. For example 'en' English, 'de' German, 'fr' French ...           SHARELATEX_SITE_LANGUAGE: 'en'            # Configure the settings for outgoing mails           SHARELATEX_EMAIL_SMTP_HOST: 'localhost'           SHARELATEX_EMAIL_SMTP_PORT: '465'           SHARELATEX_EMAIL_SMTP_SECURE: 'true'           SHARELATEX_EMAIL_SMTP_USER: 'sharelatex'           SHARELATEX_EMAIL_SMTP_PASS: 'YOUR_PASSWORD'           # SHARELATEX_EMAIL_SMTP_TLS_REJECT_UNAUTH: 'true'           # SHARELATEX_EMAIL_SMTP_IGNORE_TLS: 'false'           # Set a footer for outgoing mails:           SHARELATEX_CUSTOM_EMAIL_FOOTER: \"&lt;div&gt;Powered by ShareLaTeX&lt;/div&gt;\"   Docker-Compose up   sudo docker-compose up   Check   웹 주소창에 아래의 형식으로 주소를 입력하여 접속한다.   http://IP:PORT   아래처럼 나오면 성공이다.      Configuring Systemd   먼저 ctrl+c 조합을 이용하여 실행중인 프로세스를 종료시키자.   /etc/systemd/system/   위 경로에 sharelatex.service 파일을 생성하자.   vim /etc/systemd/system/sharelatex.service   그러고 나서 다음을 입력해주자.   [Unit]     Description=ShareLaTeX Service     After=docker.service      [Service]     Type=simple     WorkingDirectory=/etc/sharelatex     ExecStart=/usr/local/bin/docker-compose -f /etc/sharelatex/docker-compose.yml up     ExecStop=/usr/local/bin/docker-compose -f /etc/sharelatex/docker-compose.yml down      [Install]     WantedBy=multi-user.target   파일 저장 후 다음의 명령어들을 순차적으로 터미널에 입력하자.   $ systemctl enable sharelatex  $ systemctl daemon-reload  $ systemctl start sharelatex   Register   Admin 계정을 등록하기 위해 웹 주소창에 아래의 형식으로 주소를 입력하여 접속한 뒤, 계정을 생성해주면 끝이다.   http://IP:PORT/launchpad   References   Docker   ShareLaTeX   ","categories": ["ShareLaTeX","Linux"],
        "tags": ["Mathematics","LaTex","ShareLaTeX","Tool"],
        "url": "http://localhost:4000/sharelatex/linux/Studying_share-1/",
        "teaser": null
      },{
        "title": "Linear Algebra: Matrices and Linear Equations - Multiplication of Matrices #1",
        "excerpt":"Questions   Question 1   Let \\(A\\), \\(B\\) be square matrices of the same size, and assume that \\(AB = BA\\).   Show that   \\((A+B)^{2} = A^{2} + 2AB + B^{2}\\), and \\((A+B)(A-B) = A^{2} - B^{2}\\),   using the distributive law.   Question 2   Let \\(A, B\\) be two square matrices of the same size. We say that \\(A\\) is similar to \\(B\\) if there exists an invertible matrix \\(T\\) such that \\(B = TAT^{-1}\\). Suppose this is the case. Prove:   (a) \\(B\\) is similar to \\(A\\).   (b) \\(A\\) is invertible if and only if \\(B\\) is invertible.   (c) \\(\\mathbf{A}^\\top\\) is similar to \\(\\mathbf{B}^\\top\\).   (d) Suppose \\(A^{n} = O\\) and \\(B\\) is an invertible matrix of the same size as \\(A\\). Show that \\((BAB^{-1})^{n} = O\\).   Question 3   (a) Find a \\(2 \\times 2\\) matrix \\(A\\) such that \\(A^{2} = -I = \\begin{pmatrix}-1&amp;0\\\\ 0&amp;-1\\end{pmatrix}\\).       Answers   Answer 1   \\[(A+B)^{2} = (A+B)(A+B) = A^{2} + AB + BA + B^{2}\\]  \\[(\\text{By the way, } AB = BA)\\]  \\[\\therefore A^{2} + AB + BA + B^{2} = A^{2} + AB + AB + B^{2} = A^{2} + 2AB + B^{2}\\]      \\[(A+B)(A-B) = A^{2} - AB + BA -B^{2}\\]  \\[(\\text{By the way, } AB = BA)\\]  \\[\\therefore A^{2} - AB + BA -B^{2} =  A^{2} - AB + AB -B^{2} = A^{2}-B^{2}\\]  Answer 2   (a)   \\[B = TAT^{-1}\\]  \\[T^{-1}BT = T^{-1}TAT^{-1}T\\]  \\[T^{-1}BT = IAI\\]  \\[(\\because T \\text{ is invertible, } T^{-1}T = TT^{-1} = I)\\]  \\[T^{-1}BT = A\\]  \\[(\\because AI = IA = A)\\]  \\[\\therefore A = T^{-1}BT\\]  (b)   \\[Proof.\\]  \\[B \\text{ is invertible.}\\]  \\[\\therefore BB^{-1} = B^{-1}B = I\\]  \\[\\text{(1) } BB^{-1} = TAT^{-1}B^{-1} = I\\]  \\[(\\because B = TAT^{-1})\\]  \\[T^{-1}BB^{-1}T = T^{-1}TAT^{-1}B^{-1}T = I\\]  \\[T^{-1}TAT^{-1}B^{-1}T = IAT^{-1}B^{-1}T = I\\]  \\[(\\because T \\text { is invertible, } T^{-1}T = TT^{-1} = I)\\]  \\[IAT^{-1}B^{-1}T = AT^{-1}B^{-1}T = I\\]  \\[(\\because AI = IA = A)\\]      \\[\\text{(2) } B^{-1}B = B^{-1}TAT^{-1} = I\\]  \\[(\\because B = TAT^{-1})\\]  \\[T^{-1}B^{-1}BT = T^{-1}B^{-1}TAT^{-1}T = I\\]  \\[T^{-1}B^{-1}TAT^{-1}T = T^{-1}B^{-1}TAI = I\\]  \\[(\\because T \\text { is invertible, } T^{-1}T = TT^{-1} = I)\\]  \\[T^{-1}B^{-1}TAI = T^{-1}B^{-1}TA = I\\]  \\[(\\because AI = IA = A)\\]      \\[AT^{-1}B^{-1}T = T^{-1}B^{-1}TA = I\\]  \\[\\therefore A \\text{ is invertible}\\]  (c)   \\[B = TAT^{-1}\\]  \\[\\mathbf{B}^\\top = \\mathbf{(TAT^{-1})}^\\top\\]  \\[\\mathbf{(TAT^{-1})}^\\top = \\mathbf{(T^{-1})}^\\top \\mathbf{A}^\\top \\mathbf{T}^\\top\\]  \\[(\\because \\text{By the rule for the traspose of a product.})\\]  \\[\\text{Let's replace } \\mathbf{(T^{-1})}^\\top \\text{with } C.\\]  \\[\\mathbf{B}^\\top = \\mathbf{(T^{-1})}^\\top \\mathbf{A}^\\top \\mathbf{T}^\\top = C \\mathbf{A}^\\top C^{-1}\\]  \\[\\therefore \\mathbf{A}^\\top \\text{ is similar to } \\mathbf{B}^\\top\\]  (d)   \\[(BAB^{-1})^{n} = O\\]  \\[(B^{-1}BAB^{-1}B)^{n} = O\\]  \\[(B^{-1}BAB^{-1}B)^{n} = (IAI)^{n}\\]  \\[(\\because \\text{B is invertible, } BB^{-1} = B^{-1}B = I)\\]  \\[(IAI)^{n} = (A)^{n}\\]  \\[(\\because AI = IA = A)\\]  \\[(\\text{By the way, } (A)^{n} = O)\\]  \\[\\therefore (BAB^{-1})^{n} = O\\]  Answer 3   The answer to the question is \\(\\begin{pmatrix}0&amp;1\\\\ -1&amp;0\\end{pmatrix}\\).   My answer to the question is \\(\\begin{pmatrix}i&amp;0\\\\ 0&amp;i\\end{pmatrix}\\).      According to the Jaemin Shin, PhD, my answer is correct. However, he also said my answer is still incorrect. Since the range of value is not specified in the question, it seems to be limited to a real number.    So the answer to the question is \\(\\begin{pmatrix}0&amp;1\\\\ -1&amp;0\\end{pmatrix}\\).  ","categories": ["Linear Algebra"],
        "tags": ["Mathematics","Linear Algebra"],
        "url": "http://localhost:4000/linear%20algebra/Studying_Linear-2/",
        "teaser": null
      },{
        "title": "C 과제: 매크로의 활용 #2",
        "excerpt":"질문   내용   직사각형의 면적을 구하는 함수 매크로와 원의 면적을 구하는 함수 매크로를 정의하고, 각각을 이용하는 프로그램을 작성하시오.   공식   직사각형 면적   \\[\\text{width} \\times \\text{height}\\]  원 면적   \\[radius \\times radius \\times \\pi\\]  실행 결과   도형의 종류(1.직사각형 2.원 0.종료)? 1 가로 세로? 5 10 면적: 50 도형의 종류(1.직사각형 2.원 0.종료)? 2 반지름? 2 면적: 12.566368 도형의 종류(1.직사각형 2.원 0.종료)? 0   답변   내용   이 문제도 공식이 주어져 있어 쉽게 풀이가 가능하다.   사용자로부터 직사각형의 가로와 세로의 길이를 입력받을 수 있는 변수, width와 height를 정수형으로,   원의 반지름을 입력받을 수 있는 변수, radius도 정수형으로 main 함수 내에 선언하자.   (필자는 정수형에서 보편적으로 많이 사용하는 int형을 선택했다.)   int main(void) {     int width, height;     int radius; }   \b또한, 실행결과에서처럼 사용자로부터 메뉴를 입력받아 그에 따라 흐름이 분기되고 있으므로, 메뉴 저장을 위한 변수 select도 정수형으로 main 함수 내에 선언해주자.   int main(void) {     int width, height;     int radius;          int select; }   그리고 메뉴 입력 메시지를 출력하는 출력문과 메뉴를 입력하기 위한 입력문도 작성해주자. (물론 입력 함수와 출력 함수를 사용하기 위해서 stdio.h 헤더파일 선언도 잊지 말자.)   #include &lt;stdio.h&gt;  int main(void) {     int width, height;     int radius;      int select;      printf(\"도형의 종류(1.직사각형 2.원 0.종료)? \");     scanf(\"%d\", &amp;select); }   이제 사용자로부터 입력받은 메뉴에 따라 프로그램의 흐름을 분기시켜줘야 한다.   이를 위해 필자는 switch문을 선택하여 다음과 같이 흐름을 분기시켜주었다.   switch(select) {     case 0:         // select 값이 0이면, 즉 사용자가 정수 0을 입력했다면,         break;      case 1:         // select 값이 1이면, 즉 사용자가 정수 1을 입력했다면,         break;      case 2:         // select 값이 2이면, 즉 사용자가 정수 2를 입력했다면,         break; }   각 흐름들에 따른 적절한 실행문을 삽입하기 전에 직사각형 면적을 구해주는 함수 매크로부터 작성해보자.   필자는 전처리기가 다음의 구문 형식을 만나면,   SQUARE(X, Y)   다음과 같이 직사각형의 면적을 구하는 식으로 대체되게끔 하기 위해   X*Y   매크로를 다음과 같이 작성했다.   #define SQUARE(X, Y) X*Y   표면적으로 문제가 없는 코드처럼 보이나, 다음의 문제들이 존재한다.   만약 필자가 다음과 같은 구문을 작성했다고 가정해보자.   SQUARE(width+1, height+1)   필자의 의도는 전처리기에 의해 다음의 계산식으로 대체되기를 원했으나,   (width+1)*(height+1)   실제 대체 결과는 다음과 같이 된다.   width+1*height+1   이것은 전처리기의 특성(치환)에 기인한 문제이기 때문에 이를 해결하기 위해서는 매크로 함수를 다음과 같이 작성해야 한다.   #define SQUARE(X, Y) (X)*(Y)   또한, 만약 지금처럼 곱셈(*) 연산자가 아닌 뺄셈(-)이나 덧셈(+) 연산자인 상황에서 곱셈(*) 연산자와 같이 우선순위가 더 높은 연산자가 존재하는 상황일 때는 어떨까?   즉, 아래와 같이 두 피연산자 간의 뺄셈 연산을 수행하는 함수 매크로가 존재했을 때,   #define SUBTRACT(X, Y) (X)-(Y)   다음의 연산을 수행한다면, 어떻게 될까?   SUBTRACT(X, Y) * 5   의도했던 것처럼 다음의 식이 계산되는 것이 아닌,   (X-Y)*5   다음과 같이 계산이 진행되어 전혀 엉뚱한 결과값이 도출된다.   X-Y*5   이것 역시 전처리기의 특성(치환)에 기인한 문제이고, 이러한 상황을 미연에 방지하기 위해서라도   다음과 같이 전체적으로 매크로를 한번 더 괄호로 감싸주자.   #define SQUARE(X, Y) ((X)*(Y))   이러한 매크로의 주의사항만 숙지한다면 원의 면적을 구하는 함수 매크로의 작성도 그리 어렵지 않다.   직사각형의 면적을 구하는 매크로 함수를 작성했던것과 같이 원의 면적을 구하는 매크로 함수를 작성해보자.   (지금까지의 내용을 통해 독자 여러분께서 충분히 이해하셨을 것으로 판단해 중간의 사고과정은 생략했다.)   #define CIRCLE(R) ((R)*(R)*3.14)   매크로 함수의 작성이 완료되었으니 각 흐름에 적절한 실행문을 작성해주자.   switch(select) {     case 0:         // select 값이 0이면, 즉 사용자가 정수 0을 입력했다면, 이는 종료 항목 선택을 의미하므로         return 0;       // exit() 함수를 사용해도 된다.         break;      case 1:         // select 값이 1이면, 즉 사용자가 정수 1을 입력했다면, 이는 직사각형 항목 선택을 의미하므로         printf(\"가로 세로? \");         scanf(\"%d %d\", &amp;width, &amp;height);          printf(\"면적: %d\\n\", SQUARE(width, height));         break;      case 2:         // select 값이 2이면, 즉 사용자가 정수 2를 입력했다면, 이는 원 항목 선택을 의미하므로,         printf(\"반지름? \");         scanf(\"%d\", &amp;radius);          printf(\"면적: %f\\n\", CIRCLE(radius));         break; }   또한, 실행결과를 통해 알 수 있듯이 0이 입력되기 전까지는 계속해서 프로그램이 동작해 사용자로부터 메뉴를 입력받아야 하므로, main 함수 내부의 변수 선언문 아래를 무한 루프로 작성해줘야 한다.   이를 반영한 전체코드를 보이면서 이번 포스팅을 마무리 짓겠다.   전체 코드   #include &lt;stdio.h&gt;  #define SQUARE(X, Y) ((X)*(Y)) #define CIRCLE(R) ((R)*(R)*3.14)  int main(void) {     int width, height;     int radius;      int select;      while(1) {         printf(\"도형의 종류(1.직사각형 2.원 0.종료)? \");         scanf(\"%d\", &amp;select);          switch(select) {             case 0:         // select 값이 0이면, 즉 사용자가 정수 0을 입력했다면, 이는 종료 항목 선택을 의미하므로                 return 0;       // exit() 함수를 사용해도 된다.                 break;              case 1:         // select 값이 1이면, 즉 사용자가 정수 1을 입력했다면, 이는 직사각형 항목 선택을 의미하므로                 printf(\"가로 세로? \");                 scanf(\"%d %d\", &amp;width, &amp;height);                  printf(\"면적: %d\\n\", SQUARE(width, height));                 break;              case 2:         // select 값이 2이면, 즉 사용자가 정수 2를 입력했다면, 이는 원 항목 선택을 의미하므로                 printf(\"반지름? \");                 scanf(\"%d\", &amp;radius);                  printf(\"면적: %f\\n\", CIRCLE(radius));                 break;         }     } }  ","categories": ["C","Algorithms"],
        "tags": ["C","Algorithms","Programming","Coding"],
        "url": "http://localhost:4000/c/algorithms/Assign-C-8/",
        "teaser": null
      },{
        "title": "Linear Algebra: Matrices and Linear Equations - Multiplication of Matrices #2",
        "excerpt":"Questions   Question 1   Rotations. Let \\(R(\\theta)\\) be the matrix given by   \\[R(\\theta) = \\begin{pmatrix}\\cos{\\theta}&amp;-\\sin{\\theta}\\\\ \\sin{\\theta}&amp;\\cos{\\theta}\\end{pmatrix}.\\]  (a) Show that for any two numbers \\(\\theta_{1}\\), \\(\\theta_{2}\\) we have   \\[R(\\theta_{1})R(\\theta_{2}) = R(\\theta_{1} + \\theta_{2}).\\]  [You will have to use the addition formulas for sine and cosine.]   (b) Show that the matrix \\(R(\\theta)\\) has an inverse, and write down this inverse.   (c) Let \\(A = R(\\theta)\\). Show that   \\[A^{2} = \\begin{pmatrix}\\cos{2\\theta}&amp;-\\sin{2\\theta}\\\\ \\sin{2\\theta}&amp;\\cos{2\\theta} \\end{pmatrix}.\\]  (d) Determine \\(A^{n}\\) for any positive integer \\(n\\). Use induction.   Question 2   For any vector \\(X\\) in \\(R^{2}\\) let \\(Y = R(\\theta)X\\) be its rotation by an angle \\(\\theta\\). Show that \\(\\left\\|Y\\right\\| = \\left\\|X\\right\\|.\\)   Question 3   Let \\(A\\) be a square matrix which is of the form   \\[\\begin{pmatrix}a_{11}&amp;*&amp;\\cdots\\cdots&amp;&amp;*\\\\ 0&amp;a_{22}&amp;*&amp;\\cdots&amp;*\\\\ \\vdots&amp;&amp;\\ddots&amp;&amp;\\vdots\\\\ &amp;&amp;&amp;&amp;*\\\\ 0&amp;\\cdots\\cdots&amp;0&amp;&amp;a_{nn}\\end{pmatrix}\\]  The notation means that all elements below the diagonal are equal to 0, and the elements above the diagonal are arbitrary. One may express this property by saying that   \\[a_{ij}=0 \\text{ if } i&gt;j.\\]  Such a matrix is called upper triangular. If \\(A\\), \\(B\\) are upper triangular matrices(of the same size) what can you say about the diagonal elements of \\(AB\\)?       Answers   Answer 1   (a)   \\[R(\\theta_{1})R(\\theta_{2}) = \\begin{pmatrix}\\cos{\\theta_{1}}&amp;-\\sin{\\theta_{1}}\\\\ \\sin{\\theta_{1}}&amp;\\cos{\\theta_{1}}\\end{pmatrix}\\begin{pmatrix}\\cos{\\theta_{2}}&amp;-\\sin{\\theta_{2}}\\\\ \\sin{\\theta_{2}}&amp;\\cos{\\theta_{2}}\\end{pmatrix}\\]  \\[=\\begin{pmatrix}\\cos{\\theta_{1}}\\cos{\\theta_{2}}-\\sin{\\theta_{1}}\\sin{\\theta_{2}}&amp;-\\cos{\\theta_{1}}\\sin{\\theta_{2}}-\\sin{\\theta_{1}}\\cos{\\theta_{2}}\\\\ \\sin{\\theta_{1}}\\cos{\\theta_{2}}+\\cos{\\theta_{1}}\\sin{\\theta_{2}}&amp;-\\sin{\\theta_{1}}\\sin{\\theta_{2}}+\\cos{\\theta_{1}}\\cos{\\theta_{2}} \\end{pmatrix}\\]  \\[=\\begin{pmatrix}\\cos{(\\theta_{1}+\\theta_{2})}&amp;-\\sin{(\\theta_{1}+\\theta_{2})}\\\\ \\sin{(\\theta_{1}+\\theta_{2})}&amp;\\cos{(\\theta_{1}+\\theta_{2})} \\end{pmatrix}=R(\\theta_{1}+\\theta_{2})\\]  (b)   The answer to the question is \\(R(-\\theta)\\)   My answer to the question is \\(\\begin{pmatrix}\\cos{\\theta}&amp;\\sin{\\theta}\\\\ -\\sin{\\theta}&amp;\\cos{\\theta} \\end{pmatrix}\\)   Both answers are correct.   \\[\\because \\begin{pmatrix}\\cos{(-\\theta)}&amp;-\\sin{(-\\theta)}\\\\ \\sin{(-\\theta)}&amp;\\cos{(-\\theta)}\\end{pmatrix} = \\begin{pmatrix}\\cos{\\theta}&amp;\\sin{\\theta}\\\\ -\\sin{\\theta}&amp;\\cos{\\theta} \\end{pmatrix}\\]  \\[(\\because \\sin(-\\theta) = -\\sin(\\theta),\\text{ } \\cos(-\\theta) = \\cos(\\theta))\\]  (c)   \\[A = R(\\theta)\\]  \\[A^2 = \\begin{pmatrix}\\cos{\\theta}&amp;-\\sin{\\theta}\\\\ \\sin{\\theta}&amp;\\cos{\\theta} \\end{pmatrix}\\begin{pmatrix}\\cos{\\theta}&amp;-\\sin{\\theta}\\\\ \\sin{\\theta}&amp;\\cos{\\theta} \\end{pmatrix}\\]  \\[=\\begin{pmatrix}\\cos^2{\\theta}-\\sin^2{\\theta}&amp;-2\\sin{\\theta}\\cos{\\theta}\\\\ 2\\sin{\\theta}\\cos{\\theta}&amp;\\cos^2{\\theta}-\\sin^2{\\theta} \\end{pmatrix} = \\begin{pmatrix}\\cos{2\\theta}&amp;-\\sin{2\\theta}\\\\ \\sin{2\\theta}&amp;\\cos{2\\theta} \\end{pmatrix}\\]  \\[(\\because \\sin{2\\theta} = \\sin{(\\theta+\\theta)} = \\sin{\\theta}\\cos{\\theta}+\\cos{\\theta} sin{\\theta} = 2\\sin{\\theta}\\cos{\\theta})\\]  \\[(\\because \\cos{2\\theta} = \\cos{(\\theta+\\theta)} = \\cos^2{\\theta}-\\sin^2{\\theta})\\]  (d)   \\[A=\\begin{pmatrix}\\cos{\\theta}&amp;-\\sin{\\theta}\\\\ \\sin{\\theta}&amp;\\cos{\\theta} \\end{pmatrix}\\]  \\[A^{2}=\\begin{pmatrix}\\cos{2\\theta}&amp;-\\sin{2\\theta}\\\\ \\sin{2\\theta}&amp;\\cos{2\\theta} \\end{pmatrix}\\]  \\[\\vdots\\]  \\[A^{k} = \\begin{pmatrix}\\cos{k\\theta}&amp;-\\sin{k\\theta} \\\\ \\sin{k\\theta}&amp;\\cos{k\\theta} \\end{pmatrix}?\\]  Assume True:   \\[A^{k} = \\begin{pmatrix}\\cos{k\\theta}&amp;-\\sin{k\\theta} \\\\ \\sin{k\\theta}&amp;\\cos{k\\theta} \\end{pmatrix}\\]  Show True:   \\[A^{k+1} = \\begin{pmatrix}\\cos{(k+1)\\theta}&amp;-\\sin{(k+1)\\theta} \\\\ \\sin{(k+1)\\theta}&amp;\\cos{(k+1)\\theta} \\end{pmatrix}\\]      \\[Proof.\\]  \\[A^{k+1} = A^{k}A = AA^{k} = \\begin{pmatrix}\\cos{\\theta}&amp;-\\sin{\\theta}\\\\ \\sin{\\theta}&amp;\\cos{\\theta} \\end{pmatrix}\\begin{pmatrix}\\cos{k\\theta}&amp;-\\sin{k\\theta}\\\\ \\sin{k\\theta}&amp;\\cos{k\\theta} \\end{pmatrix}\\]  \\[=\\begin{pmatrix}\\cos{\\theta}\\cos{k\\theta}-\\sin{\\theta}\\sin{k\\theta}&amp;-\\cos{\\theta}\\sin{k\\theta}-\\sin{\\theta}\\cos{k\\theta}\\\\ \\sin{\\theta}\\cos{k\\theta}+\\cos{\\theta}\\sin{k\\theta}&amp;-\\sin{\\theta}\\sin{k\\theta}+\\cos{\\theta}\\cos{k\\theta} \\end{pmatrix}\\]  \\[=\\begin{pmatrix}\\cos{(k+1)\\theta}&amp;-\\sin{(k+1)\\theta} \\\\ \\sin{(k+1)\\theta}&amp;\\cos{(k+1)\\theta} \\end{pmatrix}\\]      \\[\\because \\begin{pmatrix}\\cos{(k+1)\\theta}&amp;-\\sin{(k+1)\\theta} \\\\ \\sin{(k+1)\\theta}&amp;\\cos{(k+1)\\theta} \\end{pmatrix} = \\begin{pmatrix}\\cos{k\\theta}\\cos{\\theta}-\\sin{k\\theta}\\sin{\\theta}&amp;-(\\sin{k\\theta}\\cos{\\theta}+\\cos{k\\theta}\\sin{\\theta})\\\\ \\sin{k\\theta}\\cos{\\theta}+\\cos{k\\theta}\\sin{\\theta}&amp;\\cos{k\\theta}\\cos{\\theta}-\\sin{k\\theta}\\sin{\\theta} \\end{pmatrix}\\]      So \\(A^{k+1}\\) is true.   \\[\\therefore \\text{The given statement is true for all k.}\\]  Answer 2   \\[Y = R(\\theta)X = \\begin{pmatrix}\\cos{\\theta}&amp;-\\sin{\\theta}\\\\ \\sin{\\theta}&amp;\\cos{\\theta} \\end{pmatrix}\\begin{pmatrix}x_{1}\\\\ x_{2}\\end{pmatrix}\\]  \\[(\\because \\text{for any vector } X \\text{ in } R^2.)\\]  \\[=\\begin{pmatrix}\\cos{\\theta}&amp;-\\sin{\\theta}\\\\ \\sin{\\theta}&amp;\\cos{\\theta} \\end{pmatrix}\\begin{pmatrix}x1\\\\ x2\\end{pmatrix}=\\begin{pmatrix}{x_{1}}\\cos{\\theta}-{x_{2}}\\sin{\\theta}\\\\ {x_{1}}\\sin{\\theta}+{x_{2}}\\cos{\\theta} \\end{pmatrix}\\]  \\[\\therefore y_{1} = {x_{1}}\\cos{\\theta}-{x_{2}}\\sin{\\theta}, y_{2} = {x_{1}}\\sin{\\theta}+{x_{2}}\\cos{\\theta}\\]      \\[Y^{2} = {y_{1}}^2+{y_{2}}^2\\]  \\[={x_{1}}^2\\cos^2{\\theta}-2{x_{1}}{x_{2}}\\cos{\\theta}\\sin{\\theta}+{x_{2}}^2\\sin^2{\\theta}+{x_{1}}^2\\sin^2{\\theta}+2{x_{1}}{x_{2}}\\sin{\\theta}\\cos{\\theta}+{x_{2}}^2\\cos^2{\\theta}\\]  \\[={x_{1}}^2(\\cos^2{\\theta}+\\sin^2{\\theta})-2{x_{1}}{x_{2}}\\cos{\\theta}\\sin{\\theta}+2{x_{1}}{x_{2}}\\sin{\\theta}\\cos{\\theta}+{x_{2}}^2(\\sin^2{\\theta}+\\cos^2{\\theta})\\]  \\[={x_{1}}^2+{x_{2}}^2\\]  \\[(\\because \\sin^2{\\theta}+\\cos^2{\\theta} = 1)\\]  \\[=X^{2}\\]      \\[\\therefore \\left\\|Y\\right\\| = \\left\\|X\\right\\|.\\]  Answer 3   Let \\(B\\) be the matrix given by   \\[B = \\begin{pmatrix}b_{11}&amp;*&amp;\\cdots\\cdots&amp;&amp;*\\\\ 0&amp;b_{22}&amp;*&amp;\\cdots&amp;*\\\\ \\vdots&amp;&amp;\\ddots&amp;&amp;\\vdots\\\\ &amp;&amp;&amp;&amp;*\\\\ 0&amp;\\cdots\\cdots&amp;0&amp;&amp;b_{nn}\\end{pmatrix}\\]  Also, The above-mentioned A was:   \\[\\begin{pmatrix}a_{11}&amp;*&amp;\\cdots\\cdots&amp;&amp;*\\\\ 0&amp;a_{22}&amp;*&amp;\\cdots&amp;*\\\\ \\vdots&amp;&amp;\\ddots&amp;&amp;\\vdots\\\\ &amp;&amp;&amp;&amp;*\\\\ 0&amp;\\cdots\\cdots&amp;0&amp;&amp;a_{nn}\\end{pmatrix}\\]  Thus,   \\[AB = \\begin{pmatrix}a_{11}b_{11}&amp;*&amp;\\cdots\\cdots&amp;&amp;*\\\\ 0&amp;a_{22}b_{22}&amp;*&amp;\\cdots&amp;*\\\\ \\vdots&amp;&amp;\\ddots&amp;&amp;\\vdots\\\\ &amp;&amp;&amp;&amp;*\\\\ 0&amp;\\cdots\\cdots&amp;0&amp;&amp;a_{nn}b_{nn}\\end{pmatrix}\\]      \\[\\therefore \\text{The diagonal elements of AB are } a_{11}b_{11}, \\cdots, a_{nn}b_{nn}\\] ","categories": ["Linear Algebra"],
        "tags": ["Mathematics","Linear Algebra"],
        "url": "http://localhost:4000/linear%20algebra/Studying_Linear-3/",
        "teaser": null
      },{
        "title": "OpenCV 과제: 영상 색상 채우기 #1",
        "excerpt":"질문   내용   다음 영상 이름은 “hwfig5-1.jpg”이다. 이 영상에 대해 다음을 프로그래밍하시오.              위 영상을 Mat img1 = imread() 함수를 이용하여 grayscale 영상으로 읽어 오시오.            또 다른 영상을 저장하기 위해 Mat img2;로 하고, 이것은 칼라(3채널)로 저장하기 위해 선언하시오.            위 영상에 대해 히스토그램을 구하시오.            히스토그램에서 최대 peak가 되는 값 4개를 구하시오. (육안으로…)            각 4개 peak점의 가운데 값을 문턱치로 사용하여 가장 어두운 직사각형은 파랑색, 원은 녹색, 삼각형은 빨강색, 배경은 노랑색으로 하여 img2를 만들어 display하시오.       답변   내용   독자 여러분께서 OpenCV 설치 및 설정을 완료했다는 전제하에 설명을 진행하겠다. (그러므로 아직 설치하지 않았거나 설정하지 않았다면 먼저 이것들을 해결하고 오길 바란다.)   필자가 아마 이 날 캠핑에 갔었던 것으로 기억하고 있는데, 그곳에서 이 과제를 해결해드렸던 기억이 난다.   (과제 마감까지 불과 3시간을 남겨두고;;)   필자가 듣던 바에 의하면 이쪽 학과의 4학년 분들이나 대학원생분들께서 OpenCV와 관련된 공부를 하신다는 것을 알고 있다.   필자는 OpenCV와 관련한 이론을 빠삭히 알고 있지는 못하며, 더군다나 이쪽 학과와는 전혀 관련없는 학과에 재학중인 관계로 이론적인 부분에서 밀리더라도 양해부탁드린다.   (잘못된 내용 잡아서 댓글 남겨주시면 감사드리겠습니다.)   필자는 이 문제를 풀이하기 위해 오로지 직관만 이용하였음을 밝힌다.   암튼 각설하고 풀이를 진행하겠다.   일단 문제에서 시키는 대로 순차적으로 풀이를 진행해주면 된다.   먼저 1번부터 해결해보자.      위 영상을 Mat img1 = imread() 함수를 이용하여 grayscale 영상으로 읽어 오시오.    위에서 언급했던 바와 같이 Mat에 대해서 아는 것이 없어서 인터넷에 검색해봤다.   검색을 통해 Mat는 클래스이고, OpenCV에서 가장 기본이 되는 데이터 타입이며, 행렬 구조체라는 것을 파악할 수 있었다.   또한, imread() 함수에 대해서도 아는것이 없어서 아래의 레퍼런스 문서를 확인해보니   Reference   다음과 같았다.   imread()   Mat cv::imread(const String&amp; filename, int flags = IMREAD_COLOR)   반환형이 위에서 인터넷 검색을 통해 파악했던 Mat이고, 매개변수들의 이름과 기본값을 통해서 첫 번째 인자로는 읽어들이고자 하는 이미지 파일명을, 두 번째 인자로는 색상 채널과 관련된 flags들을 보내주면 된다는 것을 파악하였다.   또한, Mat는 다음의 헤더파일에 선언되어 있고,   #include &lt;opencv2/core/mat.hpp&gt;   imread() 함수는 다음의 헤더파일에 선언되어 있다하니   #include &lt;opencv2/imgcodecs.hpp&gt;   이러한 헤더파일들을 포함시켜주면 되겠다.   그런데 필자는 이러한 과정이 번거로워 opencv2/opencv.hpp 헤더파일만 포함시켰다.   아래에 opencv.hpp의 내용을 보이겠다.   /*M/////////////////////////////////////////////////////////////////////////////////////// // //  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING. // //  By downloading, copying, installing or using the software you agree to this license. //  If you do not agree to this license, do not download, install, //  copy or use the software. // // //                           License Agreement //                For Open Source Computer Vision Library // // Copyright (C) 2000-2008, Intel Corporation, all rights reserved. // Copyright (C) 2009-2010, Willow Garage Inc., all rights reserved. // Third party copyrights are property of their respective owners. // // Redistribution and use in source and binary forms, with or without modification, // are permitted provided that the following conditions are met: // //   * Redistribution's of source code must retain the above copyright notice, //     this list of conditions and the following disclaimer. // //   * Redistribution's in binary form must reproduce the above copyright notice, //     this list of conditions and the following disclaimer in the documentation //     and/or other materials provided with the distribution. // //   * The name of the copyright holders may not be used to endorse or promote products //     derived from this software without specific prior written permission. // // This software is provided by the copyright holders and contributors \"as is\" and // any express or implied warranties, including, but not limited to, the implied // warranties of merchantability and fitness for a particular purpose are disclaimed. // In no event shall the Intel Corporation or contributors be liable for any direct, // indirect, incidental, special, exemplary, or consequential damages // (including, but not limited to, procurement of substitute goods or services; // loss of use, data, or profits; or business interruption) however caused // and on any theory of liability, whether in contract, strict liability, // or tort (including negligence or otherwise) arising in any way out of // the use of this software, even if advised of the possibility of such damage. // //M*/  #ifndef OPENCV_ALL_HPP #define OPENCV_ALL_HPP  // File that defines what modules where included during the build of OpenCV // These are purely the defines of the correct HAVE_OPENCV_modulename values #include \"opencv2/opencv_modules.hpp\"  // Then the list of defines is checked to include the correct headers // Core library is always included --&gt; without no OpenCV functionality available #include \"opencv2/core.hpp\"  // Then the optional modules are checked #ifdef HAVE_OPENCV_CALIB3D #include \"opencv2/calib3d.hpp\" #endif #ifdef HAVE_OPENCV_FEATURES2D #include \"opencv2/features2d.hpp\" #endif #ifdef HAVE_OPENCV_DNN #include \"opencv2/dnn.hpp\" #endif #ifdef HAVE_OPENCV_FLANN #include \"opencv2/flann.hpp\" #endif #ifdef HAVE_OPENCV_HIGHGUI #include \"opencv2/highgui.hpp\" #endif #ifdef HAVE_OPENCV_IMGCODECS #include \"opencv2/imgcodecs.hpp\" #endif #ifdef HAVE_OPENCV_IMGPROC #include \"opencv2/imgproc.hpp\" #endif #ifdef HAVE_OPENCV_ML #include \"opencv2/ml.hpp\" #endif #ifdef HAVE_OPENCV_OBJDETECT #include \"opencv2/objdetect.hpp\" #endif #ifdef HAVE_OPENCV_PHOTO #include \"opencv2/photo.hpp\" #endif #ifdef HAVE_OPENCV_STITCHING #include \"opencv2/stitching.hpp\" #endif #ifdef HAVE_OPENCV_VIDEO #include \"opencv2/video.hpp\" #endif #ifdef HAVE_OPENCV_VIDEOIO #include \"opencv2/videoio.hpp\" #endif  #endif   이렇듯 opencv.hpp는 대부분 필요한 헤더파일들을 다 포함시켜준다.   그 다음 이미지 파일명과 문제에서 요구한 GrayScale에 해당하는 flag를 인자로 보내주고, 그에 따른 반환값을 img1에 담자.   필자는 아래의 경로에 이미지 파일을 두었다.   /Users/hexk/Desktop/test1.jpg   즉,   Mat img1 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_GRAYSCALE);   2번도 마찬가지 방식으로 진행하면 된다.      또 다른 영상을 저장하기 위해 Mat img2;로 하고, 이것은 칼라(3채널)로 저장하기 위해 선언하시오.    문제에서 3 Channel Color를 원했으니 그에 해당하는 flag(IMREAD_COLOR)만 인자로 넘겨주자.   즉,   Mat img2 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_COLOR);   자 이제 대망의 3번이다.      위 영상에 대해 히스토그램을 구하시오.    히스토그램을 그리는 함수를 작성할 차례인데, 필자는 코드의 재사용을 고려하여 함수 draw_Histogram(Return Type: Mat Type, Parameter Type: Mat Reference Type)을 작성했다.   또한, 히스토그램을 그리기 위해 아래의 공식 문서의 예제를 참고했다.   Reference   먼저 히스토그램을 표시할 이미지를 생성하자.   Mat draw_Histogram(Mat&amp; hist) {     int hist_w = 2048;     int hist_h = 500;     int hist_size = 350;     int bin_w = cvRound((double)hist_w/hist_size);      Mat histImage(hist_h, hist_w, CV_8UC3, Scalar(0, 0, 0)); }   인자로 받은 hist 값을 normalize하자.   Mat draw_Histogram(Mat&amp; hist) {     int hist_w = 2048;     int hist_h = 500;     int hist_size = 350;     int bin_w = cvRound((double)hist_w/hist_size);      Mat histImage(hist_h, hist_w, CV_8UC3, Scalar(0, 0, 0));      normalize(hist, hist, 0, histImage.rows, NORM_MINMAX, -1, Mat()); }   (필자는 편의를 위해 이름공간인 cv를 사용했다.)   필자는 흰색으로 채워진 볼록 다각형을 그리기 위해 fillConvexPoly Function을 이용했다.   공식 문서에 의하면, fillConvexPoly Function은 다음과 같다.   void cv::fillConvexPoly(InputOutputArray img,                          const Point* pts,                         int npts,                         const Scalar&amp; color,                         int lineType = LINE_8,                         int shift = 0 )   즉, 위에서 생성한 Mat type의 histImage를 첫 번째 인자로 넘겨주고, 점들을 저장한 배열 pts를 두 번째 인자로, 점들의 개수를 세 번째 인자로, 색깔은 Scalar(255, 255, 255)(흰색)를 네 번째 인자로 넘겨주자.   이를 코드로 보이면 다음과 같다.   Mat draw_Histogram(Mat&amp; hist) {     int hist_w = 2048;     int hist_h = 500;     int hist_size = 350;     int bin_w = cvRound((double)hist_w/hist_size);      Mat histImage(hist_h, hist_w, CV_8UC3, Scalar(0, 0, 0));      normalize(hist, hist, 0, histImage.rows, NORM_MINMAX, -1, Mat());      for(int i=1; i&lt;hist_size; i++) {         Point pts[] = {Point(bin_w * (i-1), hist_h), Point(bin_w * i, hist_h), Point(bin_w * i, hist_h - cvRound(hist.at&lt;float&gt;(i))), Point(bin_w*(i-1), hist_h-cvRound(hist.at&lt;float&gt;(i-1))), Point(bin_w*(i-1)), hist_h};     // 이렇듯 Point(2차원 점) 객체를 생성하여 Point 배열 pts에 담았다.          fillConvexPoly(histImage, pts, 5, Scalar(255, 255, 255));     } }   이제 히스토그램 확인을 위해 imshow Function을 호출하자.   또한, histImage를 반환하자.   (4번째 문제에서 요구한 바(히스토그램 위에 Peaks를 찍어야 하지 않겠는가?)를 충족시키기 위해)   Mat draw_Histogram(Mat&amp; hist) {     int hist_w = 2048;     int hist_h = 500;     int hist_size = 350;     int bin_w = cvRound((double)hist_w/hist_size);      Mat histImage(hist_h, hist_w, CV_8UC3, Scalar(0, 0, 0));      normalize(hist, hist, 0, histImage.rows, NORM_MINMAX, -1, Mat());      for(int i=1; i&lt;hist_size; i++) {         Point pts[] = {Point(bin_w * (i-1), hist_h), Point(bin_w * i, hist_h), Point(bin_w * i, hist_h - cvRound(hist.at&lt;float&gt;(i))), Point(bin_w*(i-1), hist_h-cvRound(hist.at&lt;float&gt;(i-1))), Point(bin_w*(i-1), hist_h)};          fillConvexPoly(histImage, pts, 5, Scalar(255, 255, 255));     }      imshow(\"Histogram\", histImage);      return histImage; }   이제 main 함수로 돌아가서 나머지 histogram 설정을 마무리하자.   먼저 histSize를 설정하자.   int main(void) {     int histSize = 350;      return 0; }   그 후 값의 범위도 설정해주자.   int main(void) {     int histSize = 350;      float range[] = {0, 256};     const float* histRange = {range};      return 0; }   histSize를 동일한 크기로 만들고 히스토그램을 비우기 위한 bool형 변수도 설정 해주자. (아래에서 calcHist 함수의 인자로 보내줄 예정.)   int main(void) {     int histSize = 350;      float range[] = {0, 256};     const float* histRange = {range};      bool uniform = true, accumulate = false;      return 0; }   마지막으로 히스토그램을 계산하자.   이는 OpenCV 함수 cv::calcHist를 이용하면 된다.   cv::calcHist는 다음과 같으며,   void cv::calcHist(const Mat* images,                   int nimages,                   const int* channels,                   InputArray mask,                   OutputArray hist,                   int dims,                   const int* histSize,                   const float** ranges,                   bool uniform = true,                   bool accumulate = false )   첫 번째 인자로는 원본 배열(grayscale로 받아들인 img1)을, 두 번째 인자로는 첫 번째 배열의 수(1)를, 세 번째 인자로는 측정될 채널 배열(각 배열은 단일 채널이므로 0)을, 네 번째 인자로는 히스토그램이 저장될 Mat 객체(새로 생성하여 보내주자)를, 다섯 번째 인자로는 히스토그램의 차원(1)을, 여섯 번째 인자로는 histSize(histSize의 주소)를, 일곱 번째 인자로는 각 차원마다 측정될 값들의 범위(histRange의 주소)를, 여덟 번째와 아홉 번째 인자로는 각각 위에서 설정해둔 bool 변수인 uniform과 accumulate를 인자로 보내주면 된다.   즉, 이를 코드로 보이면 다음과 같다.   int main(void) {     int histSize = 350;      float range[] = {0, 256};     const float* histRange = {range};      bool uniform = true, accumulate = false;      Mat b_hist;     // 히스토그램이 저장될 Mat 객체 생성      calcHist(&amp;img1, 1, 0, Mat(), b_hist, 1, &amp;histSize, &amp;histRange, uniform, accumulate);      return 0; }   그 후 b_hist 객체를 우리가 위에서 작성한 draw_Histogram 함수의 인자로 보내주면 된다.   (물론 Peaks들을 그려진 히스토그램 위에 그려야 하므로, Mat 객체를 하나 더 생성하여 draw_Histogram의 반환값을 저장하자.)   즉,   int main(void) {     int histSize = 350;      float range[] = {0, 256};     const float* histRange = {range};      bool uniform true, accumulate = false;      Mat b_hist;     // 히스토그램이 저장될 Mat 객체 생성     Mat histImg;    // draw_histogram 반환값을 저장하기 위한 Mat 객체 생성      calcHist(&amp;img1, 1, 0, Mat(), b_hist, 1, &amp;histSize, &amp;histRange, uniform, accumulate);      histImg = draw_Histogram(b_hist);      return 0; }   마지막으로 잘 출력되는지 확인하기 전에 waitKey() Function도 넣어주자. (이 함수를 호출하지 않으면, 프로그램이 바로 종료되어 히스토그램이 잘 출력되는지 확인할 수 없다.)   int main(void) {     int histSize = 350;      float range[] = {0, 256};     const float* histRange = {range};      bool uniform true, accumulate = false;      Mat b_hist;     // 히스토그램이 저장될 Mat 객체 생성     Mat histImg;    // draw_histogram 반환값을 저장하기 위한 Mat 객체 생성      calcHist(&amp;img1, 1, 0, Mat(), b_hist, 1, &amp;histSize, &amp;histRange, uniform, accumulate);      histImg = draw_Histogram(b_hist);      waitKey();      return 0; }   여기까지 했으면 히스토그램은 완성이다.   이제 프로그램을 실행해보자.   아래와 같이 나오면 성공이다.      지금까지 우리가 작성한 전체 코드를 보이면서, 우선 여기에서 한번 끊겠다.   (한 강좌가 너무 길어질 듯하여…)   나머지 문제들은 2편(필요하다면 3편에 걸쳐)에서 풀이하도록 하겠다.   전체 코드   #include &lt;opencv2/opencv.hpp&gt;  using namespace cv;  Mat draw_Histogram(Mat&amp; hist) {     int hist_w = 2048;     int hist_h = 500;     int hist_size = 350;     int bin_w = cvRound((double)hist_w/hist_size);      Mat histImage(hist_h, hist_w, CV_8UC3, Scalar(0, 0, 0));      normalize(hist, hist, 0, histImage.rows, NORM_MINMAX, -1, Mat());      for(int i=1; i&lt;hist_size; i++) {         Point pts[] = {Point(bin_w * (i-1), hist_h), Point(bin_w * i, hist_h), Point(bin_w * i, hist_h - cvRound(hist.at&lt;float&gt;(i))), Point(bin_w*(i-1), hist_h-cvRound(hist.at&lt;float&gt;(i-1))), Point(bin_w*(i-1), hist_h)};          fillConvexPoly(histImage, pts, 5, Scalar(255, 255, 255));     }      imshow(\"Histogram\", histImage);      return histImage; }  int main(void) {     int histSize = 350;      float range[] = {0, 256};     const float* histRange = {range};      bool uniform = true, accumulate = false;          Mat img1 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_GRAYSCALE);     Mat img2 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_COLOR);      Mat b_hist;     // 히스토그램이 저장될 Mat 객체 생성     Mat histImg;    // draw_histogram 반환값을 저장하기 위한 Mat 객체 생성      calcHist(&amp;img1, 1, 0, Mat(), b_hist, 1, &amp;histSize, &amp;histRange, uniform, accumulate);      histImg = draw_Histogram(b_hist);          waitKey(0);      return 0; }  ","categories": ["OpenCV","Algorithms"],
        "tags": ["OpenCV","Algorithms","Programming","Coding"],
        "url": "http://localhost:4000/opencv/algorithms/Assign-OpenCV-1/",
        "teaser": null
      },{
        "title": "Linear Algebra: Matrices and Linear Equations - Multiplication of Matrices - Question #1",
        "excerpt":"Question   Reference - Question2   Because it is just rotation, the negative rotation is described by positive rotation.   Therefore, if \\(y^2 = x^2\\) is shown to be established, regardless of whether its root is positive or negative, is the proof completed?       Answer   Below is a reply from Jaemin Shin, PhD.   You need know the definition of \\(\\left\\|\\cdot\\right\\|\\), called the norm, first. There are several ways to define the norm but in general in \\(R^{2}\\) it is defines as follows (called 2-norm); for \\(X = \\mathbf{(x_{1}, x_{2})}^\\top \\in R^2\\)   \\[\\left\\|X\\right\\| = \\sqrt{\\left\\|x_{1}\\right\\|^2 + \\left\\|x_{2}\\right\\|^2}\\]  or it is equivalent to   \\[\\left\\|X\\right\\| = (\\mathbf{X}^{\\top}X)^{\\frac{1}{2}}\\]  Here \\(\\mathbf{X}^\\top\\) is the transpose of the vector. \\(\\) Note that   \\[\\mathbf{(AB)}^\\top = \\mathbf{B}^\\top\\mathbf{A}^\\top\\]  and   \\[\\mathbf{R(\\theta)}^\\top = R(\\theta)^{-1} = R(-\\theta)\\]  Thus,   \\[\\left\\|Y\\right\\|^{2} = \\left\\|RX\\right\\|^{2} = \\mathbf{(RX)}^{\\top}(RX)=(\\mathbf{X}^{\\top}\\mathbf{R}^{\\top})(RX)\\]  Using the associative law   \\[(\\mathbf{X}^{\\top}\\mathbf{R}^{\\top})(RX) = \\mathbf{X}^{\\top}(\\mathbf{R}^{\\top}R)X = \\mathbf{X}^{\\top}(R^{-1}R)X = \\mathbf{X}^{\\top}X = \\left\\|X\\right\\|^2\\]  Since the norm is non-negative, it follows that   \\[\\left\\|Y\\right\\| = \\left\\|X\\right\\|.\\]  ","categories": ["Linear Algebra"],
        "tags": ["Mathematics","Linear Algebra"],
        "url": "http://localhost:4000/linear%20algebra/Studying_Linear-4/",
        "teaser": null
      },{
        "title": "Statics: General Principles - General Procedure for Analysis - #1",
        "excerpt":"Question   Question 1   If a man weighs \\(155lb\\) on earth, specify (a) his mass in slugs, (b) his mass in kilograms, and (c) his weight in newtons. If the man is on the moon, where the acceleration due to gravity is \\(g_{m} = 5.30ft/s^{2}\\), determine (d) his weight in pounds, and (e) his mass in kilograms.   Question 2   Two particles have a mass of \\(8 kg\\) and \\(12 kg\\), respectively. If they are \\(800 mm\\) apart, determine the force of gravity acting between them. Compare this result with the weight of each particle.   Answer   Answer 1   (a)   \\[\\text{Use } m=\\frac{w}{g}\\]  \\[(g = 32.2ft/s^{2})\\]  \\[\\therefore m = \\frac{155lb}{32.2ft/s^{2}} = 4.81 slug\\]  (b)   \\[\\text{Use } 1 slug = 14.59 kg\\]  \\[\\therefore 4.81 slug \\times 14.59 kg = 70.3 kg\\]  (c)   \\[\\text{Use } 1 lb = 4.448 N\\]  \\[\\therefore 4.81 slug \\times 4.448 N = 689 N\\]  (d)   \\[\\text{Use } W = mg\\]  \\[(m = 4.81 slug, g_{m} = 5.30 ft/s^{2})\\]  \\[\\therefore 4.81 slug \\times 5.30 ft/s^{2} = 25.5 lb\\]  (e)   \\[\\text{(e) is the same as (b).}\\]  Answer 2   \\[\\text{Use } F = G\\frac{m_{1}m_{2}}{r^{2}}\\]  \\[F\\text{: force of gravitation between the two particles}\\]  \\[G\\text{: universal constant of gravitation; according to experimental evidence, } G=66.73(10^{-12})m^{3}/({kg} \\cdot {s^{2}})\\]  \\[m_{1}, m_{2}\\text{: mass of each of the two particles}\\]  \\[r\\text{: distance between the two particles}\\]      \\[F = 66.73(10^{-12})(m^{3}/({kg} \\cdot {s^{2}}))\\frac{8(kg)\\times12(kg)}{(800(10^{-3})(m))^{2}} = 10.0nN\\]  \\[W_{1}=8(kg)\\times9.81(m/s^{2}) = 78.5N\\]  \\[W_{2}=12(kg)\\times9.81(m/s^{2}) = 118N\\] ","categories": ["Statics"],
        "tags": ["General Procedure for Analysis"],
        "url": "http://localhost:4000/statics/Studying-Statics-1/",
        "teaser": null
      },{
        "title": "BOJ: 17254 키보드 이벤트",
        "excerpt":"문제   키보드에서 어떤 키를 누르면 어떤 키가 눌러졌는지 컴퓨터에 전송되고, 컴퓨터에서는 키가 눌러진 순서대로 화면에 출력된다.   승지는 팀 과제로 보고서 100장을 작성해야 하는 데, 마감 시간이 얼마 남지 않아서 팀원에게 도움을 요청하였다. 하지만 컴퓨터가 하나뿐이라 보고서를 동시에 작성할 수 없었다.   주변을 둘러보니 쓰지 않는 키보드가 여러 개가 바닥에서 굴러다니는 것을 보았다. 급한 대로 컴퓨터에 키보드 여러 개를 연결해서 타자 속도를 올리기로 했다.   문제는 원하는 문장을 작성하기 위해서는 서로 호흡을 잘 맞춰야 하는데, 키보드의 동작 원리를 아직 알지 못했던 승지는 어떤 결과가 출력될지 알 수 없었다.   승지는 팀원 N명에게 N개의 키보드를 나눠주고 전부 컴퓨터에 연결했다. 각자 어느 시간에 어떤 키를 누를지를 미리 정한다면, 어떤 결과가 화면에 출력될 것인지를 알아내고자 한다.   키보드의 번호는 컴퓨터에 연결된 순서대로 1번 키보드, 2번 키보드, … N번 키보드이다. 동시에 여러 키보드에서 키를 누른다면 번호가 작은 키보드에서 누른 키가 먼저 출력되지만, 하나의 키보드에서 여러 개의 키를 동시에 누를 수는 없다. 즉, 하나의 키보드에서 각 키를 누른 시간은 모두 다르다.   입력   첫째 줄에 연결된 키보드의 개수 N과, 키보드를 누르게 될 횟수 M이 주어진다. \\((1\\leq{a}\\leq{N}, 0\\leq{b}\\leq{1,000,000})\\)   다음 M개의 줄에 정수 a, b와 문자 c가 주어진다. 이는 a번 키보드로, b초에 문자 c가 적힌 키를 누를 것이라는 의미이다. \\((1\\leq{a}\\leq{N}, 0\\leq{b}\\leq{1,000,000})\\)   키보드에는 알파벳 대문자와 숫자키만 존재한다.   출력   모든 입력이 끝난 후에 화면에 출력될 결과를 출력한다.   예제 입력 1   3 5 1 0 A 2 1 P 1 2 L 2 4 E 3 0 P   예제 출력 1   APPLE   예제 입력 2   2 7 1 6 B 1 1 A 1 0 L 1 3 D 2 8 G 2 6 U 2 3 Y   예제 출력 2   LADYBUG       코드   #include &lt;iostream&gt;  #define MAX 1000  #define OPERATOR_MAX(max, var) (max &lt; var) ? max = var : 0  using namespace std;  void sorting(int * index, int * a, int m) {     int temp;      int arr[MAX] = {0,};      for(int i=0; i&lt;m; i++)         arr[i] = a[i];      for(int i=0; i&lt;m; i++) {         for(int j=i; j&lt;m; j++) {              if(arr[j] &lt; arr[i]) {                 temp = arr[i];                 arr[i] = arr[j];                 arr[j] = temp;                  temp = index[i];                 index[i] = index[j];                 index[j] = temp;             }         }     } }  int get_max(int * b, int m) {     int max = b[0];      for(int i=1; i&lt;m; i++)         OPERATOR_MAX(max, b[i]);      return max; }  void get_string(int * index, int * a, int * b, char * c, int m) {      int max = get_max(b, m);          for(int j=0; j&lt;=max; j++)         for(int k=0; k&lt;m; k++)             if(b[index[k]] == j)                 cout&lt;&lt;c[index[k]];                      }  int main(void) {     int n, m;     int a[MAX] = {0,};     int b[MAX] = {0,};     char c[MAX] = {0,};     int index[MAX] = {0,};      cin&gt;&gt;n&gt;&gt;m;      for(int i=0; i&lt;m; i++) {         cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];          if(a[i]&gt;n || a[i]&lt;1) {             i--;             continue;         }                      if((c[i] &lt; 48 || c[i] &gt; 57) &amp;&amp; (c[i] &lt; 65 || c[i] &gt; 90)) {             i--;             continue;         }          index[i] = i;     }      sorting(index, a, m);     get_string(index, a, b, c, m);      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-1/",
        "teaser": null
      },{
        "title": "BOJ: 12755 수면 장애",
        "excerpt":"문제   수면 장애를 가진 강민이는 잠이 오지 않아 적잖은 고통을 느끼고 있다. 강민이는 잠이 오지 않을 때마다 속으로 양을 세고 있었는데, 오늘따라 백만 마리까지 세었는데도 잠이 오지 않았다.   한계를 느낀 강민이는 새로운 방법으로 수를 세기로 했다.   1부터 숫자를 쭉 이어 붙이면 다음과 같은 숫자열이 생성된다.   12345678910111213…   강민이는 이 숫자열을 한 숫자씩 떼어서 읽기 시작했다. 수면에 성공한 강민이는 다음날 일어나자마자 “\\(N\\)번째 숫자까지 읽었어!” 라고 기분 좋게 외쳤다.   과연 \\(N\\)번째 숫자는 무엇일까?   입력   첫째 줄에 \\(N\\)번째 숫자를 나타내는 \\(N\\)이 주어진다. \\((1\\leq{N}\\leq{100,000,000})\\)   출력   첫째 줄에 \\(N\\)번째 숫자에 해당하는 0~9 중 한 숫자를 출력하시오.   예제 입력 1   15   예제 출력 1   2       코드   #include &lt;iostream&gt; #include &lt;stack&gt;  using namespace std;  int main(void) {     stack&lt;int&gt; s;     int n, k;     int mod;     int count = 0;     int pos = 1;     int chk;     int con = 0;      cin&gt;&gt;n;      for(int i=1; i&lt;=n; i++) {         k = i;         count = 0;          while(1) {             if(k == 0)                  break;                          mod = k % 10;             s.push(mod);             k /= 10;             count++;         }          while(count != 0) {             chk = s.top();             s.pop();                          if(pos == n) {                 con = 1;                 break;             }                              pos++;             count--;         }          if(con == 1)             break;      }      cout&lt;&lt;chk;      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-2/",
        "teaser": null
      },{
        "title": "OpenCV 과제: 영상 색상 채우기 #2",
        "excerpt":"질문   내용   다음 영상 이름은 “hwfig5-1.jpg”이다. 이 영상에 대해 다음을 프로그래밍하시오.              위 영상을 Mat img1 = imread() 함수를 이용하여 grayscale 영상으로 읽어 오시오.            또 다른 영상을 저장하기 위해 Mat img2;로 하고, 이것은 칼라(3채널)로 저장하기 위해 선언하시오.            위 영상에 대해 히스토그램을 구하시오.            히스토그램에서 최대 peak가 되는 값 4개를 구하시오. (육안으로…)            각 4개 peak점의 가운데 값을 문턱치로 사용하여 가장 어두운 직사각형은 파랑색, 원은 녹색, 삼각형은 빨강색, 배경은 노랑색으로 하여 img2를 만들어 display하시오.       답변   내용   그럼 1편에 이어서 위 문제를 풀이해보겠다.   이제 4번을 풀이할 차례이다.   먼저 1편에서 완성시킨 아래의 히스토그램을 다시 살펴보면, 히스토그램이 굉장히 매끄럽지 못한 것을 확인해볼 수 있다.      그래서 필자는 히스토그램을 그리기 전(draw_Histogram 함수를 호출하기 전)에 Gaussian Filter(Blur)를 적용하여 Smooth한 히스토그램을 만들어보려 한다.   먼저 1편에서 작성한 전체 코드를 가져오자.   #include &lt;opencv2/opencv.hpp&gt;  using namespace cv;  Mat draw_Histogram(Mat&amp; hist) {     int hist_w = 2048;     int hist_h = 500;     int hist_size = 350;     int bin_w = cvRound((double)hist_w/hist_size);      Mat histImage(hist_h, hist_w, CV_8UC3, Scalar(0, 0, 0));      normalize(hist, hist, 0, histImage.rows, NORM_MINMAX, -1, Mat());      for(int i=1; i&lt;hist_size; i++) {         Point pts[] = {Point(bin_w * (i-1), hist_h), Point(bin_w * i, hist_h), Point(bin_w * i, hist_h - cvRound(hist.at&lt;float&gt;(i))), Point(bin_w*(i-1), hist_h-cvRound(hist.at&lt;float&gt;(i-1))), Point(bin_w*(i-1), hist_h)};          fillConvexPoly(histImage, pts, 5, Scalar(255, 255, 255));     }      imshow(\"Histogram\", histImage);      return histImage; }  int main(void) {     int histSize = 350;      float range[] = {0, 256};     const float* histRange = {range};      bool uniform = true, accumulate = false;          Mat img1 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_GRAYSCALE);     Mat img2 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_COLOR);      Mat b_hist;     // 히스토그램이 저장될 Mat 객체 생성     Mat histImg;    // draw_histogram 반환값을 저장하기 위한 Mat 객체 생성      calcHist(&amp;img1, 1, 0, Mat(), b_hist, 1, &amp;histSize, &amp;histRange, uniform, accumulate);      histImg = draw_Histogram(b_hist);          waitKey(0);      return 0; }   필자가 위에서 언급했듯이 히스토그램을 그리기 전에 즉, draw_Histogram 함수를 호출하기 전에 b_hist에 대하여 Gaussian Filter를 적용해야 하는데, 이를 위해 공식적으로 제공하는 GaussianBlur 함수를 이용하자.   GaussianBlur 함수는 다음과 같다.   void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY=0, int borderType=BORDER_DEFAULT)   각 매개변수에 대한 설명은 아래의 사이트를 참고해보자.   Reference   필자는 9X9의 가우시안 필터를 적용했다.   아래의 코드를 통해 이를 확인해보자.   #include &lt;opencv2/opencv.hpp&gt;  using namespace cv;  Mat draw_Histogram(Mat&amp; hist) {     int hist_w = 2048;     int hist_h = 500;     int hist_size = 350;     int bin_w = cvRound((double)hist_w/hist_size);      Mat histImage(hist_h, hist_w, CV_8UC3, Scalar(0, 0, 0));      normalize(hist, hist, 0, histImage.rows, NORM_MINMAX, -1, Mat());      for(int i=1; i&lt;hist_size; i++) {         Point pts[] = {Point(bin_w * (i-1), hist_h), Point(bin_w * i, hist_h), Point(bin_w * i, hist_h - cvRound(hist.at&lt;float&gt;(i))), Point(bin_w*(i-1), hist_h-cvRound(hist.at&lt;float&gt;(i-1))), Point(bin_w*(i-1), hist_h)};          fillConvexPoly(histImage, pts, 5, Scalar(255, 255, 255));     }      imshow(\"Histogram\", histImage);      return histImage; }  int main(void) {     int histSize = 350;      float range[] = {0, 256};     const float* histRange = {range};      bool uniform = true, accumulate = false;          Mat img1 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_GRAYSCALE);     Mat img2 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_COLOR);      Mat b_hist;     // 히스토그램이 저장될 Mat 객체 생성     Mat histImg;    // draw_histogram 반환값을 저장하기 위한 Mat 객체 생성      calcHist(&amp;img1, 1, 0, Mat(), b_hist, 1, &amp;histSize, &amp;histRange, uniform, accumulate);      GaussianBlur(b_hist, b_hist, Size(9, 9), 0);        // 9x9 가우시안 필터 적용      histImg = draw_Histogram(b_hist);          waitKey(0);      return 0; }   그 결과는 다음과 같다.      전보다 매끄러운 히스토그램이 도출된 것을 확인해볼 수 있다.   이제 도출된 히스토그램 위의 Peaks들에 Line을 그려줘야 하는데, 이를 위해 먼저 Peaks 값을 찾는 함수를 작성하고, 찾은 값들에 대해서 실제로 Line을 그려주는 함수를 작성해보자.   필자는 Peaks 값을 찾는 함수의 이름을 find_Peaks로 지었으며, Mat Reference Type의 src라는 이름의 매개변수를 선언했다.   또한, 찾은 Peaks들의 값(int형)을 저장한 vector 자료형을 반환할 것이므로 반환형은 std::vector&lt;int&gt;로 했다.   즉, 이를 코드로 보이면 다음과 같다.   std::vector&lt;int&gt; find_Peaks(Mat&amp; src) {  }   이제 Peaks들의 값을 찾아야 하는데, 사실 극댓값을 찾는 알고리즘을 작성하여 이를 해결해도 되지만, 불연속점의 존재 가능성(실제로 불연속적이어도 극댓값은 존재한다.)과 같이 다양한 상황에 적용되는 일반적인 알고리즘을 개발하기가 상당히 까다롭기 때문에 필자는 위 이미지의 히스토그램에 적용되는 더 쉬운 방법을 이용해 이를 해결해봤다.   그것은 바로 OpenCV에서 공식적으로 제공하고 있는 minMaxLoc Function을 이용하는 것이다.   minMaxLoc Function은 다음과 같다.   void cv::minMaxLoc(InputArray src,                    double* minVal,                    double* maxVal = 0,                    Point* minLoc = 0,                    Point* maxLoc = 0,                    InputArray mask = noArray() )   위 Function에 대한 더 자세한 사항은 아래 링크를 참고해보자.   Reference   minMaxLoc Function은 히스토그램의 최댓값을 찾아주는 Function인데, 그러면 여기서 드는 생각이      최댓값만 찾을 수 있다면, 다른 히스토그램의 최댓값은 찾을 수 없는 것 아닌가요?    이다.   그래서 필자는 다음의 Trick을 이용했다.   먼저 원본 히스토그램 이미지의 유지를 위해(위에 Line을 그려야 하므로) 히스토그램 이미지의 복제본을 하나 생성한다.   복제된 이미지에 대해서 minMaxLoc Function을 호출한다.   그러면 당연히 4개의 히스토그램 중 가장 높은 Peak 값을 가지는 히스토그램(위의 이미지에서는 가장 오른쪽 히스토그램)의 Peak값이 도출될 것이다.   그 값을 별도로 저장한 후, 0(최솟값)으로 변경해버리고 히스토그램의 주변 반경에 있는 값들 역시 모두 0(최솟값)으로 변경해버리자.   만약 주변 반경에 있는 값들을 처리하지 않았을 경우에 다시 한번 minMaxLoc Function을 호출하게 되면, 두 번째로 높은 Peak 값을 가지는, 왼쪽에서 두 번째에 위치한 히스토그램의 Peak 값이 도출되는 것이 아니라 가장 오른쪽 히스토그램의 두 번째 최댓값이 도출되게 된다.   이러한 아이디어를 바탕으로 필자는 다음의 코드를 작성할 수 있었다.   (편의를 위해 std 이름 공간을 사용했다고 가정했다.)   vector&lt;int&gt; find_Peaks(Mat&amp; src) {     vector&lt;int&gt; peaks;      // peaks들의 값을 저장할 변수     Mat dup_src;            // 매개변수 src를 복제하여 저장할 변수          Point p;        // 히스토그램의 최대 Peak 값을 저장하는 변수          dup_src = src.clone();      // 매개변수 src를 복제하여 dup_src에 담는다.          for(int i=0; i&lt;4; i++) {    // 위 이미지에서 보여지는 히스토그램이 4개 있으므로, 4회 반복.         minMaxLoc(dup_src, 0, 0, 0, &amp;p);       // 우리는 히스토그램의 Peak 값만 필요하므로 최댓값과 최솟값을 저장할 변수는 필요치 않음.         peaks.push_back(p.y);       // 위치 값 중 y값만을 peaks에 담자.         dup_src.at&lt;float&gt;(p.y) = 0;        // 최솟값인 0을 넣자.          for(int j=0; j&lt;10; j++) {           // p.y의 주변 반경 10만큼을 최솟값 0으로 채운다.             dup_src.at&lt;float&gt;(p.y-(j+1)) = 0;                dup_src.at&lt;float&gt;(p.y+(j+1)) = 0;         }     }          return peaks;       // peaks 값들 반환 }   글이 길어질 듯하여 각 코드에 대한 설명을 주석에 달아놓았으니 이를 참고해보자.   (제 코드에 궁금한 점이 있으신 분들께서는 댓글 남겨주세요.)   p.y의 주변 반경 10만큼을 0으로 채우면, 히스토그램이 다음의 과정을 거치는 것을 이미지를 통해 확인해볼 수 있다.            여기까지 완료했다면, 이제 실제로 도출된 Peak의 위치 값을 기반으로 Line을 그려야한다.   필자는 Line을 그려주는 함수의 이름을 draw_Line으로 지었으며, Mat Reference Type의 src와 hist라는 이름의 매개변수를 두 개 선언했다.   또한, peaks 값들로부터 마지막 문항을 해결해야하므로 반환형은 std::vector&lt;int&gt;로 선언했다.   즉,   std::vector&lt;int&gt; draw_Line(Mat&amp; src, Mat&amp; hist) {  }   Line을 그리는 방법은 OpenCV에서 line Function을 제공하고 있으니, 이를 활용하자.   line Function은 다음과 같다.   void cv::line(InputOutputArray img,               Point pt1,               Point pt2,               const Scalar&amp; color,               int thickness = 1,               int lineType = LINE_8,               int shift = 0 )   위 함수에 대한 더 자세한 사항은 아래 Reference를 참조하자.   Reference   먼저 draw_Line Function 내에서 std::vector&lt;int&gt;형의 변수를 하나 선언하고, find_Peaks Function을 호출하여 그 반환값을 선언한 변수에 저장하자.   find_Peaks Function을 호출할 때 인자로서 src 매개변수의 값을 보내자.   std::vector&lt;int&gt; draw_Line(Mat&amp; src, Mat&amp; hist) {     std::vector&lt;int&gt; peaks = find_Peaks(src); }   받은 peaks 정보에 대해서 line Function을 이용해 히스토그램 위에 빨간색(Scalar(0, 0, 255)) Line을 그린 후, imshow 함수를 이용해 각 히스토그램의 Peaks들에 Line이 그려진 이미지가 화면에 나오도록 한다.   (편의를 위해 std 이름 공간을 사용했다고 가정했다.)   vector&lt;int&gt; draw_Line(Mat&amp; src, Mat&amp; hist) {     vector&lt;int&gt; peaks = find_Peaks(src);     int bin_w = cvRound( (double) hist.cols / 350);      for(size_t i = 0; i &lt; peaks.size(); i++)         line(hist, Point(bin_w * peaks[i], hist.rows), Point(bin_w * peaks[i], 0), Scalar(0, 0, 255));      imshow(\"Peaks\", hist);     return peaks; }   이제 실제 확인을 위해서 main 함수로 돌아가 위에서 작성한 draw_Line Function을 호출하자.   int main(void) {     int histSize = 350;      float range[] = {0, 256};     const float* histRange = {range};      bool uniform = true, accumulate = false;          Mat img1 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_GRAYSCALE);     Mat img2 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_COLOR);      Mat b_hist;     // 히스토그램이 저장될 Mat 객체 생성     Mat histImg;    // draw_histogram 반환값을 저장하기 위한 Mat 객체 생성      calcHist(&amp;img1, 1, 0, Mat(), b_hist, 1, &amp;histSize, &amp;histRange, uniform, accumulate);      GaussianBlur(b_hist, b_hist, Size(9, 9), 0);        // 9x9 가우시안 필터 적용      histImg = draw_Histogram(b_hist);          draw_Line(b_hist, histImg);         // draw_Line Function 호출          waitKey(0);      return 0; }   이제 프로그램을 실행해보면 다음과 같이 각 히스토그램의 Peaks들에 빨간색 Line이 그려지는 것을 확인해볼 수 있다.      전체 코드를 보이면서 이번 포스팅은 일단 여기서 끝맺고, 다음 포스팅에 이어서 마지막 문항을 풀이하도록 하겠다.   전체 코드   #include &lt;opencv2/opencv.hpp&gt;  using namespace cv; using namespace std;  vector&lt;int&gt; find_Peaks(Mat&amp; src) {     vector&lt;int&gt; peaks;      // peaks들의 값을 저장할 변수     Mat dup_src;            // 매개변수 src를 복제하여 저장할 변수          Point p;        // 최댓값의 위치를 저장하는 변수          dup_src = src.clone();      // 매개변수 src를 복제하여 dup_src에 담는다.          for(int i=0; i&lt;4; i++) {    // 위 이미지에서 보여지는 히스토그램이 4개 있으므로, 4회 반복.         minMaxLoc(dup_src, 0, 0, 0, &amp;p);       // 우리는 히스토그램의 Peak 값만 필요하므로 최댓값과 최솟값을 저장할 변수는 필요치 않음.         peaks.push_back(p.y);       // 위치 값 중 y값만을 peaks에 담자.         dup_src.at&lt;float&gt;(p.y) = 0;        // 최솟값인 0을 넣자.          for(int j=0; j&lt;10; j++) {           // p.y의 주변 반경 10만큼을 최솟값 0으로 채운다.             dup_src.at&lt;float&gt;(p.y-(j+1)) = 0;                dup_src.at&lt;float&gt;(p.y+(j+1)) = 0;         }     }          return peaks;       // peaks 값들 반환 }  vector&lt;int&gt; draw_Line(Mat&amp; src, Mat&amp; hist) {     vector&lt;int&gt; peaks = find_Peaks(src);     int bin_w = cvRound( (double) hist.cols / 350);      for(size_t i = 0; i &lt; peaks.size(); i++)         line(hist, Point(bin_w * peaks[i], hist.rows), Point(bin_w * peaks[i], 0), Scalar(0, 0, 255));      imshow(\"Peaks\", hist);     return peaks; }  Mat draw_Histogram(Mat&amp; hist) {     int hist_w = 2048;     int hist_h = 500;     int hist_size = 350;     int bin_w = cvRound((double)hist_w/hist_size);      Mat histImage(hist_h, hist_w, CV_8UC3, Scalar(0, 0, 0));      normalize(hist, hist, 0, histImage.rows, NORM_MINMAX, -1, Mat());      for(int i=1; i&lt;hist_size; i++) {         Point pts[] = {Point(bin_w * (i-1), hist_h), Point(bin_w * i, hist_h), Point(bin_w * i, hist_h - cvRound(hist.at&lt;float&gt;(i))), Point(bin_w*(i-1), hist_h-cvRound(hist.at&lt;float&gt;(i-1))), Point(bin_w*(i-1), hist_h)};          fillConvexPoly(histImage, pts, 5, Scalar(255, 255, 255));     }      imshow(\"Histogram\", histImage);      return histImage; }  int main(void) {     int histSize = 350;      float range[] = {0, 256};     const float* histRange = {range};      bool uniform = true, accumulate = false;          Mat img1 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_GRAYSCALE);     Mat img2 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_COLOR);      Mat b_hist;     // 히스토그램이 저장될 Mat 객체 생성     Mat histImg;    // draw_histogram 반환값을 저장하기 위한 Mat 객체 생성      calcHist(&amp;img1, 1, 0, Mat(), b_hist, 1, &amp;histSize, &amp;histRange, uniform, accumulate);      GaussianBlur(b_hist, b_hist, Size(9, 9), 0);        // 9x9 가우시안 필터 적용      histImg = draw_Histogram(b_hist);          draw_Line(b_hist, histImg);          waitKey(0);      return 0; }  ","categories": ["OpenCV","Algorithms"],
        "tags": ["OpenCV","Algorithms","Programming","Coding"],
        "url": "http://localhost:4000/opencv/algorithms/Assign-OpenCV-2/",
        "teaser": null
      },{
        "title": "OpenCV 과제: 영상 색상 채우기 #3 - 최종",
        "excerpt":"질문   내용   다음 영상 이름은 “hwfig5-1.jpg”이다. 이 영상에 대해 다음을 프로그래밍하시오.              위 영상을 Mat img1 = imread() 함수를 이용하여 grayscale 영상으로 읽어 오시오.            또 다른 영상을 저장하기 위해 Mat img2;로 하고, 이것은 칼라(3채널)로 저장하기 위해 선언하시오.            위 영상에 대해 히스토그램을 구하시오.            히스토그램에서 최대 peak가 되는 값 4개를 구하시오. (육안으로…)            각 4개 peak점의 가운데 값을 문턱치로 사용하여 가장 어두운 직사각형은 파랑색, 원은 녹색, 삼각형은 빨강색, 배경은 노랑색으로 하여 img2를 만들어 display하시오.       답변   내용   그럼 2편에 이어서 위 문제를 풀이해보겠다.   이제 5번을 풀이할 차례이다.   2편에서 작성한 전체 코드를 가져오자.   #include &lt;opencv2/opencv.hpp&gt;  using namespace cv; using namespace std;  vector&lt;int&gt; find_Peaks(Mat&amp; src) {     vector&lt;int&gt; peaks;      // peaks들의 값을 저장할 변수     Mat dup_src;            // 매개변수 src를 복제하여 저장할 변수          Point p;        // 최댓값의 위치를 저장하는 변수          dup_src = src.clone();      // 매개변수 src를 복제하여 dup_src에 담는다.          for(int i=0; i&lt;4; i++) {    // 위 이미지에서 보여지는 히스토그램이 4개 있으므로, 4회 반복.         minMaxLoc(dup_src, 0, 0, 0, &amp;p);       // 우리는 히스토그램의 Peak 값만 필요하므로 최댓값과 최솟값을 저장할 변수는 필요치 않음.         peaks.push_back(p.y);       // 위치 값 중 y값만을 peaks에 담자.         dup_src.at&lt;float&gt;(p.y) = 0;        // 최솟값인 0을 넣자.          for(int j=0; j&lt;10; j++) {           // p.y의 주변 반경 10만큼을 최솟값 0으로 채운다.             dup_src.at&lt;float&gt;(p.y-(j+1)) = 0;                dup_src.at&lt;float&gt;(p.y+(j+1)) = 0;         }     }          return peaks;       // peaks 값들 반환 }  vector&lt;int&gt; draw_Line(Mat&amp; src, Mat&amp; hist) {     vector&lt;int&gt; peaks = find_Peaks(src);     int bin_w = cvRound( (double) hist.cols / 350);      for(size_t i = 0; i &lt; peaks.size(); i++)         line(hist, Point(bin_w * peaks[i], hist.rows), Point(bin_w * peaks[i], 0), Scalar(0, 0, 255));      imshow(\"Peaks\", hist);     return peaks; }  Mat draw_Histogram(Mat&amp; hist) {     int hist_w = 2048;     int hist_h = 500;     int hist_size = 350;     int bin_w = cvRound((double)hist_w/hist_size);      Mat histImage(hist_h, hist_w, CV_8UC3, Scalar(0, 0, 0));      normalize(hist, hist, 0, histImage.rows, NORM_MINMAX, -1, Mat());      for(int i=1; i&lt;hist_size; i++) {         Point pts[] = {Point(bin_w * (i-1), hist_h), Point(bin_w * i, hist_h), Point(bin_w * i, hist_h - cvRound(hist.at&lt;float&gt;(i))), Point(bin_w*(i-1), hist_h-cvRound(hist.at&lt;float&gt;(i-1))), Point(bin_w*(i-1), hist_h)};          fillConvexPoly(histImage, pts, 5, Scalar(255, 255, 255));     }      imshow(\"Histogram\", histImage);      return histImage; }  int main(void) {     int histSize = 350;      float range[] = {0, 256};     const float* histRange = {range};      bool uniform = true, accumulate = false;          Mat img1 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_GRAYSCALE);     Mat img2 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_COLOR);      Mat b_hist;     // 히스토그램이 저장될 Mat 객체 생성     Mat histImg;    // draw_histogram 반환값을 저장하기 위한 Mat 객체 생성      calcHist(&amp;img1, 1, 0, Mat(), b_hist, 1, &amp;histSize, &amp;histRange, uniform, accumulate);      GaussianBlur(b_hist, b_hist, Size(9, 9), 0);        // 9x9 가우시안 필터 적용      histImg = draw_Histogram(b_hist);          draw_Line(b_hist, histImg);          waitKey(0);      return 0; }   draw_Line Function은 우리가 2편에서 작성했었던 것처럼 std::vector&lt;int&gt;형의 peaks 변수를 반환했기 때문에 main 함수에서 이를 받아야 median 값을 도출할 수 있다.   그러므로 std::vector&lt;int&gt;형의 peaks를 main 함수 내에 하나 선언한 후, peaks를 받자.   즉,   int main(void) {     int histSize = 350;      float range[] = {0, 256};     const float* histRange = {range};      bool uniform = true, accumulate = false;      vector&lt;int&gt; peaks;          // draw_Line Function 반환 값을 저장할 변수 선언          Mat img1 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_GRAYSCALE);     Mat img2 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_COLOR);      Mat b_hist;     // 히스토그램이 저장될 Mat 객체 생성     Mat histImg;    // draw_histogram 반환값을 저장하기 위한 Mat 객체 생성      calcHist(&amp;img1, 1, 0, Mat(), b_hist, 1, &amp;histSize, &amp;histRange, uniform, accumulate);      GaussianBlur(b_hist, b_hist, Size(9, 9), 0);        // 9x9 가우시안 필터 적용      histImg = draw_Histogram(b_hist);          peaks = draw_Line(b_hist, histImg);         // 반환 값을 담자.          waitKey(0);      return 0; }   peaks 내에는 히스토그램의 각 Peaks들의 값이 저장되어 있으므로, 문제의 5번 항목에서 요구하는 것처럼 4개의 Peaks들의 가운데 값, 즉 median 값을 산출하여 이를 문턱치로 사용하자.   우리는 이미 find_Peaks 함수에서 peaks vector에 값을 넣을 때, 가장 큰 히스토그램의 Peaks 값들부터 순차적으로 넣어줬기 때문에(minMaxLoc Function 덕분이다.) 실제로 peaks vector 내부의 값들은 정렬이 완료된 상태이다.   또한, 총 4개의 Peaks들이 들어가 있으므로, 즉 이는 홀수가 아닌 짝수이므로 가운데를 중심으로 바로 왼쪽에 위치한 원소의 값과 바로 오른쪽에 위치한 원소의 값을 더한 후 2로 나누어줘야 중앙값(median)이 도출된다.   이를 코드로 보이면 다음과 같다.   int main(void) {     int histSize = 350;      float range[] = {0, 256};     const float* histRange = {range};      bool uniform = true, accumulate = false;      vector&lt;int&gt; peaks;          // draw_Line Function 반환 값을 저장할 변수 선언     double median;              // 중앙값을 저장할 변수 선언          Mat img1 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_GRAYSCALE);     Mat img2 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_COLOR);      Mat b_hist;     // 히스토그램이 저장될 Mat 객체 생성     Mat histImg;    // draw_histogram 반환값을 저장하기 위한 Mat 객체 생성      calcHist(&amp;img1, 1, 0, Mat(), b_hist, 1, &amp;histSize, &amp;histRange, uniform, accumulate);      GaussianBlur(b_hist, b_hist, Size(9, 9), 0);        // 9x9 가우시안 필터 적용      histImg = draw_Histogram(b_hist);          peaks = draw_Line(b_hist, histImg);         // 반환 값을 담자.      median = (peaks.at((peaks.size()/2)-1) + peaks.at((peaks.size()/2)+1))/2;          waitKey(0);      return 0; }   위 코드 중 다음의 코드를 보자.   median = (peaks.at((peaks.size()/2)-1) + peaks.at((peaks.size()/2)+1))/2;   median 값을 도출할 때 필자가 위에서 언급했듯이, peaks 내부에는 총 4개의 Element들이 들어있기 때문에, peaks.size() 즉 peaks의 크기 4를 2로 나눈 후 -1을 하게 되면, 가운데를 중심으로 바로 왼쪽에 위치한 원소의 인덱스 값이 도출된다.   마찬가지 방식으로 가운데를 중심으로 바로 오른쪽에 위치한 원소의 인덱스 값도 peaks.size() 즉 peaks의 크기 4를 2로 나눈 후 +1을 하게 되면 도출된다.   각 인덱스 값에 대응되는 원소의 값들을 불러들여서 서로 더한 후 2로 나누어주면 median 값은 도출된다.   여기까지 완료했다면, 이제 문턱치를 구해보자.   문턱치 값을 구하기 위해서 OpenCV에서는 threshold Function을 제공해주므로, 이를 이용하면 되겠다.   threshold Function은 다음과 같다.   double cv::threshold(InputArray src,                      OutputArray dst,                      double thresh,                      double maxval,                      int type )   위 함수에 대한 더 자세한 설명은 아래의 Reference를 참조하자.   Reference   필자는 흑 또는 백으로만 결과 이미지가 나오게끔 하고 싶기 때문에 type 인자로서 cv::ThresholdTypes인 Threshold Binary를 보내주었다.   또한, 백이 나오려면 maxval의 값은 255가 되어야 하므로, 255를 인자로 보내주었다.   즉 이를 코드로 보이면,   int main(void) {     int histSize = 350;      float range[] = {0, 256};     const float* histRange = {range};      bool uniform = true, accumulate = false;      vector&lt;int&gt; peaks;          // draw_Line Function 반환 값을 저장할 변수 선언     double median;              // 중앙값을 저장할 변수 선언          Mat img1 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_GRAYSCALE);     Mat img2 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_COLOR);      Mat b_hist;     // 히스토그램이 저장될 Mat 객체 생성     Mat histImg;    // draw_histogram 반환값을 저장하기 위한 Mat 객체 생성     Mat dst;        // threshold 처리 후 결과 이미지를 저장하기 위한 Mat 객체 생성      calcHist(&amp;img1, 1, 0, Mat(), b_hist, 1, &amp;histSize, &amp;histRange, uniform, accumulate);      GaussianBlur(b_hist, b_hist, Size(9, 9), 0);        // 9x9 가우시안 필터 적용      histImg = draw_Histogram(b_hist);          peaks = draw_Line(b_hist, histImg);         // 반환 값을 담자.      median = (peaks.at(peaks.size()/2-1) + peaks.at(peaks.size()/2))/2;      threshold(img1, dst, median, 255, THRESH_BINARY);       // threshold Function 호출          waitKey(0);      return 0; }   이렇게 한 후 threshold Function 처리 후의 결과 이미지를 확인해보자.   우리가 위에서 dst Mat 객체를 결과 이미지로 설정했기 때문에 imshow 함수를 이용해서 단순히 dst 이미지를 띄워주기만 하면 된다.   int main(void) {     int histSize = 350;      float range[] = {0, 256};     const float* histRange = {range};      bool uniform = true, accumulate = false;      vector&lt;int&gt; peaks;          // draw_Line Function 반환 값을 저장할 변수 선언     double median;              // 중앙값을 저장할 변수 선언          Mat img1 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_GRAYSCALE);     Mat img2 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_COLOR);      Mat b_hist;     // 히스토그램이 저장될 Mat 객체 생성     Mat histImg;    // draw_histogram 반환값을 저장하기 위한 Mat 객체 생성     Mat dst;        // threshold 처리 후 결과 이미지를 저장하기 위한 Mat 객체 생성      calcHist(&amp;img1, 1, 0, Mat(), b_hist, 1, &amp;histSize, &amp;histRange, uniform, accumulate);      GaussianBlur(b_hist, b_hist, Size(9, 9), 0);        // 9x9 가우시안 필터 적용      histImg = draw_Histogram(b_hist);          peaks = draw_Line(b_hist, histImg);         // 반환 값을 담자.      median = (peaks.at(peaks.size()/2-1) + peaks.at(peaks.size()/2))/2;      threshold(img1, dst, median, 255, THRESH_BINARY);      imshow(\"Result\", dst);          waitKey(0);      return 0; }   위 코드의 실행 결과가 아래와 같다면 성공이다.      이제 정말 마지막이다.      가장 어두운 직사각형은 파랑색, 원은 녹색, 삼각형은 빨강색, 배경은 노랑색으로 하여 img2를 만들어 display하시오.    필자는 위의 threshold Function 처리 결과 도출된 이미지에서 다음과 같은 하나의 패턴을 발견할 수 있었다.      흰색, 검은색, 흰색, 검은색, 흰색, 검은색, 흰색의 순서이다.    그래서 필자는 dst 이미지에 대해서 왼쪽에서부터 오른쪽으로 순차적으로 Elements들에 접근하여 만약에 지금 현재 Element의 값이 0이면, 즉 검은색이면 count의 값이 0일 때는 파랑색을, 1일 때는 초록색을, 2일 때는 빨간색을 칠하게끔 작성하였으며, 또 그 다음 Element의 값이 255이면, 즉 흰색이면 count가 2인지 검사하여 만약 그렇다면 다시 0으로, 그렇지 않다면 +1 시키는 방식으로 진행했다.   또한, 지금 현재 Element의 값이 255이면, 즉 흰색이면 노랑색을 칠하게끔 작성했다.   그런데 만약 위에서 필자가 생각해낸 방식에서 count의 값이 2일 때 다시 0으로 만들어주는 조건식이 존재하지 않는다면 어떤 문제가 발생할까?   아래는 이러한 조건식이 존재하지 않는 상황에서의 코드의 동작을 나타낸 것이다.      직사각형에서 흰색 배경을 만났을 때 기존 0에서 1로 count의 값이 증가하고, 마찬가지로 원에서 흰색 배경을 만났을 경우에도 기존 count 값인 1에서 2로 증가를 하게 되며, 마지막으로 삼각형에서 흰색 배경을 만났을 때는 count 값이 기존 2에서 3으로 증가한다.       문제점을 찾았는가?    필자는 count의 값이 0일 때와 1일 때 그리고 2일 때에 대해서만 그에 맞는 색깔을 칠해주는 조건을 걸었기 때문에 3에 대응되는 조건은 없어서 색깔이 칠해지지 않는 문제가 발생한다.   (더군다나 count의 값은 계속 증가하게 된다.)   그리하여 필자는 count의 값이 2일 때 다시 0으로 만들어주는 조건을 걸어두었다.   이를 코드로 보이면 다음과 같다.   int count = 0;                      // count의 값은 0으로 초기화한다.  uchar *data_input = dst.data;       // dst 이미지의 Element에 접근하기 위한 data_input 포인터 변수, 실제 조건의 대상은 dst 이미지이다.  for (int y = 0; y &lt; img2.rows; y++) {     for (int x = 0; x &lt; img2.cols-1; x++) {         uchar *data_output = img2.data;     // img2 이미지 위에 색깔을 그리기 위해 Element에 접근하는 data_output 포인터 변수          if(data_input[y*img2.cols+x] == 0) {        // 현재 Element의 값이 0이면, 즉 검은색이면             if(count == 0){                         // 그때의 count 값이 0이면, 파랑색             data_output[y * img2.cols*3 + x*3] = 255;           // B             data_output[y * img2.cols*3 + x*3 + 1] = 144;       // G             data_output[y * img2.cols*3 + x*3 + 2] = 30;        // R             } else if(count == 1) {                 // 그때의 count 값이 1이면, 초록색                 data_output[y * img2.cols*3 + x*3] = 0;         // B                 data_output[y * img2.cols*3 + x*3 + 1] = 128;   // G                 data_output[y * img2.cols*3 + x*3 + 2] = 0;     // R             }else if(count == 2) {                  // 그때의 count 값이 2이면, 빨강색                 data_output[y * img2.cols*3 + x*3] = 0;         // B                 data_output[y * img2.cols*3 + x*3 + 1] = 0;     // G                 data_output[y * img2.cols*3 + x*3 + 2] = 255;   // R             }              if(data_input[y*img2.cols+x+1] == 255) {            // 다음 Element의 값이 255이면, 즉 흰색이면                 if(count == 2)          // 그때의 count 값이 2라면                     count = 0;          // 0으로 변경                 else                    // 2가 아니라면                     count++;            // count 값을 1만큼 증가             }         }else if(data_input[y*img2.cols+x] == 255) {            // 현재 Element의 값이 255이면, 즉 흰색이면 노랑색             data_output[y * img2.cols*3 + x*3] = 0;             // B             data_output[y * img2.cols*3 + x*3 + 1] = 255;       // G             data_output[y * img2.cols*3 + x*3 + 2] = 255;       // R         }     } }   위 코드로부터 알 수 있는 사실은      OpenCV에서 Color Image Matrix는 우리가 기존에 알고 있던 R, G, B 순서가 아닌 B, G, R 순서이다.    라는 점과 img2의 경우에는 dst와는 달리 3 channel Matrix라서(img2를 불러들일 때 IMREAD_COLOR로 불러들인 것을 기억하고 있는가?) +0, +1, +2로 각각 B, G, R에 접근할 수 있다는 점이다.   이제 필자가 생각하여 작성한 코드가 문제의 5번 항목에서 요구한 바를 충족시켜주는지를 확인해보자.   img2에 대해서 색깔을 칠해주었으므로 imshow 함수의 인자로 img2를 보내주자.   int main(void) {     int histSize = 350;      float range[] = {0, 256};     const float* histRange = {range};      bool uniform = true, accumulate = false;      vector&lt;int&gt; peaks;          // draw_Line Function 반환 값을 저장할 변수 선언     vector&lt;int&gt;::iterator iter;          double median;              // 중앙값을 저장할 변수 선언          Mat img1 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_GRAYSCALE);     Mat img2 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_COLOR);          Mat b_hist;     // 히스토그램이 저장될 Mat 객체 생성     Mat histImg;    // draw_histogram 반환값을 저장하기 위한 Mat 객체 생성     Mat dst;        // threshold 처리 후 결과 이미지를 저장하기 위한 Mat 객체 생성      calcHist(&amp;img1, 1, 0, Mat(), b_hist, 1, &amp;histSize, &amp;histRange, uniform, accumulate);      GaussianBlur(b_hist, b_hist, Size(9, 9), 0);        // 9x9 가우시안 필터 적용      histImg = draw_Histogram(b_hist);          peaks = draw_Line(b_hist, histImg);         // 반환 값을 담자.          for(iter = peaks.begin(); iter != peaks.end(); iter++)         cout&lt;&lt;*iter&lt;&lt;endl;      median = (peaks.at((peaks.size()/2)-1) + peaks.at((peaks.size()/2)+1))/2;      threshold(img1, dst, median, 255, THRESH_BINARY);          uchar *data_input = dst.data;      int count = 0;      for (int y = 0; y &lt; img2.rows; y++) {         for (int x = 0; x &lt; img2.cols-1; x++) {             uchar *data_output = img2.data;     // img2 이미지 위에 색깔을 그리기 위해 Element에 접근하는 data_output 포인터 변수              if(data_input[y*img2.cols+x] == 0) {        // 현재 Element의 값이 0이면, 즉 검은색이면                 if(count == 0){                         // 그때의 count 값이 0이면, 파랑색                 data_output[y * img2.cols*3 + x*3] = 255;           // B                 data_output[y * img2.cols*3 + x*3 + 1] = 144;       // G                 data_output[y * img2.cols*3 + x*3 + 2] = 30;        // R                 } else if(count == 1) {                 // 그때의 count 값이 1이면, 초록색                     data_output[y * img2.cols*3 + x*3] = 0;         // B                     data_output[y * img2.cols*3 + x*3 + 1] = 128;   // G                     data_output[y * img2.cols*3 + x*3 + 2] = 0;     // R                 }else if(count == 2) {                  // 그때의 count 값이 2이면, 빨강색                     data_output[y * img2.cols*3 + x*3] = 0;         // B                     data_output[y * img2.cols*3 + x*3 + 1] = 0;     // G                     data_output[y * img2.cols*3 + x*3 + 2] = 255;   // R                 }                  if(data_input[y*img2.cols+x+1] == 255) {            // 다음 Element의 값이 255이면, 즉 흰색이면                     if(count == 2)          // 그때의 count 값이 2라면                         count = 0;          // 0으로 변경                     else                    // 2가 아니라면                         count++;            // count 값을 1만큼 증가                 }             }else if(data_input[y*img2.cols+x] == 255) {            // 현재 Element의 값이 255이면, 즉 흰색이면 노랑색                 data_output[y * img2.cols*3 + x*3] = 0;             // B                 data_output[y * img2.cols*3 + x*3 + 1] = 255;       // G                 data_output[y * img2.cols*3 + x*3 + 2] = 255;       // R             }         }        }      imshow(\"Result\", img2);          waitKey(0);      return 0; }   다음과 같은 이미지가 출력되었다면, 성공이다.      전체 코드를 보이면서 OpenCV 색상 채우기 과제를 마무리 짓겠다.   전체 코드   #include &lt;opencv2/opencv.hpp&gt;  using namespace cv; using namespace std;  vector&lt;int&gt; find_Peaks(Mat&amp; src) {     vector&lt;int&gt; peaks;      // peaks들의 값을 저장할 변수         Mat dup_src;            // 매개변수 src를 복제하여 저장할 변수                  Point p;        // 최댓값의 위치를 저장하는 변수                  dup_src = src.clone();      // 매개변수 src를 복제하여 dup_src에 담는다.                  for(int i=0; i&lt;4; i++) {    // 위 이미지에서 보여지는 히스토그램이 4개 있으므로, 4회 반복.             minMaxLoc(dup_src, 0, 0, 0, &amp;p);       // 우리는 위치값만 필요하므로 최대와 최솟값을 저장할 변수는 필요치 않음.             peaks.push_back(p.y);       // 위치 값 중 y값만을 peaks에 담자. 실제로 가장 큰 Peak를 가지는 히스토그램의 y값이 먼저 담기므로, 실제로 히스토그램 위에 Line을 그릴 때는 가장 작은 Peak를 가지는 히스토그램부터 그려진다. (Stack)             dup_src.at&lt;float&gt;(p.y) = 0;        // 필자는 단순히 최솟값으로서 0을 채택했다.              for(int j=0; j&lt;10; j++) {           // p.y의 주변 반경 10만큼을 0으로 채운다.                 dup_src.at&lt;float&gt;(p.y-(j+1)) = 0;                 dup_src.at&lt;float&gt;(p.y+(j+1)) = 0;             }         }                  return peaks;       // peaks 값들 반환 }  vector&lt;int&gt; draw_Line(Mat&amp; src, Mat&amp; hist) {     vector&lt;int&gt; peaks = find_Peaks(src);     int bin_w = cvRound( (double) hist.cols / 350);      for(size_t i = 0; i &lt; peaks.size(); i++)         line(hist, Point(bin_w * peaks[i], hist.rows), Point(bin_w * peaks[i], 0), Scalar(0, 0, 255));      imshow(\"Peaks\", hist);     return peaks; }  Mat draw_Histogram(Mat&amp; hist) {     int hist_w = 2048;     int hist_h = 500;     int hist_size = 350;     int bin_w = cvRound((double)hist_w/hist_size);      Mat histImage(hist_h, hist_w, CV_8UC3, Scalar(0, 0, 0));      normalize(hist, hist, 0, histImage.rows, NORM_MINMAX, -1, Mat());      for(int i=1; i&lt;hist_size; i++) {         Point pts[] = {Point(bin_w * (i-1), hist_h), Point(bin_w * i, hist_h), Point(bin_w * i, hist_h - cvRound(hist.at&lt;float&gt;(i))), Point(bin_w*(i-1), hist_h-cvRound(hist.at&lt;float&gt;(i-1))), Point(bin_w*(i-1), hist_h)};          fillConvexPoly(histImage, pts, 5, Scalar(255, 255, 255));     }      imshow(\"Histogram\", histImage);      return histImage; }  int main(void) {     int histSize = 350;      float range[] = {0, 256};     const float* histRange = {range};      bool uniform = true, accumulate = false;      vector&lt;int&gt; peaks;          // draw_Line Function 반환 값을 저장할 변수 선언     vector&lt;int&gt;::iterator iter;          double median;              // 중앙값을 저장할 변수 선언          Mat img1 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_GRAYSCALE);     Mat img2 = imread(\"/Users/hexk/Desktop/test1.jpg\", IMREAD_COLOR);          Mat b_hist;     // 히스토그램이 저장될 Mat 객체 생성     Mat histImg;    // draw_histogram 반환값을 저장하기 위한 Mat 객체 생성     Mat dst;        // threshold 처리 후 결과 이미지를 저장하기 위한 Mat 객체 생성      calcHist(&amp;img1, 1, 0, Mat(), b_hist, 1, &amp;histSize, &amp;histRange, uniform, accumulate);      GaussianBlur(b_hist, b_hist, Size(9, 9), 0);        // 9x9 가우시안 필터 적용      histImg = draw_Histogram(b_hist);          peaks = draw_Line(b_hist, histImg);         // 반환 값을 담자.          for(iter = peaks.begin(); iter != peaks.end(); iter++)         cout&lt;&lt;*iter&lt;&lt;endl;      median = (peaks.at((peaks.size()/2)-1) + peaks.at((peaks.size()/2)+1))/2;      threshold(img1, dst, median, 255, THRESH_BINARY);          imshow(\"p1\", img1);     imshow(\"p2\", dst);          uchar *data_input = dst.data;      int count = 0;      for (int y = 0; y &lt; img2.rows; y++) {         for (int x = 0; x &lt; img2.cols-1; x++) {             uchar *data_output = img2.data;     // img2 이미지 위에 색깔을 그리기 위해 Element에 접근하는 data_output 포인터 변수              if(data_input[y*img2.cols+x] == 0) {        // 현재 Element의 값이 0이면, 즉 검은색이면                 if(count == 0){                         // 그때의 count 값이 0이면, 파랑색                 data_output[y * img2.cols*3 + x*3] = 255;           // B                 data_output[y * img2.cols*3 + x*3 + 1] = 144;       // G                 data_output[y * img2.cols*3 + x*3 + 2] = 30;        // R                 } else if(count == 1) {                 // 그때의 count 값이 1이면, 초록색                     data_output[y * img2.cols*3 + x*3] = 0;         // B                     data_output[y * img2.cols*3 + x*3 + 1] = 128;   // G                     data_output[y * img2.cols*3 + x*3 + 2] = 0;     // R                 }else if(count == 2) {                  // 그때의 count 값이 2이면, 빨강색                     data_output[y * img2.cols*3 + x*3] = 0;         // B                     data_output[y * img2.cols*3 + x*3 + 1] = 0;     // G                     data_output[y * img2.cols*3 + x*3 + 2] = 255;   // R                 }                  if(data_input[y*img2.cols+x+1] == 255) {            // 다음 Element의 값이 255이면, 즉 흰색이면                     if(count == 2)          // 그때의 count 값이 2라면                         count = 0;          // 0으로 변경                     else                    // 2가 아니라면                         count++;            // count 값을 1만큼 증가                 }             }else if(data_input[y*img2.cols+x] == 255) {            // 현재 Element의 값이 255이면, 즉 흰색이면 노랑색                 data_output[y * img2.cols*3 + x*3] = 0;             // B                 data_output[y * img2.cols*3 + x*3 + 1] = 255;       // G                 data_output[y * img2.cols*3 + x*3 + 2] = 255;       // R             }         }        }      imshow(\"Result\", img2);          waitKey(0);      return 0; }  ","categories": ["OpenCV","Algorithms"],
        "tags": ["OpenCV","Algorithms","Programming","Coding"],
        "url": "http://localhost:4000/opencv/algorithms/Assign-OpenCV-3/",
        "teaser": null
      },{
        "title": "BOJ: 1934 최소공배수",
        "excerpt":"문제   두 자연수 A와 B에 대해서, A의 배수이면서 B의 배수인 자연수를 A와 B의 공배수라고 한다. 이런 공배수 중에서 가장 작은 수를 최소공배수라고 한다. 예를 들어, 6과 15의 공배수는 30, 60, 90등이 있으며, 최소 공배수는 30이다.   두 자연수 A와 B가 주어졌을 때, A와 B의 최소공배수를 구하는 프로그램을 작성하시오.   입력   첫째 줄에 테스트 케이스의 개수 \\(T(1\\leq{T}\\leq{1,000})\\)가 주어진다. 둘째 줄부터 T개의 줄에 걸쳐서 A와 B가 주어진다. \\((1\\leq{A, B}\\leq{45,000})\\)   출력   첫째 줄부터 T개의 줄에 A와 B의 최소공배수를 입력받은 순서대로 한 줄에 하나씩 출력한다.   예제 입력 1   3 1 45000 6 10 13 17   예제 출력 1   45000 30 221       코드   #include &lt;iostream&gt;  using namespace std;  int get_least(int * a, int * b) {     int i=1, j=1;      if(a &lt; b) {         while(1) {             if(*a*i == *b*j)                 break;              if(*a*i &lt; *b*j)                 i++;             else                 j++;         }     }else{         while(1) {             if(*a*i == *b*j)                 break;              if(*a*i &gt; *b*j)                 j++;             else                 i++;         }     }      return *a*i; }  int main(void) {     int a, b;     int t;     int least;      cin&gt;&gt;t;      for(int i=0; i&lt;t; i++) {         cin&gt;&gt;a&gt;&gt;b;          least = get_least(&amp;a, &amp;b);          cout&lt;&lt;least&lt;&lt;endl;     }      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-3/",
        "teaser": null
      },{
        "title": "BOJ: 2581 소수",
        "excerpt":"문제   자연수 \\(M\\)과 \\(N\\)이 주어질 때 \\(M\\)이상 \\(N\\)이하의 자연수 중 소수인 것을 모두 골라 이들 소수의 합과 최솟값을 찾는 프로그램을 작성하시오.   예를 들어 \\(M=60, N=100\\)인 경우 60이상 100이하의 자연수 중 소수는 61, 67, 71, 73, 79, 83, 89, 97 총 8개가 있으므로, 이들 소수의 합은 620이고, 최솟값은 61이 된다.   입력   입력의 첫째 줄에 \\(M\\)이, 둘째 줄에 \\(N\\)이 주어진다.   \\(M\\)과 \\(N\\)은 10,000이하의 자연수이며, \\(M\\)은 \\(N\\)보다 작거나 같다.   출력   \\(M\\)이상 \\(N\\)이하의 자연수 중 소수인 것을 모두 찾아 첫째 줄에 그 합을, 둘째 줄에 그 중 최솟값을 출력한다.   단, \\(M\\)이상 \\(N\\)이하의 자연수 중 소수가 없을 경우는 첫째 줄에 -1을 출력한다.   예제 입력 1   60 100   예제 출력 1   620 61   예제 입력 2   64 65   예제 출력 2   -1       코드   #include &lt;iostream&gt;  #define OPERATOR_MIN(min, var) (min &gt; var) ? min = var : 0  using namespace std;  int prime_chk(int n) {     int count = 0;      for(int i=1; i&lt;=n; i++)         if(n%i == 0)             count++;      if(count != 2)         return 0;     else         return 1; }  void get_prime(int i, int j, int * arr) {      for(int k=i; k&lt;=j; k++) {         if(prime_chk(k)) {                 if(arr[2] == 0)                     arr[1] = k;                 else                     OPERATOR_MIN(arr[1], k);                  arr[0] += k;                 arr[2]++;         }     } }  int main(void) {     int i, j;     int arr[3] = {0,};      cin&gt;&gt;i&gt;&gt;j;      if(i&gt;=j)         get_prime(j, i, arr);     else         get_prime(i, j, arr);       if(arr[2] == 0)         cout&lt;&lt;-1;     else         cout&lt;&lt;arr[0]&lt;&lt;endl&lt;&lt;arr[1];          return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-4/",
        "teaser": null
      },{
        "title": "Linear Algebra: Solving Linear Equations - Vectors and Linear Equations #1",
        "excerpt":"Concepts   Multiplication by rows   \\(Ax\\) comes from dot products, each row times the column \\(x\\):   \\[Ax = \\begin{pmatrix}(row 1) \\cdot x \\\\ (row 2) \\cdot x \\\\ (row 3) \\cdot x  \\end{pmatrix}\\]  Multiplication by columns   \\(Ax\\) is a combination of column vectors:   \\[Ax = x(\\text{column 1}) + y(\\text{column 2}) + z(\\text{column 3})\\]      Questions   Question 1   Write \\(2x+3y+z+5t=8\\) as a matrix \\(A\\) (how many rows?) multiplying the column vector \\(x = (x, y, z, t)\\) to produce \\(b\\). The solutions \\(x\\) fill a plane or “hyperplane” in 4-dimensional space. The plane is 3-dimensional with no 4D volume.   Question 2   Find the matrix \\(P\\) that multiplies \\((x, y, z)\\) to give \\((y, z, x)\\). Find the Matrix \\(Q\\) that multiplies \\((y, z, x)\\) to bring back \\((x, y, z)\\).   Question 3   (a) What 2 by 2 matrix \\(R\\) rotates every vector by \\(90\\,^{\\circ}\\)? \\(R\\) times \\(\\begin{pmatrix}x \\\\ y\\end{pmatrix}\\) is \\(\\begin{pmatrix}y \\\\ -x\\end{pmatrix}\\) (b) What 2 by 2 matrix \\(R^{2}\\) rotates every vector by \\(180\\,^{\\circ}\\)?       Answers   Answer 1   \\[Ax = \\begin{pmatrix}2 &amp; 3 &amp; 1 &amp; 5\\end{pmatrix}\\begin{pmatrix}x \\\\ y \\\\ z \\\\ t \\\\ \\end{pmatrix}\\]     how many rows?    one row.   Answer 2      Find the matrix \\(P\\) that multiplies \\((x, y, z)\\) to give \\((y, z, x)\\).    \\[\\begin{pmatrix}0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\\\ 1 &amp; 0 &amp; 0 \\end{pmatrix}\\begin{pmatrix}x \\\\ y \\\\ z\\end{pmatrix} = \\begin{pmatrix}y \\\\ z \\\\ x\\end{pmatrix}\\]  \\[\\therefore P = \\begin{pmatrix}0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\\\ 1 &amp; 0 &amp; 0\\end{pmatrix}\\]     Find the Matrix \\(Q\\) that multiplies \\((y, z, x)\\) to bring back \\((x, y, z)\\).    \\[\\begin{pmatrix}0 &amp; 0 &amp; 1 \\\\ 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\end{pmatrix}\\begin{pmatrix}y \\\\ z \\\\ x\\end{pmatrix}\\]  \\[\\therefore Q = \\begin{pmatrix}0 &amp; 0 &amp; 1 \\\\ 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\end{pmatrix}\\]  Answer 3   (a)   \\[\\begin{pmatrix}0 &amp; 1 \\\\ -1 &amp; 0\\end{pmatrix}\\begin{pmatrix}x \\\\ y\\end{pmatrix} = \\begin{pmatrix}y \\\\ -x\\end{pmatrix}\\]  \\[\\therefore R = \\begin{pmatrix}0 &amp; 1 \\\\ -1 &amp; 0\\end{pmatrix}\\]  (b)   Intuitively, if a \\(90\\,^{\\circ}\\) rotation occurs when R is applied once, wouldn’t a \\(180\\,^{\\circ}\\) rotation occur when R is applied twice?   \\[\\therefore \\text{ Let's apply R to the answer obtained from (a) again.}\\]  \\[\\begin{pmatrix}y \\\\ -x\\end{pmatrix}\\begin{pmatrix}0 &amp; 1 \\\\ -1 &amp; 0\\end{pmatrix} = \\begin{pmatrix}-x \\\\ -y\\end{pmatrix}\\]      \\[\\text{By the way, It is the same as:}\\]  \\[\\begin{pmatrix}-1 &amp; 0 \\\\ 0 &amp; -1\\end{pmatrix}\\begin{pmatrix}x \\\\ y\\end{pmatrix} = \\begin{pmatrix}-x \\\\ -y\\end{pmatrix}\\]      \\[\\text{Here, }\\begin{pmatrix}-1 &amp; 0 \\\\ 0 &amp; -1\\end{pmatrix} = -I\\]  \\[\\therefore R^{2} = -I\\]  ","categories": ["Linear Algebra"],
        "tags": ["Mathematics","Linear Algebra"],
        "url": "http://localhost:4000/linear%20algebra/Studying_Linear-5/",
        "teaser": null
      },{
        "title": "Calculus: Functions and Limits - Calculating Limits Using the Limit Laws",
        "excerpt":"Question   Question 1   (a) What is wrong with the following equation?   \\[\\frac{x^{2}+x-6}{x-2} = x + 3\\]  (b) In view of part (a), explain why the equation   \\[\\lim_{x\\to{2}}\\frac{x^{2} + x - 6}{x - 2} = \\lim_{x\\to{2}}(x + 3)\\]  is correct.   Question 2   Is there a number \\(a\\) such that   \\[\\lim_{x\\to{-2}}{\\frac{3x^{2}+ax+a+3}{x^{2}+x-2}}\\]  exists? If so, find the value of \\(a\\) and the value of the limit.   Question 3   The figure shows a fixed circle \\(C_{1}\\) with equation \\((x-1)^{2} + y^{2} = 1\\) and a shrinking circle \\(C_{2}\\) with radius \\(r\\) and center the origin. \\(P\\) is the point \\((0, r)\\), \\(Q\\) is the upper point of intersection of the two circles, and \\(R\\) is the point of intersection of the line \\(PQ\\) and the x-axis. What happens to \\(R\\) as \\(C_{2}\\) shrinks, that is, as \\(r\\to{0^{+}}\\)?      Answer   Answer 1   (a)   \\[\\frac{x^{2}+x-6}{x-2} \\neq x + 3\\]  \\[(\\because \\frac{x^{2}+x-6}{x-2} \\text{ is not defined when x = 2})\\]  (b)   \\[\\lim_{x\\to{2}}\\frac{x^{2} + x - 6}{x - 2} = \\lim_{x\\to{2}}\\frac{(x-2)(x+3)}{x - 2}\\]  \\[= \\lim_{x\\to{2}}(x + 3)\\]  \\[(\\because x\\to{2} \\text{ is not equal to }x=2)\\]  Answer 2   \\[\\text{Since the denominator approaches 0 as } x\\to{-2}\\]  \\[\\text{The limit will exist only if the nominator approaches 0 as } x\\to{-2}\\]      \\[\\lim_{x\\to{-2}}{(3x^{2}+ax+a+3)} = 0\\]  \\[3(-2)^2+a(-2)+a+3 = 0\\]  \\[\\therefore a = 15\\]      \\[\\text{With } a = 15, \\text{the limit becomes}\\]  \\[\\lim_{x\\to{-2}}{\\frac{3x^{2}+15x+18}{x^{2}+x-2}} = \\lim_{x\\to{-2}}{\\frac{3(x+2)(x+3)}{(x-1)(x+2)}}\\]  \\[= \\lim_{x\\to{-2}}{\\frac{3(x+3)}{(x-1)}}\\]  \\[(\\because x\\to{-2} \\text{ is not equal to }x = -2)\\]  \\[= \\frac{3((-2)+3)}{((-2)-1)}\\]  \\[= \\frac{3}{(-3)} = -1\\]  Answer 3   \\[C_{1}: (x-1)^{2}+y^{2} = 1\\]  \\[C_{2}: x^{2} + y^{2} = r\\]  \\[\\text{We already know the coordinates of the point P is } (0, r) \\text{ from graph.}\\]  \\[\\text{Thus, we must first find the coordinates of the point } Q \\text{ to get the equation of the line } PR.\\]  \\[Q \\text{ is the upper point of intersection of the two circles.}\\]      \\[\\therefore x^{2} + 1 - (x-1)^{2} = r^{2}\\]  \\[x = \\frac{r^{2}}{2}\\]  \\[x = \\frac{r^{2}}{2} \\text{ is the } x\\text{-coordinate of the point Q.}\\]  \\[\\text{Substituting back into any equation of the two circles to find the } y\\text{-coordinate}.\\]  \\[(\\frac{r^{2}}{2})^{2} + y^{2} = r^{2}\\]  \\[y^{2} = r^{2} - (\\frac{r^{2}}{2})^{2}\\]  \\[y = \\sqrt{r^{2}-(\\frac{r^{2}}{2})^{2}}\\]  \\[(\\because y \\geq 0)\\]  \\[\\therefore y = \\sqrt{r^{2}-(\\frac{r^{2}}{2})^{2}} \\text{ is the } y\\text{-coordinate of the point Q.}\\]  \\[\\text{Now, The equation of the line joining } P \\text{ and } Q \\text{ is thus}\\]  \\[y = -\\frac{r-\\sqrt{r^{2}-(\\frac{r^{2}}{2})^{2}}}{\\frac{r^{2}}{2}}x + r\\]  \\[\\text{We set } y = 0 \\text{ in order to find the x-intercept, and get}\\]  \\[-\\frac{r-\\sqrt{r^{2}-(\\frac{r^{2}}{2})^{2}}}{\\frac{r^{2}}{2}}x + r = 0\\]  \\[x = \\frac{-r^{3}}{-2r+2\\sqrt{r^{2}-(\\frac{r^{2}}{2})^{2}}}\\]      \\[\\text{Let's take the limit as } r\\to{0^{+}}.\\]  \\[\\lim_{r\\to{0^{+}}}\\frac{-r^{3}}{-2r+2\\sqrt{r^{2}-(\\frac{r^{2}}{2})^{2}}}\\]      \\[\\lim_{r\\to{0^{+}}}\\frac{-r^{3}}{-2r+2\\sqrt{r^{2}-(\\frac{r^{2}}{2})^{2}}} = \\lim_{r\\to{0^{+}}}\\frac{-r^{3}}{-2r(1-\\sqrt{1-\\frac{r^{2}}{4}})}\\]  \\[= \\lim_{r\\to{0^{+}}}\\frac{r^{2}}{2(1-\\sqrt{1-\\frac{r^{2}}{4}})} = \\lim_{r\\to{0^{+}}}\\frac{r^{2}(1+\\sqrt{1-\\frac{r^{2}}{4}})}{2(1-\\sqrt{1-\\frac{r^{2}}{4}})(1+\\sqrt{1-\\frac{r^{2}}{4}})}\\]  \\[= \\lim_{r\\to{0^{+}}}\\frac{r^{2}(1+\\sqrt{1-\\frac{r^{2}}{4}})}{2\\{1-(1-\\frac{r^{2}}{4})\\}} = \\lim_{r\\to{0^{+}}}\\frac{r^{2}(1+\\sqrt{1-\\frac{r^{2}}{4}})}{\\frac{r^{2}}{2}}\\]  \\[= \\lim_{r\\to{0^{+}}}2(1+\\sqrt{1-\\frac{r^{2}}{4}}) = 4\\] ","categories": ["Calculus"],
        "tags": ["Mathematics","Calculus"],
        "url": "http://localhost:4000/calculus/Studying_Calculus-1/",
        "teaser": null
      },{
        "title": "C++ & Assembly : Settings for Visual Studio 2017",
        "excerpt":"내용   Dropper Lab 연구 활동 중 개인적으로 Visual Studio 2017에서 C++ 내에 Assembly 코드를 작성하는 방식(inline) 대신, 외부 참조 방식으로 코드를 작성할 일이 생겨, 이번 포스팅에서는 이와 관련하여 몇 가지 설정법에 대해 알아보고자 한다.   프로젝트 생성   먼저 프로젝트를 생성하자.   프로젝트 Type은 Console Application이다.      프로젝트 설정   사용자 지정 빌드   일단 솔루션 탐색기에서 프로젝트를 선택한 상태로, 메뉴에서 프로젝트 &gt; 사용자 지정 빌드를 선택하자.      다음과 같이 나오는 창에서 masm을 체크하고 확인을 누르자.      구성 관리자   메뉴에서 빌드 &gt; 구성 관리자를 선택하자.   그 후 다음의 노출되는 창에서      활성 솔루션 플랫폼 아래의 x86이 적혀있는 콤보박스를 내려서 x64로 변경하자.      어셈블리 파일 생성 및 설정   어셈블리 파일 생성   이제 어셈블리 파일을 생성할 차례이다.   솔루션 탐색기의 프로젝트 아래에 있는 소스 파일 directory에 오른쪽 마우스를 눌러서 나오는 드롭다운 메뉴에서 추가 &gt; 새 항목을 누르자.      파일의 Type은 C++ 파일(.cpp)을 선택하고, 아래의 이름 적는 란에는 파일의 확장자를 기존 .cpp에서 .asm으로 변경하자.   (참고로 기존 .cpp 파일과 동일 이름으로 파일명을 작성하진 말자.)      그리고 추가 버튼을 눌러주면 된다.   어셈블리 파일 설정   솔루션 탐색기 아래의 소스 파일 directory 내부에 생성된 .asm 파일을 선택한 후, 노출되는 드롭다운 메뉴에서 속성을 누르자.      노출되는 창에서 항목 형식이 Microsoft Macro Assembler인지 확인하자.   (만약 이것이 아니라면, 드롭다운 메뉴를 내려서 이것으로 설정해주자.)      설정이 되었다면, 왼쪽에 Microsoft Macro Assembler를 내려보면 Command Line이라는 항목이 존재하는 데 이를 눌러보자.   모든 옵션 아래에 있는 내용이 ml64.exe로 시작하는지 확인하자.      여기까지 완료했다면, 확인 버튼을 누르자.   코드 작성   단순히 동작 여부만을 확인하기 위해서 두 개의 정수 값을 인자로 받아서 이것의 덧셈을 반환하는 함수(IntegerAdd)를 어셈블리로 작성해보자.   필자는 .cpp 파일명을 main으로 .asm 파일명을 main2로 작성했다.   main.cpp   #include &lt;iostream&gt;  using namespace std;  extern \"C\" int IntegerAdd(int a, int b);  int main() {     int result = IntegerAdd(3, 5);      cout&lt;&lt;result&lt;&lt;endl;      return 0; }   main2.asm   .code IntegerAdd proc  mov eax, ecx add eax, edx  ret  IntegerAdd endp end   아래에 실행 결과를 보이면서 이번 포스팅을 마무리 짓겠다.   실행 결과      Reference   Reference  ","categories": ["Cpp","Assembly"],
        "tags": ["Programming","Tool"],
        "url": "http://localhost:4000/cpp/assembly/Studying_Assembly_in_Cpp-1/",
        "teaser": null
      },{
        "title": "BOJ: 1152 단어의 개수",
        "excerpt":"문제   영어 대소문자와 띄어쓰기만으로 이루어진 문자열이 주어진다. 이 문자열에는 몇 개의 단어가 있을까? 이를 구하는 프로그램을 작성하시오. 단, 한 단어가 여러 번 등장하면 등장한 횟수만큼 모두 세어야 한다.   입력   첫 줄에 영어 대소문자와 띄어쓰기로 이루어진 문자열이 주어진다. 이 문자열의 길이는 1,000,000을 넘지 않는다. 단어는 띄어쓰기 한 개로 구분되며, 공백이 연속해서 나오는 경우는 없다. 또한 문자열의 앞과 뒤에는 공백이 있을 수도 있다.   출력   첫째 줄에 단어의 개수를 출력한다.   예제 입력 1   The Curious Case of Benjamin Button   예제 출력 1   6   예제 입력 2    Mazatneunde Wae Teullyeoyo   예제 출력 2   3   예제 입력 3   Teullinika Teullyeotzi   예제 출력 3   2       코드   #include &lt;iostream&gt;  #define MAX 1000000  using namespace std;  int main(void) {     char str[MAX] = {0,};     int i=0;     int count = 0;      cin.getline(str, sizeof(str));      while(str[i] != 0) {          if(i == 0)              if((str[i] &gt;= 65 &amp;&amp; str[i] &lt;= 90) || (str[i] &gt;= 97 &amp;&amp; str[i] &lt;= 122))                 count++;                    if(i &lt; MAX - 1)              if(str[i] == ' ' &amp;&amp; ((str[i+1] &gt;= 65 &amp;&amp; str[i+1] &lt;= 90) || (str[i+1] &gt;= 97 &amp;&amp; str[i+1] &lt;= 122))                 count++;                            i++;     }      cout&lt;&lt;count;      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-5/",
        "teaser": null
      },{
        "title": "BOJ: 4344 평균은 넘겠지",
        "excerpt":"문제   대학생 새내기들의 90%는 자신이 반에서 평균은 넘는다고 생각한다. 당신은 그들에게 슬픈 진실을 알려줘야 한다.   입력   첫째 줄에는 테스트 케이스의 개수 \\(C\\)가 주어진다.   둘째 줄부터 각 테스트 케이스마다 학생의 수 \\(N(1 \\leq{N} \\leq{1000}, N\\)은 정수)이 첫 수로 주어지고, 이어서 \\(N\\)명의 점수가 주어진다. 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다.   출력   각 케이스마다 한 줄씩 평균을 넘는 학생들의 비율을 반올림하여 소수점 셋째 자리까지 출력한다.   예제 입력 1   5 5 50 50 70 80 100 7 100 95 90 80 70 60 50 3 70 90 80 3 70 90 81 9 100 99 98 97 96 95 94 93 91   예제 출력 1   40.000% 57.143% 33.333% 66.667% 55.556%       코드   #include &lt;iostream&gt; #include &lt;iomanip&gt;  using namespace std;  int main(void) {     int t, k;     int arr[1000];     int result = 0;     int avg;     int count = 0;      cin&gt;&gt;t;      for(int i=0; i&lt;t; i++) {         result = 0;         avg = 0;         count = 0;          cin&gt;&gt;k;          for(int j=0; j&lt;k; j++) {             cin&gt;&gt;arr[j];             result += arr[j];         }          avg = result / k;          for(int j=0; j&lt;k; j++)             if(arr[j] &gt; avg)                 count++;          cout.precision(3);         cout&lt;&lt;fixed&lt;&lt;(double)count*100/k&lt;&lt;'%'&lt;&lt;'\\n';       }      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-6/",
        "teaser": null
      },{
        "title": "BOJ: 1110 더하기 사이클",
        "excerpt":"문제   0보다 크거나 같고, 99보다 작거나 같은 정수가 주어질 때 다음과 같은 연산을 할 수 있다. 먼저 주어진 수가 10보다 작다면 앞에 0을 붙여 두 자리 수로 만들고, 각 자리의 숫자를 더한다. 그 다음, 주어진 수의 가장 오른쪽 자리 수와 앞에서 구한 합의 가장 오른쪽 자리 수를 이어 붙이면 새로운 수를 만들 수 있다. 다음 예를 보자.   26부터 시작한다. \\(2+6=8\\)이다. 새로운 수는 68이다. \\(6+8=14\\)이다. 새로운 수는 84이다. \\(8+4=12\\)이다. 새로운 수는 42이다. \\(4+2=6\\)이다. 새로운 수는 26이다.   위의 예는 4번만에 원래 수로 돌아올 수 있다. 따라서 26의 사이클의 길이는 4이다.   \\(N\\)이 주어졌을 때, \\(N\\)의 사이클의 길이를 구하는 프로그램을 작성하시오.   입력   첫째 줄에 \\(N\\)이 주어진다. \\(N\\)은 0보다 크거나 같고, 99보다 작거나 같은 정수이다.   출력   첫째 줄에 \\(N\\)의 사이클 길이를 출력한다.   예제 입력 1   26   예제 출력 1   4   예제 입력 2   55   예제 출력 2   3   예제 입력 3   1   예제 출력 3   60   예제 입력 4   0   예제 출력 4   1       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int a, b, c;     int result = 0;     int count = 0;      cin&gt;&gt;a;      b = a;      while(1) {         result = 0;          c = (b % 10) * 10;          while(1) {             if(b == 0)                 break;              result += (b % 10);              b /= 10;         }          c += (result % 10);          if(a == c)             break;          b = c;         count++;     }      cout&lt;&lt;count+1;      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-7/",
        "teaser": null
      },{
        "title": "BOJ: 2292 벌집",
        "excerpt":"문제      위의 그림과 같이 육각형으로 이루어진 벌집이 있다. 그림에서 보는 바와 같이 중앙의 방 1부터 시작해서 이웃하는 방에 돌아가면서 1씩 증가하는 번호를 주소로 매길 수 있다. 숫자 \\(N\\)이 주어졌을 때, 벌집의 중앙 1에서 \\(N\\)번 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나가는지(시작과 끝을 포함하여)를 계산하는 프로그램을 작성하시오. 예를 들면, 13까지는 3개, 58까지는 5개를 지난다.   입력   첫째 줄에 \\(N(1\\leq{N}\\leq{1,000,000,000})\\)이 주어진다.   출력   입력으로 주어진 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나는지 출력한다.   예제 입력 1   13   예제 출력 1   3       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int i;     int j=1;     int k=1;     int count = 1;      cin&gt;&gt;i;      while(1) {                  if(j&gt;=i)             break;          count++;          j=k*6+j;         k++;     }      cout&lt;&lt;count;      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-8/",
        "teaser": null
      },{
        "title": "Statistics: 제1장 통계학의 기초",
        "excerpt":"질문 &amp; 답변   1. 통계학을 정의하라.   통계학(Statistics)이란 불확실한 환경에서 그의 상황을 분석하고 불확실성을 최소화함으로써 좀더 효과적인 의사결정을 할 수 있도록 수치자료(Numerical data)를 수집, 정리, 표현, 분석, 해석하는 수학의 한 분야이다.      통계학의 핵심 또는 목적은 효과적인 의사결정이다.   다음 용어를 설명하라.   (1) 통계치와 모수치   통계치(표본 통계치, Statistics)란 통계량의 특정한 값을 말한다.   즉, 통계치는 모집단에서 추출된 표본의 구성원들이 소유하고 있는 변인들의 특성을 요약한 것입니다. 따라서 통계치는 모수치에 대응되며, 표본조사를 통해 모집단의 특성을 밝힌다는 것은 표본 통계치를 통해 모수치를 추정한다는 의미입니다.   모수치(Parameter)란 모수의 특정한 값을 말한다.   즉, 모수치는 모집단의 구성원들이 소유하고 있는 변인들의 특성입니다.   (2) 모집단과 표본   모집단(Population)이란 연구자가 통계분석을 하고 결론을 내리고자 하는 어떤 기본단위의 관심 있는 특정 변수에 관해 수집한 가능한 모든 관찰치를 말한다.   모집단은 우리가 무엇을 알려고 하느냐에 따라 다르게 정의되기 때문에 모집단을 명확하게 정의하는 것은 매우 중요한 일입니다.   표본(Sample)이란 통계분석을 할 목적으로 모집단에서 추출한 그의 일부분을 말한다.   간단히 말해 표본은 모집단의 다룰 수 있을만한 크기의 부분집합입니다. 표본이 얻어지면 모집단으로부터 얻은 표본에 대해 추론(Inference) 또는 외삽법(Extrapolation)을 하기 위하여 통계적 계산이 수행됩니다.   (3) 모수와 통계량   모수(Population parameter)란 모집단의 특성을 말한다.   즉, 모집단의 표준편차, 모집단의 평균 등을 모수라 할 수 있습니다.   통계량(Statistic)이란 모집단에서 추출한 표본의 특성을 말한다.   즉, 표본을 통해서 얻어진 숫자들을 정리/요약한 것들을 말합니다.   또한, 통계량이란 표본의 몇몇 특징을 수치화한 값입니다. 표본을 입력으로, 특정한 함수를 계산함으로써 그 값을 계량하게 됩니다. 좀 더 엄밀하게, 통계학에서는 표본의 분포가 무엇이든지 상관없이 정해진 함수가 있을 때에, 표본의 함수 값을 통계량으로 정의합니다.   예를 들어, 표본의 산술 평균은 데이터의 값을 모두 더하고 데이터의 개수로 나눠줌으로써 계산됩니다. 이 때, 이 산술 평균은 하나의 통계량입니다. 이처럼 구한 표본 평균은 주로 모평균을 추정할 때에 사용됩니다. 그러나 모평균은 통계량이 아닌데, 그 이유는 표본으로부터 계산되는 값이 아니기 때문입니다.   (4) 통계적 추론   통계적 추론(Statistical inference) 또는 통계적 추측은 모집단에 대한 어떤 미지의 양상을 알기 위해 통계학을 이용하여 추측하는 과정을 말합니다. 통계학의 한 부분으로서 추론 통계학이라고 불립니다. 이것은 기술 통계학(Descriptive statistics)과 구별되는 개념입니다. 추론 통계에는 도수 확률(Frequency probability)과 사전 확률(Prior probability)을 기반으로 하는 베이즈 추론의 두 학파가 있습니다.      최종적으로 알고 싶은 정보는 통계량이 아닌, 모수입니다.   3. 모집단 대신 표본조사에 의존하는 이유는 무엇인가?   예를 들어, 금강에 살고 있는 물고기 전체를 조사하는 경우에는 이 물고기의 전체 개체 수조차 확인이 불가능한 상황 즉, 모집단 조사 자체가 불가능한 경우가 있을 수 있고, 이와 마찬가지로 콘크리트의 강도를 알아내기 위해서 모든 건물의 콘크리트 조각에 대해서 조사하는 것도 마치 모래밭에서 바늘을 찾는 것처럼 모집단 조사 자체가 불가능한 경우에 포함된다 할 수 있습니다. 또 다른 이유로서 모집단 조사는 표본조사에 비해 막대한 시간과 돈의 손실이 발생하기 때문에 실용성이 떨어진다고도 할 수 있습니다. 이러한 이유로 모집단 조사에 의존하는 것 대신에 표본조사에 의존하는 것이라 할 수 있습니다.   4. 기술통계학과 추리통계학을 비교 설명하라.   기술통계학과 추리통계학의 정의는 다음과 같습니다.   기술통계학이란 표본이나 모집단의 측정이나 실험을 통해 수집한 통계자료를 정보로 전환하기 위하여 표, 그래프, 요약 특성치로 정리/표현/요약/해석을 통하여 자료의 특성을 규명하는 방법과 기법을 말한다.   단순히 기술통계학은 수집된 데이터를 그래프나 표로 만들어 간단하고 단순하게 설명하기 위한 통계학이라면, 추리통계학은 이러한 기술통계학을 이용하여 결론을 도출해내는 통계학, 즉 데이터를 통해서 무엇인가를 추정해내는 과정, 그 자체를 의미하는 통계학이라 할 수 있습니다.   위의 2번에서 언급된 모집단, 모수, 표본, 통계량 등을 기술통계학과 추리통계학을 이용하여 설명하면, 모집단에서 모수를 계산하는 것과 표본을 통해서 통계량을 계산하는 것 모두 기술통계학이고, 통계량을 가지고서 모수를 추리한다면 이는 기술통계학이 아닌 추리통계학입니다.   5. 추리통계학이 오늘날 통계학의 주류를 이루는 이유는 무엇인가?   모집단(대상)이 100명 정도로 비교적 적은 숫자라면 모든 대상 하나하나를 조사할 수 있지만, 만약 그 숫자가 대상 하나하나를 조사할 수 없을 정도로 많아진다면, 이러한 경우 혹여 모집단을 전부 조사한다하더라도 막대한 비용과 시간이 소요될 것입니다. 그러므로 우리는 모집단 전체에서 표본을 추출하고, 추출된 데이터를 통해 원래의 집단의 특성을 알아낼 수만 있다면 이러한 근본적인 문제를 해결할 수 있을 것입니다. 이러한 생각에서 발생한 추리통계학은 기존의 모집단 전체를 조사하여 특성을 파악하는 방식에서 탈피하여 표본 정보에 입각하여 모집단에 관한 일반적 결론을 도출하기 때문에 위에서 상술한 근본 문제를 해결할 수 있을 뿐만 아니라 기존 방식과 동일하게 효율적으로 의사 결정을 내릴 수도 있습니다. 이러한 이유로 추리통계학이 통계학 분야에서 주류를 이루게 되었다고 말할 수 있습니다.   6. 통계분석에 있어서 연역적 방법과 귀납적 방법을 비교 설명하라.   연역법(Inductive Method)과 귀납법(Deductive Method)의 정의는 다음과 같습니다.   연역법(Inductive Method)이란 미리 알고 있는 모집단에 관한 정보에 입각해서 그로부터 추출한 표본의 특성에 대해 결론을 내리는 방법이다.   즉, 일반적인 정보를 사용하여 특수한 경우에 대해 결론을 내리는 방법입니다.   귀납법(Deductive Method)이란 표본정보에 입각해서 그것이 추출된 모집단의 특성에 대해 결론을 내리는 추리통계학과 같은 개념이다.   즉, 특수한 정보에 입각해서 일반적 결론을 이끌어 내는 방법입니다.   우리가 모집단에 대해서 어느 정도 그 특성을 알고 있을 때, 즉 데이터를 이용하여 알고 있는 결론이 맞는지/틀린지를 검증하는 방법이 연역법이라면, 귀납법은 우리가 얻은 정보를 가지고서 어떤 일반적인 결론을 내는 방법이라고 할 수 있습니다.   연역적 방법의 연구는 다음의 절차를 밟습니다.      이론 -&gt; 가설 설정 -&gt; 연구 설계(조직화 및 측정과정 전반에 대한 설계) -&gt; 측정 -&gt; 자료수집 -&gt; 자료 분석 -&gt; 경험적 일반화    귀납적 방법의 연구는 다음의 절차를 밟습니다.      경험적 관찰 -&gt; 가설 설정 -&gt; 연구 설계(조직화 및 측정과정 전반에 대한 설계) -&gt; 측정 -&gt; 자료수집 -&gt; 자료 분석 -&gt; 이론    연역적인 방법의 조사는 연구자가 사전에 미리 결과에 대해서 예언하고, 이를 검증하는 과정을 밟는 것으로, 일반적인 사실에서 특수한 사실을 이끌어낸다는 것이 그 특징입니다.   이와는 다르게 귀납적인 방법의 조사는 탐구한 자료로부터 일반적인 원리를 도출해내는 방법을 의미합니다. 특수한 사실에서 일반적인 사실을 이끌어낸다는 것이 그 특징입니다.   7. 모평균과 표본평균을 조사할 때 서로 일치하지 않을 가능성이 높은데 그 이유는 무엇인가?   표본조사의 전제로서 오차 발생을 염두에 두기 때문입니다. 사실 모집단에서 표본 즉, sample을 추출하여 이에 대한 평균을 구했을지라도 이러한 sample data들이 population data들의 성격을 온전히 반영하고 있다고 말할 수는 없습니다. 극단적으로는 추출한 sample data들이 모집단의 성격을 전혀 대표하지 않는 데이터일 수도 있습니다. 그러므로 운이 좋아 오차가 설령 존재하지 않는 상황이 있을지라도 이것이 오차의 완전한 배제를 의미하지는 않기 때문에 오차 발생은 항상 존재한다고 간주하는 것이 옳습니다. 또한, 통계학의 정의 자체에서 볼 수 있듯이, 우리는 통계학을 통해 효율적인 의사 결정을 하기 위함이지 이 학문이 100% 정확한 의사결정을 하기 위해 탄생한 학문은 아니므로 이러한 오차 발생이 전제되어 있을지라도 이것이 통계학의 정의를 위배하지는 않습니다. 그러므로 이러한 관점에서 모평균과 표본평균을 조사할 때 서로 일치하지 않을 가능성이 높은 것은 어찌보면 당연한 것이라 할 수 있겠습니다.  ","categories": ["Statistics"],
        "tags": ["Statistics"],
        "url": "http://localhost:4000/statistics/Studying-Statistics-1/",
        "teaser": null
      },{
        "title": "Geomatics Engineering: 거리오차 증명",
        "excerpt":"질문      다음 거리오차를 증명하라.   \\[d-D = \\frac{D^{3}}{12r^{2}}\\]  \\[(\\text{Here, } D = 2r\\frac{\\theta}{2})\\]  답변   \\[\\tan{\\frac{\\theta}{2}} = \\frac{\\frac{d}{2}}{r}\\]  \\[\\therefore d = 2r\\tan{\\frac{\\theta}{2}}\\]      \\[\\text{Here,}\\]  \\[\\text{By Taylor series}\\]  \\[tan{\\frac{\\theta}{2}} = \\frac{\\theta}{2} + \\frac{1}{3}(\\frac{\\theta}{2})^{3} + \\cdots\\]  \\[\\therefore d = 2r\\{\\frac{\\theta}{2} + \\frac{1}{3}(\\frac{\\theta}{2})^{3}\\}\\]      \\[d = 2r\\{\\frac{\\theta}{2} + \\frac{1}{3}(\\frac{\\theta}{2})^{3}\\} = 2r\\{\\frac{D}{2r} + \\frac{1}{3}(\\frac{D}{2r})^{3}\\}\\]  \\[(\\because \\frac{\\theta}{2} = \\frac{D}{2r})\\]  \\[= D + \\frac{2r}{3}(\\frac{D^{3}}{8r^{3}})\\]  \\[= D + \\frac{D^{3}}{12r^{2}}\\]      \\[\\therefore d-D = \\frac{D^{3}}{12r^{2}}\\] ","categories": ["Geomatics Engineering"],
        "tags": ["Geomatics Engineering"],
        "url": "http://localhost:4000/geomatics%20engineering/Studying-Geomatics-1/",
        "teaser": null
      },{
        "title": "Geomatics Engineering: 구과량 증명",
        "excerpt":"Question   Girard’s Theorem   A spherical triangle on the surface of a sphere of radius \\(r\\), with angles \\(A, B\\) and \\(C\\), has area, \\(T\\), given by   \\[T = r^{2}(A+B+C-\\frac{1}{2}\\tau)\\text{,}\\]  \\[\\text{where }\\tau = 2\\pi.\\]             \\[\\text{(1) Prove Girard's Theorem.}\\]  \\[\\text{(2) Prove that } \\varepsilon^{''} = \\frac{T}{r^{2}}\\rho^{''}.\\]  Answer   (1)   \\[Proof\\]  \\[\\text{A sphere of radius } r \\text{ has surface area } 2\\tau{r^{2}}.\\]      \\[\\text{If two great circles meet in a lunar angle }\\theta, 0 &lt; \\theta \\leq{\\tau}, \\text{then the proportion of surface area which is occupied by the lune they create is } \\frac{\\theta}{\\tau}.\\]  \\[\\therefore \\text{ We have area of lune with lunar angle } \\theta.\\]  \\[\\frac{\\theta}{\\tau} \\times 2\\tau{r^{2}} = 2r^{2}\\theta\\]      \\[\\text{Denote by } L_{A}, L_{B} \\text{ and } L_{C} \\text{ the areas of the three lunes with angles } A, B \\text{ and } C, \\text{ respectively}.\\]  \\[\\text{Also, Denote by } T \\text{ the area of triangle } ABC;\\]      \\[\\text{These areas}(L_{A}, L_{B}, L_{C}) \\text{ each have an antipodal duplicate.}\\]  \\[\\text{Likewise, } T \\text{ also has its antipodal duplicate.}\\]  \\[\\therefore 2L_{A} + 2L_{B} + 2L_{C} = 2r^{2}\\tau + 4T\\]      \\[T = \\frac{1}{2}(L_{A} + L_{B} + L_{C} - r^2\\tau)\\]  \\[= \\frac{1}{2}(2r^{2}A + 2r^{2}B + 2r^{2}C - r^{2}\\tau)\\]  \\[= r^{2}(A + B + C - \\frac{1}{2}\\tau)\\]      (2)   \\[Proof\\]  \\[\\text{Let's replace } A + B + C - \\frac{1}{2}\\tau \\text{ with } \\varepsilon.\\]  \\[\\therefore T = r^{2}\\varepsilon\\]  \\[\\varepsilon = \\frac{T}{r^{2}}\\]      \\[\\text{Here,}\\]  \\[\\rho^{''} = \\frac{180^{\\circ}}{\\pi}\\]  \\[\\therefore \\varepsilon^{''} = \\frac{T}{r^{2}}\\rho^{''}\\]  ","categories": ["Geomatics Engineering"],
        "tags": ["Geomatics Engineering"],
        "url": "http://localhost:4000/geomatics%20engineering/Studying-Geomatics-2/",
        "teaser": null
      },{
        "title": "BOJ: 2577 숫자의 개수",
        "excerpt":"문제   세 개의 자연수 \\(A, B, C\\)가 주어질 때 \\(A \\times B \\times C\\)를 계산한 결과에 0부터 9까지 각각의 숫자가 몇 번씩 쓰였는지를 구하는 프로그램을 작성하시오.   예를 들어 \\(A = 150, B = 266, C = 427\\) 이라면 \\(A \\times B \\times C = 150 \\times 266 \\times 427 = 17037300\\) 이 되고, 계산한 결과 17037300 에는 0이 3번, 1이 1번, 3이 2번, 7이 2번 쓰였다.   입력   첫째 줄에 \\(A\\), 둘째 줄에 \\(B\\), 셋째 줄에 \\(C\\)가 주어진다. \\(A, B, C\\)는 모두 100보다 같거나 크고, \\(1,000\\)보다 작은 자연수이다.   출력   첫째 줄에는 \\(A \\times B \\times C\\)의 결과에 0이 몇 번 쓰였는지 출력한다. 마찬가지로 둘째 줄부터 열 번째 줄까지 \\(A \\times B \\times C\\)의 결과에 1부터 9까지의 숫자가 각각 몇 번 쓰였는지 차례로 한 줄에 하나씩 출력한다.   예제 입력 1   150 266 427   예제 출력 1   3 1 0 2 0 0 0 2 0 0       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {   int num[10] = {0, };   int a, b, c;   int t;    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;    t = a*b*c;    while(1) {     if(t == 0)       break;          num[t%10]++;      t /= 10;   }    for(int i=0; i&lt;10; i++)     cout&lt;&lt;num[i]&lt;&lt;endl;    return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-9/",
        "teaser": null
      },{
        "title": "BOJ: 2884 알람 시계",
        "excerpt":"문제   상근이는 매일 아침 알람을 듣고 일어난다. 알람을 듣고 바로 일어나면 다행이겠지만, 항상 조금만 더 자려는 마음 때문에 매일 학교를 지각하고 있다.   상근이는 모든 방법을 동원해보았지만, 조금만 더 자려는 마음은 그 어떤 겂도 없앨 수가 없었다.   이런 상근이를 불쌍하게 보던, 창영이는 자신이 사용하는 방법을 추천해 주었다.   바로 “45분 일찍 알람 설정하기”이다.   이 방법은 단순하다. 원래 설정되어 있는 알람을 45분 앞서는 시간으로 바꾸는 것이다. 어차피 알람 소리를 들으면, 알람을 끄고 조금 더 잘 것이기 때문이다. 이 방법을 사용하면, 매일 아침 더 잤다는 기분을 느낄 수 있고, 학교도 지각하지 않게 된다.   현재 상근이가 설정한 알람 시각이 주어졌을 때, 창영이의 방법을 사용한다면, 이를 언제로 고쳐야 하는지 구하는 프로그램을 작성하시오.   입력   첫째 줄에 두 정수 \\(H\\)와 \\(M\\)이 주어진다. \\((0 \\leq H \\leq 23, 0 \\leq M \\leq 59)\\) 그리고 이것은 현재 상근이가 설정해 놓은 알람 시간 \\(H\\)시 \\(M\\)분을 의미한다.   입력 시간은 24시간 표현을 사용한다. 24시간 표현에서 하루의 시작은 \\(0:0\\)(자정)이고, 끝은 \\(23:59\\)(다음날 자정 1분 전)이다. 시간을 나타낼 때, 불필요한 0은 사용하지 않는다.   출력   첫째 줄에 상근이가 창영이의 방법을 사용할 때, 설정해야 하는 알람 시간을 출력한다. (입력과 같은 형태로 출력하면 된다.)   예제 입력 1   10 10   예제 출력 1   9 25   예제 입력 2   0 30   예제 출력 2   23 45   예제 입력 3   23 40   예제 출력 3   22 55       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int h, m;     int cal;          cin&gt;&gt;h&gt;&gt;m;      cal = h*60+m-45;      if(cal &lt; 0) {         h = 23;         m = 60 + cal;     }else{         h = cal / 60;         m = cal % 60;     }      cout&lt;&lt;h&lt;&lt;' '&lt;&lt;m;          return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-10/",
        "teaser": null
      },{
        "title": "BOJ: 15552 빠른 A+B",
        "excerpt":"문제   본격적으로 for문 문제를 풀기 전에 주의해야 할 점이 있다. 입출력 방식이 느리면 여러 줄을 입력받거나 출력할 때 시간초과가 날 수 있다는 점이다.   C++을 사용하고 있고 cin / cout을 사용하고자 한다면, cin.tie(NULL)과 sync_with_stdio(false)를 둘 다 적용해 주고, endl 대신 개행문자(\\n)을 쓰자. 단, 이렇게 하면 더 이상 scanf / printf / puts / getchar / putchar 등 C의 입출력 방식을 사용하면 안 된다.   Java를 사용하고 있다면, Scanner와 System.out.println 대신 BufferedReader와 BufferedWriter를 사용할 수 있다. BufferedWriter.flush는 맨 마지막에 한 번만 하면 된다.   Python을 사용하고 있다면, input 대신 sys.stdin.readline을 사용할 수 있다. 단, 이때는 맨 끝의 개행문자까지 같이 입력받기 때문에 문자열을 저장하고 싶을 경우 .rstrip()을 추가로 해 주는 것이 좋다.   또한 입력과 출력 스트림은 별개이므로, 테스트케이스를 전부 입력받아서 저장한 뒤 전부 출력할 필요는 없다. 테스트케이스를 하나 받은 뒤 하나 출력해도 된다.   자세한 설명 및 다른 언어의 경우는 이 글에 설명되어 있다.   이 블로그 글에서 BOJ의 기타 여러 가지 팁을 볼 수 있다.   입력   첫 줄에 테스트케이스의 개수 \\(T\\)가 주어진다. \\(T\\)는 최대 1,000,000이다. 다음 \\(T\\)줄에는 각각 두 정수 \\(A\\)와 \\(B\\)가 주어진다. \\(A\\)와 \\(B\\)는 1 이상, 1,000 이하이다.   출력   각 테스트케이스마다 \\(A+B\\)를 한 줄에 하나씩 순서대로 출력한다.   예제 입력 1   5 1 1 12 34 5 500 40 60 1000 1000   예제 출력 1   2 46 505 100 2000       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     ios_base::sync_with_stdio(false); cin.tie(NULL);      int a, b, t;      cin&gt;&gt;t;      for(int i=0; i&lt;t; i++) {         cin&gt;&gt;a&gt;&gt;b;          cout&lt;&lt;a+b&lt;&lt;'\\n';     }      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-11/",
        "teaser": null
      },{
        "title": "BOJ: 3052 나머지",
        "excerpt":"문제   두 자연수 \\(A\\)와 \\(B\\)가 있을 때, \\(A%B\\)는 \\(A\\)를 \\(B\\)로 나눈 나머지이다. 예를 들어, 7, 14, 27, 38을 3으로 나눈 나머지는 1, 2, 0, 2이다.   수 10개를 입력받은 뒤, 이를 42로 나눈 나머지를 구한다. 그 다음 서로 다른 값이 몇 개 있는지 출력하는 프로그램을 작성하시오.   입력   첫째 줄부터 열번째 줄까지 숫자가 한 줄에 하나씩 주어진다. 이 숫자는 1,000보다 작거나 같고, 음이 아닌 정수이다.   출력   첫째 줄에, 42로 나누었을 때, 서로 다른 나머지가 몇 개 있는지 출력한다.   예제 입력 1   1 2 3 4 5 6 7 8 9 10   각 수를 42로 나눈 나머지는 1, 2, 3, 4, 5, 6, 7, 8, 9, 10이다.   예제 출력 1   10   예제 입력 2   42 84 252 420 840 126 42 84 420 126   예제 출력 2   1   모든 수를 42로 나눈 나머지는 0이다.   예제 입력 3   39 40 41 42 43 44 82 83 84 85   각 수를 42로 나눈 나머지는 39, 40, 41, 0, 1, 2, 40, 41, 0, 1이다. 서로 다른 값은 6개가 있다.   예제 출력 3   6       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int arr[10];     int num[42] = {0,};     int count = 0;       for(int i=0; i&lt;10; i++) {         cin&gt;&gt;arr[i];         num[arr[i]%42]++;     }              for(int i=0; i&lt;42; i++)         if(num[i] &gt; 0)             count++;      cout&lt;&lt;count;      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-12/",
        "teaser": null
      },{
        "title": "BOJ: 1920 수 찾기",
        "excerpt":"문제   \\(N\\)개의 정수 \\(A[1], A[2], \\cdots, A[N]\\)이 주어져 있을 때, 이 안에 \\(X\\)라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.   입력   첫째 줄에 자연수 \\(N(1 \\leq N \\leq 100,000)\\)이 주어진다. 다음 줄에는 \\(N\\)개의 정수 \\(A[1], A[2], \\cdots, A[N]\\)이 주어진다. 다음 줄에는 \\(M(1 \\leq M \\leq 100,000)\\)이 주어진다. 다음 줄에는 \\(M\\)개의 수들이 주어지는데, 이 수들이 \\(A\\)안에 존재하는지 알아내면 된다. 모든 정수의 범위는 \\(-2^{31}\\)보다 크거나 같고 \\(2^{31}\\)보다 작다.   출력   \\(M\\)개의 줄에 답을 출력한다. 존재하면 1을, 존재하지 않으면 0을 출력한다.   예제 입력 1   5 4 1 5 2 3 5 1 3 7 9 5   예제 출력 1   1 1 0 0 1       코드   #include &lt;iostream&gt;  #define EXCHANGE(x, y, temp) temp = x; x = y; y = temp; #define MAX 100001  using namespace std;  int partition(int* arr_n, int low, int high) {     int first = low;     int pivot = arr_n[first];     int temp;      while(low &lt;= high) {         while(arr_n[low] &lt;= pivot &amp;&amp; low &lt; high)             ++low;         while(arr_n[high] &gt;= pivot &amp;&amp; low &lt;= high)             --high;                  if(low &lt; high) {             EXCHANGE(arr_n[low], arr_n[high], temp);         }else {             break;         }                  }      EXCHANGE(arr_n[first], arr_n[high], temp);      return high; }  void quick_sort(int* arr_n, int low, int high) {      if(high &gt; low) {         int index = partition(arr_n, low, high);         quick_sort(arr_n, low, index - 1);         quick_sort(arr_n, index + 1, high);     } }  int binary_search(const int* arr_n, int n, int x) {     int low = 0, mid, high = n;      while(low &lt;= high) {         mid = (low+high)/2;          if(x == arr_n[mid])             return 1;         else if(x &lt; arr_n[mid])             high = mid - 1;         else             low = mid + 1;     }          return 0; }   int main(void) {     int arr_n[MAX];     int arr_m[MAX];     int arr_t[MAX];      int n, m;      cin&gt;&gt;n;      for(int i=0; i&lt;n; i++)         cin&gt;&gt;arr_n[i];      quick_sort(arr_n, 0, n-1);      cin&gt;&gt;m;      for(int i=0; i&lt;m; i++)         cin&gt;&gt;arr_m[i];      for(int i=0; i&lt;m; i++) {         if(binary_search(arr_n, n-1, arr_m[i]))             arr_t[i] = 1;         else             arr_t[i] = 0;     }      for(int i=0; i&lt;m; i++)         cout&lt;&lt;arr_t[i]&lt;&lt;'\\n';              return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-13/",
        "teaser": null
      },{
        "title": "BOJ: 2164 카드2",
        "excerpt":"문제   \\(N\\)장의 카드가 있다. 각각의 카드는 차례로 1부터 \\(N\\)까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, \\(N\\)번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.   이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.   예를 들어 \\(N=4\\)인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나며, 남는 카드는 4가 된다.   \\(N\\)이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오.   입력   첫째 줄에 정수 \\(N(1 \\leq N \\leq 500,000)\\)이 주어진다.   출력   첫째 줄에 남게 되는 카드의 번호를 출력한다.   예제 입력 1   6   예제 출력 1   4       코드   #include &lt;iostream&gt; #include &lt;queue&gt;  using namespace std;  int main(void) {     queue&lt;int&gt; q;      int n;      cin&gt;&gt;n;      for(int i=0; i&lt;n; i++)         q.push(i+1);      while(q.size() != 1) {         q.pop();         int temp = q.front();         q.pop();         q.push(temp);     }      cout&lt;&lt;q.front();      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-14/",
        "teaser": null
      },{
        "title": "Calculus: Applications of Differentiation - The Mean Value Theorem #1",
        "excerpt":"Concepts   The Mean Value Theorem   Lef \\(f\\) be a function that satisfies the following hypotheses:      \\(f\\) is continuous on the closed interval \\([a, b]\\).   \\(f\\) is differentiable on the open interval \\((a, b)\\).   Then there is a number \\(c\\) in \\((a, b)\\) such that   \\[f^{'}(c) = \\frac{f(b) - f(a)}{b - a}\\]  or, equivalently,   \\[f(b) - f(a) = f^{'}(c)(b - a)\\]  Questions   Consider the following function and closed interval.   \\[f(x) = x^{3} - 3x + 4, [-2, 2]\\]  Question 1   Find \\(\\frac{f(b) - f(a)}{b - a}\\) for \\([a, b] = [-2, 2]\\). (If an answer does not exist, enter DNE.)   \\[\\frac{f(b) - f(a)}{b - a} = ?\\]  Question 2   If the mean value theorem can be applied, find all values of \\(c\\) that satisfy the conclusion of the mean value theorem. (Enter your answers as a comma-separated list. If it does not satisfy the hypotheses, enter DNE).   \\[c = ?\\]  Answers   Answer 1      Answer 2      ","categories": ["Calculus"],
        "tags": ["Mathematics","Calculus"],
        "url": "http://localhost:4000/calculus/Studying-Calculus-2/",
        "teaser": null
      },{
        "title": "Calculus: Applications of Differentiation - The Mean Value Theorem #2",
        "excerpt":"Questions   Question 1   If \\(f(3) = 3\\) and \\(f^{'}(x) \\geq 3\\) for \\(3 \\leq x \\leq 8\\), how small can \\(f(8)\\) possibly be?   \\[f(8) \\geq \\text{ } ?\\]  Answers   Answer 1     ","categories": ["Calculus"],
        "tags": ["Mathematics","Calculus"],
        "url": "http://localhost:4000/calculus/Studying-Calculus-3/",
        "teaser": null
      },{
        "title": "Calculus: Applications of Differentiation - The Mean Value Theorem #3",
        "excerpt":"Questions   Question 1   At 2:00 p.m. a car’s speedometer reads 50\\(km/h\\). At 2:20 p.m. it reads 65\\(km/h\\). Show that at some time between 2:00 and 2:20 the acceleration is exactly 45\\(km/h^{2}\\).   Let \\(v(t)\\) be the velocity of the car \\(t\\) hours after 2:00 p.m. Then \\(\\frac{v(1/3) - v(0)}{1/3 - 0} = ?\\). By the Mean Value Theorem, there is a number \\(c\\) such that \\(0 &lt; c &lt; ?\\) with \\(v^{'}(c) = ?\\). Since \\(v^{'}(t)\\) is the acceleration at time \\(t\\), the acceleration \\(c\\) hours after 2:00 p.m. is exactly 45 \\(km/h^{2}\\).   Answers   Answer 1     ","categories": ["Calculus"],
        "tags": ["Mathematics","Calculus"],
        "url": "http://localhost:4000/calculus/Studying-Calculus-4/",
        "teaser": null
      },{
        "title": "BOJ: 8958 OX퀴즈",
        "excerpt":"문제   “OOXXOXXOOO”와 같은 OX퀴즈의 결과가 있다. O는 문제를 맞은 것이고, X는 문제를 틀린 것이다. 문제를 맞은 경우 그 문제의 점수는 그 문제까지 연속된 O의 개수가 된다. 예를 들어, 10번 문제의 점수는 3이 된다.   “OOXXOXXOOO”의 점수는 \\(1+2+0+0+1+0+0+1+2+3 = 10\\)점이다.   OX퀴즈의 결과가 주어졌을 때, 점수를 구하는 프로그램을 작성하시오.   입력   첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 길이가 0보다 크고 80보다 작은 문자열이 주어진다. 문자열은 O와 X만으로 이루어져 있다.   출력   각 테스트 케이스마다 점수를 출력한다.   예제 입력 1   5 OOXXOXXOOO OOXXOOXXOO OXOXOXOXOXOXOX OOOOOOOOOO OOOOXOOOOXOOOOX   예제 출력 1   10 9 7 55 30       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     char arr[80] = {0,};     int k;     int i;     int add = 0;     int result = 0;      cin&gt;&gt;k;      cin.clear();     cin.ignore(1, '\\n');      for(; k&gt;0; k--) {         i = 0;         result = 0;         add = 0;          cin.getline(arr, 80);          for(int i=0; i&lt;80; i++) {             if(arr[i] == 'O')                 add++;             else if(arr[i] == 0)                 break;             else                 add = 0;              result += add;         }          cout&lt;&lt;result&lt;&lt;'\\n';          while(1) {             if(arr[i] != 0)                 arr[i] = 0;             else                 break;              i++;           }     }          return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-15/",
        "teaser": null
      },{
        "title": "BOJ: 1003 피보나치 함수",
        "excerpt":"문제   다음 소스는 \\(N\\)번째 피보나치 수를 구하는 C++ 함수이다.   int fibonacci(int n) {     if (n == 0) {         printf(\"0\");         return 0;     } else if (n == 1) {         printf(\"1\");         return 1;     } else {         return fibonacci(n-1) + fibonacci(n-2);     } }   fibonacci(3)을 호출하면 다음과 같은 일이 일어난다.      fibonacci(3)은 fibonacci(2)와 fibonacci(1) (첫 번째 호출)을 호출한다.   fibonacci(2)는 fibonacci(1) (두 번째 호출)과 fibonacci(0)을 호출한다.   두 번째 호출한 fibonacci(1)은 1을 출력하고 1을 리턴한다.   fibonacci(0)은 0을 출력하고, 0을 리턴한다.   fibonacci(2)는 fibonacci(1)과 fibonacci(0)의 결과를 얻고, 1을 리턴한다.   첫 번째 호출한 fibonacci(1)은 1을 출력하고, 1을 리턴한다.   fibonacci(3)은 fibonacci(2)와 fibonacci(1)의 결과를 얻고, 2를 리턴한다.   1은 2번 출력되고, 0은 1번 출력된다. \\(N\\)이 주어졌을 때, fibonacci(N) 을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 작성하시오.   입력   첫째 줄에 테스트 케이스의 개수 \\(T\\)가 주어진다.   각 테스트 케이스는 한 줄로 이루어져 있고, \\(N\\)이 주어진다. \\(N\\)은 40보다 작거나 같은 자연수 또는 0이다.   출력   각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다.   예제 입력 1   3 0 1 3   예제 출력 1   1 0 0 1 1 2       코드   #include &lt;iostream&gt;  #define MAX 41  using namespace std;  int fibonacci(int* value, int* zero, int* one, int* check, int n, int t, int k) {     if(n == 0) {          if(check[k] == 0) {             zero[t]++;         }         return 0;     } else if(n == 1) {         if(check[k] == 0) {             one[t]++;         }         return 1;     }          if(value[n] == 0) {         value[n] = fibonacci(value, zero, one, check, n-2, n, k) + fibonacci(value, zero, one, check, n-1, n, k);          if(n != k) {             zero[t] += zero[n];             one[t] += one[n];         }         check[n] = 1;     } else {         if(check[k] == 0) {             zero[t] += zero[n];             one[t] += one[n];         }     }      return value[n]; }   int main(void) {     int value[MAX]={0,};     int zero[MAX]={0,};     int one[MAX]={0,};     int check[MAX]={0, };     int t;     int n;      cin&gt;&gt;t;      for(int i=0; i&lt;t; i++) {         cin&gt;&gt;n;         fibonacci(value, zero, one, check, n, n, n);         cout&lt;&lt;zero[n]&lt;&lt;' '&lt;&lt;one[n]&lt;&lt;'\\n';     }      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-16/",
        "teaser": null
      },{
        "title": "BOJ: 10816 숫자 카드 2",
        "excerpt":"문제   숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 \\(N\\)개를 가지고 있다. 정수 \\(M\\)개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 몇 개 가지고 있는지 구하는 프로그램을 작성하시오.   입력   첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 \\(N(1 \\leq N \\leq 500,000)\\)이 주어진다. 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 숫자 카드에 적혀있는 수는 \\(-10,000,000\\)보다 크거나 같고, \\(10,000,000\\)보다 작거나 같다.   셋째 줄에는 \\(M(1 \\leq M \\leq 500,000)\\)이 주어진다. 넷째 줄에는 상근이가 몇 개 가지고 있는 숫자 카드인지 구해야 할 \\(M\\)개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다. 이 수도 \\(-10,000,000\\)보다 크거나 같고, \\(10,000,000\\)보다 작거나 같다.   출력   첫째 줄에 입력으로 주어진 \\(M\\)개의 수에 대해서, 각 수가 적힌 숫자 카드를 상근이가 몇 개 가지고 있는지를 공백으로 구분해 출력한다.   예제 입력 1   10 6 3 2 10 10 10 -10 -10 7 3 8 10 9 -5 2 3 4 5 -10   예제 출력 1   3 0 0 1 2 0 0 2       코드   #include &lt;iostream&gt; #include &lt;algorithm&gt;  #define MAX 500001  using namespace std;  int main(void) {     ios_base::sync_with_stdio(0);     cin.tie(0);      int arr_n[MAX];     int arr_m[MAX];      int n, m;      cin&gt;&gt;n;          for(int i=0; i&lt;n; i++)         cin&gt;&gt;arr_n[i];      sort(arr_n, arr_n+n);      cin&gt;&gt;m;      for(int i=0; i&lt;m; i++)          cin&gt;&gt;arr_m[i];      for(int i=0; i&lt;m; i++) {         int count = 0;          int* a = upper_bound(arr_n, arr_n+n, arr_m[i]-1);         int* b = upper_bound(arr_n, arr_n+n, arr_m[i]);          for(; a&lt;b; a++)             count++;          cout&lt;&lt;count&lt;&lt;' ';     }              return 0; }    Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-17/",
        "teaser": null
      },{
        "title": "Calculus: Functions and Limits - Continuity #1",
        "excerpt":"Questions   Question 1   Find the limit, if it exists. (If an answer does not exist, enter DNE.)   \\[\\lim_{x \\to \\infty}\\arctan{e^{x}} = \\text{ }?\\]  Answers   Answer 1        ","categories": ["Calculus"],
        "tags": ["Mathematics","Calculus"],
        "url": "http://localhost:4000/calculus/Studying-Calculus-5/",
        "teaser": null
      },{
        "title": "Calculus: Applications of Differentiation - How Derivatives Affect the Shape of a Graph #1",
        "excerpt":"Questions   Question 1   Consider the following. (If an answer does not exist, enter DNE.)   \\[f(x) = 7\\sin{x} + 7\\cos{x}, \\text{ } 0 \\leq x \\leq 2\\pi\\]  (a) Find the interval on which \\(f\\) is increasing. (Enter your answer using interval notation.)   (b) Find the interval on which \\(f\\) is decreasing. (Enter your answer using interval notation.)   Answers   Answer 1     ","categories": ["Calculus"],
        "tags": ["Mathematics","Calculus"],
        "url": "http://localhost:4000/calculus/Studying-Calculus-6/",
        "teaser": null
      },{
        "title": "BOJ: 10815 숫자 카드",
        "excerpt":"문제   숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 \\(N\\)개를 가지고 있다. 정수 \\(M\\)개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 가지고 있는지 아닌지를 구하는 프로그램을 작성하시오.   입력   첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 \\(N(1 \\leq N \\leq 500,000)\\)이 주어진다. 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 숫자 카드에 적혀있는 수는 \\(-10,000,000\\)보다 크거나 같고, \\(10,000,000\\)보다 작거나 같다. 두 숫자 카드에 같은 수가 적혀있는 경우는 없다.   셋째 줄에는 \\(M(1 \\leq M \\leq 500,000)\\)이 주어진다. 넷째 줄에는 상근이가 가지고 있는 숫자 카드인지 아닌지를 구해야 할 \\(M\\)개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다. 이 수도 \\(-10,000,000\\)보다 크거나 같고, \\(10,000,000\\)보다 작거나 같다.   출력   첫째 줄에 입력으로 주어진 \\(M\\)개의 수에 대해서, 각 수가 적힌 숫자 카드를 상근이가 가지고 있으면 1을, 아니면 0을 공백으로 구분해 출력한다.   예제 입력 1   5 6 3 2 10 -10 8 10 9 -5 2 3 4 5 -10   예제 출력 1   1 0 0 1 1 0 0 1       코드   #include &lt;iostream&gt; #include &lt;algorithm&gt;  #define MAX 500001  using namespace std;  int main(void) {     ios_base::sync_with_stdio(0);      cin.tie(0);      int arr_n[MAX];     int arr_m[MAX];     int arr_t[MAX];      int n, m;      cin&gt;&gt;n;      for(int i=0; i&lt;n; i++)         cin&gt;&gt;arr_n[i];      sort(arr_n, arr_n+n);      cin&gt;&gt;m;      for(int i=0; i&lt;m; i++)         cin&gt;&gt;arr_m[i];      for(int i=0; i&lt;m; i++)         if(binary_search(arr_n, arr_n+n, arr_m[i]))             arr_t[i]++;           for(int i=0; i&lt;m; i++)         cout&lt;&lt;arr_t[i]&lt;&lt;' ';              return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-18/",
        "teaser": null
      },{
        "title": "Fluid Mechanics: Test 1-4",
        "excerpt":"질문   내용   어떤 액체의 단위중량이 \\(1.025t/m^{3}\\)이고 부피가 \\(6m^{3}\\)일 때 이 액체의 비중과 무게를 구하시오.   답변   내용     ","categories": ["Fluid Mechanics"],
        "tags": ["Fluid Mechanics"],
        "url": "http://localhost:4000/fluid%20mechanics/Studying-Fluid-1/",
        "teaser": null
      },{
        "title": "Fluid Mechanics: Test 1-5",
        "excerpt":"질문   내용   지하의 기름저장 탱크에 누수가 발생하여 \\(1m\\) 깊이의 물이 스며들었다. 물 위로 기름이 \\(5m\\) 깊이로 떠  있을 때 물과 기름의 접촉면 및 탱크 바닥에서의 압력을 계산하시오. 단, 기름의 비중은 \\(0.7\\), 공기에 의한 압력은 \\(0\\)으로 가정하시오.   답변   내용     ","categories": ["Fluid Mechanics"],
        "tags": ["Fluid Mechanics"],
        "url": "http://localhost:4000/fluid%20mechanics/Studying-Fluid-2/",
        "teaser": null
      },{
        "title": "Fluid Mechanics: Test 1-2",
        "excerpt":"질문   내용   어떤 액체의 점성계수가 \\(0.83 \\times 10^{-3} kg_{0}/m \\cdot s\\)이고, 비중이 \\(0.95\\)일 때, 액체의 동점성 계수(단위는 \\(m^{2}/s\\)로 표시)를 구하시오. 단, 여기서 \\(kg_{0}\\)는 질량을 의미함.   답변   내용     ","categories": ["Fluid Mechanics"],
        "tags": ["Fluid Mechanics"],
        "url": "http://localhost:4000/fluid%20mechanics/Studying-Fluid-3/",
        "teaser": null
      },{
        "title": "Geomatics Engineering: Propagation of Error #1",
        "excerpt":"질문   내용   수평거리 \\(L\\)을 구하기 위해 경사거리(\\(d\\))와 연직각(\\(\\theta\\))을 계산하였다. 수평거리를 계산할 경우 포함된 오차를 구하시오.   \\[d=150\\pm 0.07m\\]  \\[\\theta=30^{\\circ}\\pm2'\\]  답변   내용      ","categories": ["Geomatics Engineering"],
        "tags": ["Geomatics Engineering"],
        "url": "http://localhost:4000/geomatics%20engineering/Studying-Geomatics-3/",
        "teaser": null
      },{
        "title": "Fluid Mechanics: Test 1-1",
        "excerpt":"질문   내용   다음 물리량의 차원을 \\([MLT]\\)계와 \\([FLT]\\)계로 나타내시오.      밀도   압력   체적   전단응력   답변   내용     ","categories": ["Fluid Mechanics"],
        "tags": ["Fluid Mechanics"],
        "url": "http://localhost:4000/fluid%20mechanics/Studying-Fluid-4/",
        "teaser": null
      },{
        "title": "Differential Equation: Test 1-5",
        "excerpt":"질문   내용   \\(x^{y} = y^{x}\\)일 때 \\(y'\\)을 구하시오.   답변   내용     ","categories": ["Differential Equation"],
        "tags": ["Differential Equation"],
        "url": "http://localhost:4000/differential%20equation/Studying-Differential-Equation-1/",
        "teaser": null
      },{
        "title": "Differential Equation: Fourier Series #1",
        "excerpt":"질문   내용   \\(f(x) = \\sin{3x}\\)의 Fourier series (\\(\\displaystyle \\sum_{n=-\\infty}^{\\infty}{c_{n}e^{inx}}\\))를 구하여라. 즉, \\(\\sin{3x} = \\displaystyle \\sum_{n=-\\infty}^{\\infty}{c_{n}e^{inx}}\\)가 되는 \\(c_{n}\\)을 구하여라.   답변   내용     ","categories": ["Differential Equation"],
        "tags": ["Differential Equation"],
        "url": "http://localhost:4000/differential%20equation/Studying-Differential-Equation-2/",
        "teaser": null
      },{
        "title": "Differential Equation: Test 1-3",
        "excerpt":"질문   내용   적분 \\(\\displaystyle \\int x^{2}\\sin{2x}\\,dx\\)를 구하시오.   답변   내용     ","categories": ["Differential Equation"],
        "tags": ["Differential Equation"],
        "url": "http://localhost:4000/differential%20equation/Studying-Differential-Equation-3/",
        "teaser": null
      },{
        "title": "Differential Equation: Test 1-1",
        "excerpt":"질문   내용   다음 함수를 미분하여라.   \\[y=\\frac{x}{(2-3x^{2})}\\]  \\[y=(x^{5}-3x)^{4}\\]  답변   내용     ","categories": ["Differential Equation"],
        "tags": ["Differential Equation"],
        "url": "http://localhost:4000/differential%20equation/Studying-Differential-Equation-4/",
        "teaser": null
      },{
        "title": "Mechanics of Materials: Assignment 4-1",
        "excerpt":"질문   내용   단면적이 \\(250mm^{2}\\)인 황동봉(\\(E = 110GPa\\))에 하중 \\(P_{1} = 15kN, P_{2} = 10kN\\) 및 \\(P_{3} = 8kN\\)이 작용한다. 봉의 구간 별 길이는 \\(a = 2.0m, b = 0.75m, c = 1.2m\\)이다.   봉의 길이 변화를 구하라.   답변   내용     ","categories": ["Mechanics of Materials"],
        "tags": ["Mechanics of Materials"],
        "url": "http://localhost:4000/mechanics%20of%20materials/Studying-Mechanics-of-Materials-1/",
        "teaser": null
      },{
        "title": "Mechanics of Materials: Assignment 4-2",
        "excerpt":"질문   내용   다음 그림을 보고 자유물체도, 부재력, 부재의 최종 처짐량을 유도하여라.   답변   내용     ","categories": ["Mechanics of Materials"],
        "tags": ["Mechanics of Materials"],
        "url": "http://localhost:4000/mechanics%20of%20materials/Studying-Mechanics-of-Materials-2/",
        "teaser": null
      },{
        "title": "BOJ: 10872 팩토리얼",
        "excerpt":"문제   \\(0\\)보다 크거나 같은 정수 \\(N\\)이 주어진다. 이때, \\(N!\\)을 출력하는 프로그램을 작성하시오.   입력   첫째 줄에 정수 \\(N(0 \\leq N \\leq 12)\\)가 주어진다.   출력   첫째 줄에 \\(N!\\)을 출력한다.   예제 입력 1   10   예제 출력 1   3628800   예제 입력 2   0   예제 출력 2   1       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int input;     int result = 1;      cin&gt;&gt;input;      while(input != 0)          result *= (input--);      cout&lt;&lt;result;      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-19/",
        "teaser": null
      },{
        "title": "Structural Mechanics: Assignment 1-1",
        "excerpt":"질문   내용   다음 구조물의 지점반력을 계산하라.      답변   내용     ","categories": ["Structural Mechanics"],
        "tags": ["Structural Mechanics"],
        "url": "http://localhost:4000/structural%20mechanics/Studying-Structural-Mechanics-1/",
        "teaser": null
      },{
        "title": "Structural Mechanics: Assignment 1-2",
        "excerpt":"질문   내용   단면법을 이용하여 “x”로 표시된 트러스 부재에 대한 부재력을 계산하라.      답변   내용     ","categories": ["Structural Mechanics"],
        "tags": ["Structural Mechanics"],
        "url": "http://localhost:4000/structural%20mechanics/Studying-Structural-Mechanics-2/",
        "teaser": null
      },{
        "title": "Structural Mechanics: Assignment 1-3",
        "excerpt":"질문   내용   절점법을 이용하여 트러스의 모든 부재를 계산하라.      답변   내용     ","categories": ["Structural Mechanics"],
        "tags": ["Structural Mechanics"],
        "url": "http://localhost:4000/structural%20mechanics/Studying-Structural-Mechanics-3/",
        "teaser": null
      },{
        "title": "BOJ: 2576 홀수",
        "excerpt":"문제   7개의 자연수가 주어질 때, 이들 중 홀수인 자연수들을 모두 골라 그 합을 구하고, 고른 홀수들 중 최솟값을 찾는 프로그램을 작성하시오.   예를 들어, 7개의 자연수 12, 77, 38, 41, 53, 92, 85가 주어지면 이들 중 홀수는 77, 41, 53, 85이므로 그 합은 \\(77+41+53+85=256\\)이 되고, \\(41 &lt; 53 &lt; 77 &lt; 85\\)이므로 홀수들 중 최솟값은 41이 된다.   입력   입력의 첫째 줄부터 일곱 번째 줄까지 한 줄에 하나의 자연수가 주어진다. 주어지는 자연수는 100보다 작다.   출력   홀수가 존재하지 않는 경우에는 첫째 줄에 -1을 출력한다. 홀수가 존재하는 경우 첫째 줄에 홀수들의 합을 출력하고, 둘째 줄에 홀수들 중 최솟값을 출력한다.   예제 입력 1   12 77 38 41 53 92 85   예제 출력 1   256 41   예제 입력 2   2 4 20 32 6 10 8   예제 출력 2   -1       코드   #include &lt;iostream&gt;  #define OPERATOR_MIN(min, var) (min &gt; var) ? min = var : 0   using namespace std;  int odd_chk(int n) {     if(n % 2 != 0)         return 1;     else         return 0; }  int main(void) {     int arr[7] = {0,};     int arr2[3] = {0,};      for(int i=0; i&lt;7; i++)         cin&gt;&gt;arr[i];      for(int i=0; i&lt;7; i++) {         if(odd_chk(arr[i])) {             if(arr2[2] == 0)                 arr2[1] = arr[i];             else                 OPERATOR_MIN(arr2[1], arr[i]);              arr2[0] += arr[i];             arr2[2]++;         }                  }      if(arr2[2] == 0)         cout&lt;&lt;-1;     else         cout&lt;&lt;arr2[0]&lt;&lt;endl&lt;&lt;arr2[1];              return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-20/",
        "teaser": null
      },{
        "title": "Mechanics of Materials: Assignment 5-1",
        "excerpt":"질문   내용   단면적 \\(A=1,200mm^{2}\\)인 균일단면 봉이 축하중 \\(P=90kN\\)에 의해 압축을 받고 있다.   (a) 각 \\(\\theta=25^{\\circ}\\)로 봉을 절단한 경사단면 \\(pq\\)에 작용하는 응력을 구하라.   (b) \\(\\theta=25^{\\circ}\\)에 대한 완전한 응력상태를 구하고, 이 응력을 적절한 방향으로 회전된 응력요소에 표시하라.   답변   내용     ","categories": ["Mechanics of Materials"],
        "tags": ["Mechanics of Materials"],
        "url": "http://localhost:4000/mechanics%20of%20materials/Studying-Mechanics-of-Materials-3/",
        "teaser": null
      },{
        "title": "Mechanics of Materials: Assignment 5-2",
        "excerpt":"질문   내용   단면적 \\(A=1,200mm^{2}\\)인 균일단면 봉이 축하중 \\(P=90kN\\)에 의해 압축을 받고 있다.   (a) 각 \\(\\theta=180^{\\circ}\\)로 봉을 절단한 경사단면 \\(pq\\)에 작용하는 응력을 구하라.   (b) \\(\\theta=180^{\\circ}\\)에 대한 완전한 응력상태를 구하고, 이 응력을 적절한 방향으로 회전된 응력요소에 표시하라.   답변   내용     ","categories": ["Mechanics of Materials"],
        "tags": ["Mechanics of Materials"],
        "url": "http://localhost:4000/mechanics%20of%20materials/Studying-Mechanics-of-Materials-4/",
        "teaser": null
      },{
        "title": "Mechanics of Materials: Assignment 5-3",
        "excerpt":"질문   내용   단면적 \\(A=1,000mm^{2}\\)인 균일단면 봉이 축하중 \\(P=50kN\\)에 의해 압축을 받고 있다.   (a) 각 \\(\\theta=135^{\\circ}\\)로 봉을 절단한 경사단면 \\(pq\\)에 작용하는 응력을 구하라.   (b) \\(\\theta=135^{\\circ}\\)에 대한 완전한 응력상태를 구하고, 이 응력을 적절한 방향으로 회전된 응력요소에 표시하라.   답변   내용     ","categories": ["Mechanics of Materials"],
        "tags": ["Mechanics of Materials"],
        "url": "http://localhost:4000/mechanics%20of%20materials/Studying-Mechanics-of-Materials-5/",
        "teaser": null
      },{
        "title": "Geomatics Engineering: Propagation of Error #2",
        "excerpt":"질문   내용   줄자를 사용하여 \\(100m\\)의 길이를 측정하였는데 \\(\\pm7mm\\)의 오차가 있었다. 같은 줄자, 같은 방법으로 \\(3000m\\)를 측정하였다면 총 오차는 얼마인가?   답변   내용      ","categories": ["Geomatics Engineering"],
        "tags": ["Geomatics Engineering"],
        "url": "http://localhost:4000/geomatics%20engineering/Studying-Geomatics-4/",
        "teaser": null
      },{
        "title": "BOJ: 10829 이진수 변환",
        "excerpt":"문제   자연수 \\(N\\)이 주어진다. \\(N\\)을 이진수로 바꿔서 출력하는 프로그램을 작성하시오.   입력   첫째 줄에 자연수 \\(N\\)이 주어진다. \\((1 \\leq N \\leq 100,000,000,000,000)\\)   출력   \\(N\\)을 이진수로 바꿔서 출력한다. 이진수는 0으로 시작하면 안 된다.   예제 입력 1   53   예제 출력 1   110101       코드   #include &lt;iostream&gt;  using namespace std;  void n_to_b(long long n) {     if(n &gt; 0 &amp;&amp; n &lt; 100000000000001) {         n_to_b(n/2);         cout&lt;&lt;n%2;     } }  int main(void) {     long long n;      cin&gt;&gt;n;     n_to_b(n);      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-21/",
        "teaser": null
      },{
        "title": "BOJ: 1259 팰린드롬수",
        "excerpt":"문제   어떤 단어를 뒤에서부터 읽어도 똑같다면 그 단어를 팰린드롬이라고 한다. ‘radar’, ‘sees’는 팰린드롬이다.   수도 팰린드롬으로 취급할 수 있다. 수의 숫자들을 뒤에서부터 읽어도 같다면 그 수는 팰린드롬수다. 121, 12421 등은 팰린드롬수다. 123, 1231은 뒤에서부터 읽으면 다르므로 팰린드롬수가 아니다. 또한 10도 팰린드롬수가 아닌데, 앞에 무의미한 0이 올 수 있다면 010이 되어 팰린드롬수로 취급할 수도 있지만, 특별히 이번 문제에서는 무의미한 0이 앞에 올 수 없다고 하자.   입력   입력은 여러 개의 테스트 케이스로 이루어져 있으며, 각 줄마다 1 이상 99999 이하의 정수가 주어진다. 입력의 마지막 줄에는 0이 주어지며, 이 줄은 문제에 포함되지 않는다.   출력   각 줄마다 주어진 수가 팰린드롬수면 ‘yes’, 아니면 ‘no’를 출력한다.   예제 입력 1   121 1231 12421 0   예제 출력 1   yes no yes       코드   #include &lt;iostream&gt; #include &lt;cstring&gt;  using namespace std;  int is_palin(char* s, int len) {     int i=0, j=len-1;      while(i&lt;j &amp;&amp; s[i] == s[j]) {         i++;j--;     }      if((i == j) || (j &lt; i))         return 1;     else         return 0; }   int main(void) {     char s[6];     int check;      while(1) {         int b_check = 0;          cin&gt;&gt;s;          if(int(s[0]) &lt;= 48 || int(s[0]) &gt; 57)             break;          for(int i=1; i&lt;strlen(s); i++) {             if(int(s[i]) &lt; 48 || int(s[i]) &gt; 57) {                 b_check = 1;                 break;             }         }          if(b_check != 0)             break;                  check = is_palin(s, strlen(s));          if(check == 1)             cout&lt;&lt;\"yes\\n\";         else             cout&lt;&lt;\"no\\n\";     }      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-22/",
        "teaser": null
      },{
        "title": "Mechanics of Materials: Assignment 6-1",
        "excerpt":"질문   내용   원형단면은 가진 속이 찬 강철봉의 지름 \\(d=40mm\\), 길이 \\(L=1.4m\\)이고, 봉은 양단에 작용하는 토크 \\(T\\)를 받는다. 이때 다음 주어진 토크를 활용하여 봉에서의 최대 전단응력을 구하여라. (전단 탄성계수 \\(G=80GPa\\))   (1) \\(T=340N\\cdot{m}\\)   답변   내용     ","categories": ["Mechanics of Materials"],
        "tags": ["Mechanics of Materials"],
        "url": "http://localhost:4000/mechanics%20of%20materials/Studying-Mechanics-of-Materials-6/",
        "teaser": null
      },{
        "title": "Mechanics of Materials: Assignment 6-2",
        "excerpt":"질문   내용   A hollow aluminum tube used in a roof structure has an outside diameter \\(d_{2} = 104mm\\) and an inside diameter \\(d_{1} = 82mm\\) (see figure). The tube is \\(2.75m\\) long, and the aluminum has shear modulus \\(G=28GPa\\).   (a) If the tube is twisted in pure torsion by torques acting at the ends, what is the angle of twist (in degrees) when the maximum shear stress is \\(48MPa\\)?   (b) What diameter \\(d\\) is required for a solid shaft (see figure) to resist the same torque with the same maximum stress?   (c) What is the ratio of the weight of the hollow tube to the weight of the solid shaft?      답변   내용     ","categories": ["Mechanics of Materials"],
        "tags": ["Mechanics of Materials"],
        "url": "http://localhost:4000/mechanics%20of%20materials/Studying-Mechanics-of-Materials-7/",
        "teaser": null
      },{
        "title": "Fluid Mechanics: Studying 5-1",
        "excerpt":"질문   내용   그림의 피스톤 \\(A\\)와 \\(B\\)의 직경은 각각 \\(3cm\\) 및 \\(20cm\\)이다. 두 피스톤의 아랫면은 같은 높이에 있고 피스톤 아래의 수압기에는 기름이 차 있다. 그림의 지렛대의 \\(C\\)점에 \\(10kg\\)의 힘을 작용했을 때 평형을 이루었다. 이 수압기는 얼마만한 무게 \\(W\\)를 지지하고 있는 것인가?      답변   내용     ","categories": ["Fluid Mechanics"],
        "tags": ["Fluid Mechanics"],
        "url": "http://localhost:4000/fluid%20mechanics/Studying-Fluid-5/",
        "teaser": null
      },{
        "title": "Mechanics of Materials: Studying 1-1",
        "excerpt":"질문   내용   A circular steel rod of length \\(L\\) and diameter \\(d\\) hangs in a mine shaft and holds an ore bucket of weight \\(W\\) at its lower end.   (a) Obtain a formula for the maximum stress \\(\\sigma_{max}\\) in the rod, taking into account the weight of the rod itself.   (b) Calculate the maximum stress if \\(L=40m, d=8mm\\), and \\(W=1.5kN\\).      답변   내용     ","categories": ["Mechanics of Materials"],
        "tags": ["Mechanics of Materials"],
        "url": "http://localhost:4000/mechanics%20of%20materials/Studying-Mechanics-of-Materials-8/",
        "teaser": null
      },{
        "title": "BOJ: 10988 팰린드롬인지 확인하기",
        "excerpt":"문제   알파벳 소문자로만 이루어진 단어가 주어진다. 이때, 이 단어가 팰린드롬인지 아닌지 확인하는 프로그램을 작성하시오.   팰린드롬이란 앞으로 읽을 때와 거꾸로 읽을 때 똑같은 단어를 말한다.   level, noon은 팰린드롬이고, baekjoon, online, judge는 팰린드롬이 아니다.   입력   첫째 줄에 단어가 주어진다. 단어의 길이는 1보다 크거나 같고, 100보다 작거나 같으며, 알파벳 소문자로만 이루어져 있다.   출력   첫째 줄에 팰린드롬이면 1, 아니면 0을 출력한다.   예제 입력 1   level   예제 출력 1   1   예제 입력 2   baekjoon   예제 출력 2   0       코드   #include &lt;iostream&gt; #include &lt;cstring&gt;  using namespace std;  int is_palin(char* s, int len) {     int i=0, j=len-1;      while(i&lt;j &amp;&amp; s[i] == s[j]) {         i++;j--;     }      if((i == j) || (j &lt; i))         return 1;     else         return 0; }   int main(void) {     char s[101];     int check;      cin&gt;&gt;s;      for(int i=0; i&lt;strlen(s); i++)         if(int(s[i]) &lt; 97 || int(s[i]) &gt; 122)             return 0;          check = is_palin(s, strlen(s));      if(check == 1)         cout&lt;&lt;\"1\";     else         cout&lt;&lt;\"0\";      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-23/",
        "teaser": null
      },{
        "title": "Fluid Mechanics: Studying 5-2",
        "excerpt":"질문   내용   계기압력 \\(5kg/cm^{2}\\)를 절대압력으로 표시하라. 국지대기압은 \\(768mm\\)의 수은주와 같다. 또한 이 절대압력을 \\(bar\\) 단위로 환산하라. 수은의 비중은 \\(13.6\\)이다.   답변   내용     ","categories": ["Fluid Mechanics"],
        "tags": ["Fluid Mechanics"],
        "url": "http://localhost:4000/fluid%20mechanics/Studying-Fluid-6/",
        "teaser": null
      },{
        "title": "BOJ: 2753 윤년",
        "excerpt":"문제   연도가 주어졌을 때, 윤년이면 1, 아니면 0을 출력하는 프로그램을 작성하시오.   윤년은 연도가 4의 배수이면서, 100의 배수가 아닐 때 또는 400의 배수일 때이다.   예를 들어, 2012년은 4의 배수이면서 100의 배수가 아니라서 윤년이다. 1900년은 100의 배수이고 400의 배수는 아니기 때문에 윤년이 아니다. 하지만, 2000년은 400의 배수이기 때문에 윤년이다.   입력   첫째 줄에 연도가 주어진다. 연도는 1보다 크거나 같고, 4000보다 작거나 같은 자연수이다.   출력   첫째 줄에 윤년이면 1, 아니면 0을 출력한다.   예제 입력 1   2000   예제 출력 1   1   예제 입력 2   1999   예제 출력 2   0       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int year;      cin&gt;&gt;year;      if(year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0)         cout&lt;&lt;1;     else         cout&lt;&lt;0;      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-24/",
        "teaser": null
      },{
        "title": "BOJ: 10951 A+B - 4",
        "excerpt":"문제   두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.   입력   입력은 여러 개의 테스트 케이스로 이루어져 있다.   각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. \\((0 &lt; A, B &lt; 10)\\)   출력   각 테스트 케이스마다 A+B를 출력한다.   예제 입력 1   1 1 2 3 3 4 9 8 5 2   예제 출력 1   2 5 7 17 7       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int a, b;      while(1) {         cin&gt;&gt;a&gt;&gt;b;          if(cin.eof() == true) {             break;         }                  if(a &lt;= 0 || b &gt;= 10)             continue;                  cout&lt;&lt;a+b&lt;&lt;endl;     }          return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-25/",
        "teaser": null
      },{
        "title": "BOJ: 10172 개",
        "excerpt":"문제   아래 예제와 같이 개를 출력하시오.   입력   없음.   출력   개를 출력한다.   예제 입력 1      예제 출력 1   |\\_/| |q p|   /} ( 0 )\"\"\"\\ |\"^\"`    | ||_/=\\\\__|       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {      cout&lt;&lt;\"|\\\\_/|\"&lt;&lt;endl;     cout&lt;&lt;\"|q p|   /}\"&lt;&lt;endl;     cout&lt;&lt;\"( 0 )\\\"\\\"\\\"\\\\\"&lt;&lt;endl;     cout&lt;&lt;\"|\\\"^\\\"`    |\"&lt;&lt;endl;     cout&lt;&lt;\"||_/=\\\\\\\\__|\"&lt;&lt;endl;      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-26/",
        "teaser": null
      },{
        "title": "BOJ: 10871 X보다 작은 수",
        "excerpt":"문제   정수 \\(N\\)개로 이루어진 수열 \\(A\\)와 정수 \\(X\\)가 주어진다. 이때, \\(A\\)에서 \\(X\\)보다 작은 수를 모두 출력하는 프로그램을 작성하시오.   입력   첫째 줄에 \\(N\\)과 \\(X\\)가 주어진다. \\((1 \\leq N, X \\leq 10,000)\\)   둘째 줄에 수열 \\(A\\)를 이루는 정수 \\(N\\)개가 주어진다. 주어지는 정수는 모두 1보다 크거나 같고, 10,000보다 작거나 같은 정수이다.   출력   \\(X\\)보다 작은 수를 입력받은 순서대로 공백으로 구분해 출력한다. \\(X\\)보다 작은 수는 적어도 하나 존재한다.   예제 입력 1   10 5 1 10 4 9 2 3 8 5 7 6   예제 출력 1   1 4 2 3       코드   #include &lt;iostream&gt;  #define MAX 10000  using namespace std;  int main(void) {     int n, x;     int arr[MAX] = {0,};      cin&gt;&gt;n&gt;&gt;x;      for(int i=0; i&lt;n; i++)         cin&gt;&gt;arr[i];          for(int i=0; i&lt;n; i++)         if(arr[i] &lt; x)             cout&lt;&lt;arr[i]&lt;&lt;' ';      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-27/",
        "teaser": null
      },{
        "title": "BOJ: 10998 AxB",
        "excerpt":"문제   두 정수 \\(A\\)와 \\(B\\)를 입력받은 다음, \\(A \\times B\\)를 출력하는 프로그램을 작성하시오.   입력   첫째 줄에 \\(A\\)와 \\(B\\)가 주어진다. \\((0 &lt; A, B &lt; 10)\\)   출력   첫째 줄에 \\(A \\times B\\)를 출력한다.   예제 입력 1   1 2   예제 출력 1   2   예제 입력 2   3 4   에제 출력 2   12       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int a, b;      cin&gt;&gt;a&gt;&gt;b;      cout&lt;&lt;a*b;      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-28/",
        "teaser": null
      },{
        "title": "BOJ: 11022 A+B - 8",
        "excerpt":"문제   두 정수 \\(A\\)와 \\(B\\)를 입력받은 다음, \\(A + B\\)를 출력하는 프로그램을 작성하시오.   입력   첫째 줄에 테스트 케이스의 개수 \\(T\\)가 주어진다.   각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 \\(A\\)와 \\(B\\)가 주어진다. \\((0 &lt; A, B &lt; 10)\\)   출력   각 테스트 케이스마다 “Case #x: \\(A + B = C\\)” 형식으로 출력한다.   x는 테스트 케이스 번호이고 1부터 시작하며, \\(C\\)는 \\(A + B\\)이다.   예제 입력 1   5 1 1 2 3 3 4 9 8 5 2   예제 출력 1   Case #1: 1 + 1 = 2 Case #2: 2 + 3 = 5 Case #3: 3 + 4 = 7 Case #4: 9 + 8 = 17 Case #5: 5 + 2 = 7       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int n;     int a, b;      cin&gt;&gt;n;      for(int i=0; i&lt;n; i++) {         cin&gt;&gt;a&gt;&gt;b;          if(a &lt;= 0 || b &gt;= 10) {             i--;             continue;         }                  cout&lt;&lt;\"Case #\"&lt;&lt;i+1&lt;&lt;':'&lt;&lt;' '&lt;&lt;a&lt;&lt;' '&lt;&lt;'+'&lt;&lt;' '&lt;&lt;b&lt;&lt;' '&lt;&lt;'='&lt;&lt;' '&lt;&lt;a+b&lt;&lt;endl;     }      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-29/",
        "teaser": null
      },{
        "title": "MFC & Algorithms: Snowflake",
        "excerpt":"내용   Nontail Recursion으로 Snowflake를 구현하였으며, 대화상자 위에 뷰(vonKochView)를 올려 해당 뷰에 Snowflake가 그려지게끔 했다.   아래는 Visual Studio에서 기본적으로 생성되는 MFC 프로젝트 내의 파일 중 수정한 부분들과 Snowflake를 구현한 코드이며, 전체 솔루션 파일의 다운로드는 최하단에 별도의 링크로 기재해두었으니 결과물을 확인해보고 싶다면 참고하길 바란다.   코드   vonKoch.h   #pragma once  #define _USE_MATH_DEFINES  #include &lt;afxwin.h&gt; #include &lt;math.h&gt;  class vonKoch {     public:     vonKoch(int, int, CDC*);     void snowflake();      private:     double side, angle;     int level;     CPoint currPt, pt;     CDC* pen;      void right(double x) {         angle += x;     }      void left(double x) {         angle -= x;     }      void drawFourLines(double side, int level); };  vonKoch::vonKoch(int s, int lvl, CDC* pDC) {     pen = pDC;     currPt.x = 200;     currPt.y = 100;     pen-&gt;MoveTo(currPt);     angle = 0.0;     side = s;     level = lvl; }  void vonKoch::drawFourLines(double side, int level) {     if(level == 0) {         pt.x = int(cos(angle*M_PI / 180)*side) + currPt.x;         pt.y = int(sin(angle*M_PI / 180)*side) + currPt.y;         pen-&gt;LineTo(pt);         currPt.x = pt.x;         currPt.y = pt.y;     } else {         drawFourLines(side / 3, level - 1);         left(60);         drawFourLines(side / 3, level - 1);         right(120);         drawFourLines(side / 3, level - 1);         left(60);         drawFourLines(side / 3, level - 1);     } }  void vonKoch::snowflake() {     for(int i=1; i&lt;=3; i++) {         drawFourLines(side, level);         right(120);     }      drawFourLines(side, level); }   vonKochView.h   #pragma once  class vonKochView : public CView {     DECLARE_DYNCREATE(vonKochView)      public:     vonKochView();      // 기존 protected -&gt; public     virtual ~vonKochView();     // 기존 protected -&gt; public      virtual void OnDraw(CDC* pDC);     #ifdef _DEBUG     virtual void AssertValid() const;     #ifndef _WIN32_WCE     virtual void Dump(CDumpContext&amp; dc) const;     #endif     #endif      protected:     DECLARE_MESSAGE_MAP() };   vonKochView.cpp   #include \"pch.h\" #include \"MFCApplication8.h\" #include \"vonKochView.h\" #include \"vonKoch.h\"        // 추가  IMPLEMENT_DYNCREATE(vonKochView, CView)  vonKochView::vonKochView() {  }  vonKochView::~vonKochView() {  }  BEGIN_MESSAGE_MAP(vonKochView, CView) END_MESSAGE_MAP()  void vonKochView::OnDraw(CDC* pDC) {     CDocument* pDoc = GetDocument();      vonKoch(200, 4, pDC).snowflake();   // 추가 }  #ifdef _DEBUG void vonKochView::AssertValid() const {     CView::AssertValid(); }  #ifndef _WIN32_WCE void vonKochView::Dump(CDumpContext&amp; dc) const {     CView::Dump(dc); } #endif #endif   MFCApplication8Dlg.h   #pragma once  #include \"vonKochView.h\"  class CMFCApplication8Dlg : public CDialog {     public:     vonKochView* m_vonKochView;         // 추가     CMFCApplication8Dlg(CWnd* pParent = nullptr);      #ifdef AFX_DESIGN_TIME     enum { IDD = IDD_MFCAPPLICATION8_DIALOG };     #endif      protected:     virtual void DoDataExchange(CDataExchange* pDX);      protected:     HICON m_hIcon;      virtual BOOL OnInitDialog();     afx_msg void OnSysCommand(UINT nID, LPARAM lParam);     afx_msg void OnPaint();     afx_msg void OnDestroy();       // 추가     afx_msg HCURSOR OnQueryDragIcon();     DECLARE_MESSAGE_MAP() };   MFCApplication8Dlg.cpp   #include \"pch.h\" #include \"framework.h\" #include \"MFCApplication8.h\" #include \"MFCApplication8Dlg.h\" #include \"afxdialogex.h\"  #ifdef _DEBUG #define new DEBUG_NEW #endif  class CAboutDlg : public CDialogEx {     public:     CAboutDlg();      #ifdef AFX_DESIGN_TIME         enum { IDD = IDD_ABOUTBOX };     #endif      protected:     virtual void DoDataExchange(CDataExchange* pDX);      protected:     DECLARE_MESSAGE_MAP(); };  CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX) {  }  void CAboutDlg::DoDataExchange(CDataExchange* pDX) {     CDialogEx::DoDataExchange(pDX); }  BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx) END_MESSAGE_MAP()  CMFCApplication8Dlg::CMFCApplication8Dlg(CWnd* pParent) : CDialog(IDD_MFCAPPLICATION8_DIALOG, pParent) {     m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME); }  void CMFCApplication8Dlg::DoDataExchange(CDataExchange* pDX) {     CDialog::DoDataExchange(pDX); }  BEGIN_MESSAGE_MAP(CMFCApplication8Dlg, CDialog)     ON_WM_SYSCOMMAND()     ON_WM_PAINT()     ON_WM_QUERYDRAGICON() END_MESSAGE_MAP()  BOOL CMFCApplication8Dlg::OnInitDialog() {     CDialog::OnInitDialog();      m_vonKochView = new vonKochView;        // 추가     m_vonKochView-&gt;Create(NULL, L\"\", WS_CHILD|WS_BORDER|WS_VISIBLE, CRect(10, 10, 550, 340), this, 50001);          // 추가     m_vonKochView-&gt;OnInitialUpdate();       // 추가      ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX);     ASSERT(IDM_ABOUTBOX &lt; 0xF000);      CMenu* pSysMenu = GetSystemMenu(FALSE);      if(pSysMenu != nullptr) {         BOOL bNameValid;         CString strAboutMenu;         bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);         ASSERT(bNameValid);          if(!strAboutMenu.IsEmpty()) {             pSysMenu-&gt;AppendMenu(MF_SEPARATOR);             pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);         }     }      SetIcon(m_hIcon, TRUE);     SetIcon(m_hIcon, FALSE);      return TRUE; }  void CMFCApplication8Dlg::OnSysCommand(UINT nID, LPARAM lParam) {     if((nID &amp; 0xFFF0) == IDM_ABOUTBOX) {         CAboutDlg dlgAbout;         dlgAbout.DoModal();     } else {         CDialog::OnSysCommand(nID, lParam);     } }  void CMFCApplication8Dlg::OnPaint() {     if(IsIconic()) {         CPaintDC dc(this);          SendMessage(WM_ICONERASEBKGND, reinterpret_cast&lt;WPARAM&gt;(dc.GetSafeHdc()), 0);          int cxIcon = GetSystemMetrics(SM_CXICON);         int cyIcon = GetSystemMetrics(SM_CYICON);         CRect rect;         GetClientRect(&amp;rect);         int x = (rect.Width() - cxIcon + 1) / 2;         int y = (rect.Height() - cyIcon + 1) / 2;          dc.DrawIcon(x, y, m_hIcon);     } else {         CDialog::OnPaint();     } }  // 추가 void CMFCApplication8Dlg::OnDestroy() {     delete m_vonKochView; }  HCURSOR CMFCApplication8Dlg::OnQueryDragIcon() {     return static_cast&lt;HCURSOR&gt;(m_hIcon); }   결과   level == 1      level == 2      level == 3      level == 4      참고   다운로드   다운로드   ","categories": ["MFC","Algorithms"],
        "tags": ["MFC","Algorithms","Programming","Coding"],
        "url": "http://localhost:4000/mfc/algorithms/Application_MFC-2/",
        "teaser": null
      },{
        "title": "Linear Algebra & C++: The Jacobi Method",
        "excerpt":"Concepts   The Jacobi Method   For each \\(k \\geq 1\\), generate the components \\(x_{i}^{(k)}\\) of \\(x^{(k)}\\) from \\(x^{(k-1)}\\) by   \\[x_{i}^{(k)} = \\frac{1}{a_{ii}}\\left[\\sum_{j=1, \\\\ j \\neq i}^{n} (-a_{ij}x_{j}^{(k-1)}) + b_{i} \\right]\\text{,   for } i=1,2, \\cdots, n\\]      Questions   Question 1   Solve the system of equations using Jacobi Iteration Method.   \\[\\begin{cases} 5x-2y+3z=-1 \\\\ -3x+9y+z=2 \\\\ 2x-y-7z=3 \\end{cases}\\]  Answers   Answer 1   #include &lt;iostream&gt; #include &lt;math.h&gt;  #define f1(x, y, z) (-1+2*y-3*z)/5 #define f2(x, y, z) (2+3*x-z)/9 #define f3(x, y, z) (-3+2*x-y)/7  using namespace std;  int main(void) {     double error;     double xi=0, yi=0, zi=0;     double xf, yf, zf;     double error1, error2, error3;     int count = 1;      cout&lt;&lt;\"Allowable Error: \";     cin&gt;&gt;error;      do {         xf = f1(xi, yi, zi); yf = f2(xi, yi, zi); zf = f3(xi, yi, zi);         cout&lt;&lt;count++&lt;&lt;' '&lt;&lt;xf&lt;&lt;' '&lt;&lt;yf&lt;&lt;' '&lt;&lt;zf&lt;&lt;endl;          error1 = fabs(xi - xf); error2 = fabs(yi - yf); error3 = fabs(zi - zf);         xi = xf; yi = yf; zi = zf;     }while(error1 &gt; error &amp;&amp; error2 &gt; error &amp;&amp; error3 &gt; error);      cout&lt;&lt;\"\\n Solution: x = \"&lt;&lt;xf&lt;&lt;\" y = \"&lt;&lt;yf&lt;&lt;\" z = \"&lt;&lt;zf&lt;&lt;endl;      return 0; }   Results   Result 1     ","categories": ["Linear Algebra","Cpp"],
        "tags": ["Mathematics","Programming","Linear Algebra","C++"],
        "url": "http://localhost:4000/linear%20algebra/cpp/Studying_Linear-6/",
        "teaser": null
      },{
        "title": "BOJ: 1001 A-B",
        "excerpt":"문제   두 정수 \\(A\\)와 \\(B\\)를 입력받은 다음, \\(A - B\\)를 출력하는 프로그램을 작성하시오.   입력   첫째 줄에 \\(A\\)와 \\(B\\)가 주어진다. \\((0 &lt; A, B &lt; 10)\\)   출력   첫째 줄에 \\(A - B\\)를 출력한다.   예제 입력 1   3 2   예제 출력 1   1       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int a, b;      cin&gt;&gt;a&gt;&gt;b;      cout&lt;&lt;a-b;      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-30/",
        "teaser": null
      },{
        "title": "BOJ: 2750 수 정렬하기",
        "excerpt":"문제   \\(N\\)개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.   입력   첫째 줄에 수의 개수 \\(N(1 \\leq N \\leq 1,000)\\)이 주어진다. 둘째 줄부터 \\(N\\)개의 줄에는 숫자가 주어진다. 이 수는 절댓값이 \\(1,000\\)보다 작거나 같은 정수이다. 수는 중복되지 않는다.   출력   첫째 줄부터 \\(N\\)개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.   예제 입력 1   5 5 2 3 4 1   예제 출력 1   1 2 3 4 5       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int arr[1000];     int n;     int temp;      cin&gt;&gt;n;      for(int i=0; i&lt;n; i++)         cin&gt;&gt;arr[i];      for(int i=0; i&lt;n; i++)          for(int j=i; j&lt;n; j++)              if(arr[i] &gt; arr[j]) {                 temp = arr[i];                 arr[i] = arr[j];                 arr[j] = temp;             }      for(int i=0; i&lt;n; i++)         cout&lt;&lt;arr[i]&lt;&lt;endl;      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-31/",
        "teaser": null
      },{
        "title": "BOJ: 8393 합",
        "excerpt":"문제   \\(n\\)이 주어졌을 때, 1부터 \\(n\\)까지 합을 구하는 프로그램을 작성하시오.   입력   첫째 줄에 \\(n(1 \\leq N \\leq 10,000)\\)이 주어진다.   출력   1부터 \\(n\\)까지 합을 출력한다.   예제 입력 1   3   예제 출력 1   6       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int n;     int result = 0;      cin&gt;&gt;n;      for(int i=1; i&lt;=n; i++)         result += i;      cout&lt;&lt;result;      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-32/",
        "teaser": null
      },{
        "title": "BOJ: 2439 별 찍기 - 2",
        "excerpt":"문제   첫째 줄에는 별 1개, 둘째 줄에는 별 2개, \\(N\\)번째 줄에는 별 \\(N\\)개를 찍는 문제   하지만, 오른쪽을 기준으로 정렬한 별(예제 참고)을 출력하시오.   입력   첫째 줄에 \\(N(1 \\leq N \\leq 100)\\)이 주어진다.   출력   첫째 줄부터 \\(N\\)번째 줄까지 차례대로 별을 출력한다.   예제 입력 1   5   예제 출력 1       *    **   ***  **** *****       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int n;     int k;      cin&gt;&gt;n;      k = n;      for(int i=0; i&lt;n; i++) {         for(int j=k-1; j&gt;0; j--)             cout&lt;&lt;' ';                  for(int j=0; j&lt;=i; j++)             cout&lt;&lt;'*';          cout&lt;&lt;endl;         k--;     }      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-33/",
        "teaser": null
      },{
        "title": "BOJ: 10171 고양이",
        "excerpt":"문제   아래 예제와 같이 고양이를 출력하시오.   입력   없음.   출력   고양이를 출력한다.   예제 입력 1      예제 출력 1   \\    /\\  )  ( ') (  /  )  \\(__)|       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     cout&lt;&lt;\"\\\\    /\\\\\"&lt;&lt;'\\n';     cout&lt;&lt;\" )  ( ')\"&lt;&lt;'\\n';     cout&lt;&lt;\"(  /  )\"&lt;&lt;'\\n';     cout&lt;&lt;\" \\\\(__)|\";      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-34/",
        "teaser": null
      },{
        "title": "BOJ: 10818 최소, 최대",
        "excerpt":"문제   \\(N\\)개의 정수가 주어진다. 이때, 최솟값과 최댓값을 구하는 프로그램을 작성하시오.   입력   첫째 줄에 정수의 개수 \\(N(1 \\leq N \\leq 1,000,000)\\)이 주어진다. 둘째 줄에는 \\(N\\)개의 정수를 공백으로 구분해서 주어진다. 모든 정수는 \\(-1,000,000\\)보다 크거나 같고, \\(1,000,000\\)보다 작거나 같은 정수이다.   출력   첫째 줄에 주어진 정수 \\(N\\)개의 최솟값과 최댓값을 공백으로 구분해 출력한다.   예제 입력 1   5 20 10 35 30 7   예제 출력 1   7 35       코드   #include &lt;iostream&gt; #define MAX 1000000  using namespace std;  int main(void) {     int i, j;     int min, max;     int arr[MAX];      cin&gt;&gt;i;      for(int j=0; j&lt;i; j++) {         cin&gt;&gt;arr[j];     }      min = arr[0];     max = arr[0];      for(int j=1; j&lt;i; j++) {         if(min &gt; arr[j])             min = arr[j];                  if(max &lt; arr[j])             max = arr[j];     }      cout&lt;&lt;min&lt;&lt;' '&lt;&lt;max;              return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-35/",
        "teaser": null
      },{
        "title": "BOJ: 2739 구구단",
        "excerpt":"문제   \\(N\\)을 입력받은 뒤, 구구단 \\(N\\)단을 출력하는 프로그램을 작성하시오. 출력 형식에 맞춰서 출력하면 된다.   입력   첫째 줄에 \\(N\\)이 주어진다. \\(N\\)은 1보다 크거나 같고, 9보다 작거나 같다.   출력   출력형식과 같게 \\(N*1\\)부터 \\(N*9\\)까지 출력한다.   예제 입력 1   2   예제 출력 1   2 * 1 = 2 2 * 2 = 4 2 * 3 = 6 2 * 4 = 8 2 * 5 = 10 2 * 6 = 12 2 * 7 = 14 2 * 8 = 16 2 * 9 = 18       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int n;      cin&gt;&gt;n;      if(n &gt;= 1 &amp;&amp; n &lt;= 9)          for(int i=1; i&lt;10; i++)             cout&lt;&lt;n&lt;&lt;' '&lt;&lt;'*'&lt;&lt;' '&lt;&lt;i&lt;&lt;' '&lt;&lt;'='&lt;&lt;' '&lt;&lt;n*i&lt;&lt;endl;      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-36/",
        "teaser": null
      },{
        "title": "BOJ: 4101 크냐?",
        "excerpt":"문제   두 양의 정수가 주어졌을 때, 첫 번째 수가 두 번째 수보다 큰지 구하는 프로그램을 작성하시오.   입력   입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있으며, 두 정수가 주어진다. 두 수는 백만보다 작거나 같은 양의 정수이다. 입력의 마지막 줄에는 0이 두 개 주어진다.   출력   각 테스트 케이스마다, 첫 번째 수가 두 번째 수보다 크면 Yes를, 아니면 No를 한 줄에 하나씩 출력한다.   예제 입력 1   1 19 4 4 23 14 0 0   예제 출력 1   No No Yes       코드   #include &lt;iostream&gt;  using namespace std;  int big_chk(int i, int j) {     if(i&gt;j)         return 1;     else         return 0; }  int main(void) {     int i, j;      while(1) {         cin&gt;&gt;i&gt;&gt;j;          if(i == 0 &amp;&amp; j == 0)             break;          if(big_chk(i, j))             cout&lt;&lt;\"Yes\"&lt;&lt;endl;         else             cout&lt;&lt;\"No\"&lt;&lt;endl;              }      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-37/",
        "teaser": null
      },{
        "title": "Mechanics of Materials: Assignment 9-1",
        "excerpt":"질문   내용   Calculate the shear force \\(V\\) and bending moment \\(M\\) at a cross section just to the left of the \\(7.0kN\\) load acting on the simple beam \\(AB\\) shown in the figure.      답변   내용     ","categories": ["Mechanics of Materials"],
        "tags": ["Mechanics of Materials"],
        "url": "http://localhost:4000/mechanics%20of%20materials/Studying-Mechanics-of-Materials-9/",
        "teaser": null
      },{
        "title": "Mechanics of Materials: Assignment 9-2",
        "excerpt":"질문   내용   Calculate the shear force \\(V\\) and bending moment \\(M\\) at a cross section located \\(0.5m\\) from the fixed support of the cantilever beam \\(AB\\) shown in the figure.      답변   내용     ","categories": ["Mechanics of Materials"],
        "tags": ["Mechanics of Materials"],
        "url": "http://localhost:4000/mechanics%20of%20materials/Studying-Mechanics-of-Materials-10/",
        "teaser": null
      },{
        "title": "Mechanics of Materials: Assignment 9-3",
        "excerpt":"질문   내용   A cantilever beam \\(AB\\) supports a couple and a concentrated load, as shown in the figure. Draw the shear-force and bending-moment diagrams for this beam.      답변   내용        ","categories": ["Mechanics of Materials"],
        "tags": ["Mechanics of Materials"],
        "url": "http://localhost:4000/mechanics%20of%20materials/Studying-Mechanics-of-Materials-11/",
        "teaser": null
      },{
        "title": "BOJ: 10773 제로",
        "excerpt":"문제   나코더 기장 재민이는 동아리 회식을 준비하기 위해서 장부를 관리하는 중이다.   재현이는 재민이를 도와서 돈을 관리하는 중인데, 애석하게도 항상 정신없는 재현이는 돈을 실수로 잘못 부르는 사고를 치기 일쑤였다.   재현이는 잘못된 수를 부를 때마다 0을 외쳐서, 가장 최근에 재민이가 쓴 수를 지우게 시킨다.   재민이는 이렇게 모든 수를 받아 적은 후 그 수의 합을 알고 싶어 한다. 재민이를 도와주자!   입력   첫 번째 줄에 정수 \\(K\\)가 주어진다. \\((1 \\leq K \\leq 100,000)\\)   이후 \\(K\\)개의 줄에 정수가 1개씩 주어진다. 정수는 \\(0\\)에서 \\(1,000,000\\) 사이의 값을 가지며, 정수가 “0”일 경우에는 가장 최근에 쓴 수를 지우고, 아닐 경우 해당 수를 쓴다.   정수가 “0”일 경우에 지울 수 있는 수가 있음을 보장할 수 있다.   출력   재민이가 최종적으로 적어낸 수의 합을 출력한다. 최종적으로 적어낸 수의 합은 \\(2^{31}-1\\)보다 작거나 같은 정수이다.   예제 입력 1   4 3 0 4 0   예제 출력 1   0   예제 입력 2   10 1 3 5 4 0 0 7 0 0 6   예제 출력 2   7   힌트   예제 2의 경우를 시뮬레이션 해보면,      [1]   [1,3]   [1,3,5]   [1,3,5,4]   [1,3,5] (0을 불렀기 때문에 최근의 수를 지운다)   [1,3] (0을 불렀기 때문에 그 다음 최근의 수를 지운다)   [1,3,7]   [1,3] (0을 불렀기 때문에 최근의 수를 지운다)   [1] (0을 불렀기 때문에 그 다음 최근의 수를 지운다)   [1,6]   합은 7이다.       코드   #include &lt;bits/stdc++.h&gt;  using namespace std;  int main(void) {     vector&lt;int&gt; v;      int n;     int sum = 0;      cin&gt;&gt;n;      for(int i=0; i&lt;n; i++) {         int k;          cin&gt;&gt;k;          if(k == 0) {             sum -= v.back();             v.pop_back();             continue;         }          v.push_back(k);         sum += k;     }      cout&lt;&lt;sum;      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-38/",
        "teaser": null
      },{
        "title": "BOJ: 1874 스택 수열",
        "excerpt":"문제   스택(stack)은 기본적인 자료구조 중 하나로, 컴퓨터 프로그램을 작성할 때 자주 이용되는 개념이다. 스택은 자료를 넣는 (push) 입구와 자료를 뽑는 (pop) 입구가 같아 제일 나중에 들어간 자료가 제일 먼저 나오는 (LIFO, Last In First Out) 특성을 가지고 있다.   1부터 n까지의 수를 스택에 넣었다가 뽑아 늘어놓음으로써, 하나의 수열을 만들 수 있다. 이때, 스택에 push하는 순서는 반드시 오름차순을 지키도록 한다고 하자. 임의의 수열이 주어졌을 때 스택을 이용해 그 수열을 만들 수 있는지 없는지, 있다면 어떤 순서로 push와 pop 연산을 수행해야 하는지를 알아낼 수 있다. 이를 계산하는 프로그램을 작성하라.   입력   첫 줄에 \\(n (1 \\leq n \\leq 100,000)\\)이 주어진다. 둘째 줄부터 \\(n\\)개의 줄에는 수열을 이루는 1이상 n이하의 정수가 하나씩 순서대로 주어진다. 물론 같은 정수가 두 번 나오는 일은 없다.   출력   입력된 수열을 만들기 위해 필요한 연산을 한 줄에 한 개씩 출력한다. push 연산은 +로, pop 연산은 -로 표현하도록 한다. 불가능한 경우 NO를 출력한다.   예제 입력 1   8 4 3 6 8 7 5 2 1   예제 출력 1   + + + + - - + + - + + - - - - -   예제 입력 2   5 1 2 5 3 4   예제 출력 2   NO   힌트   1부터 n까지의 수에 대해 차례로 [push, push, push, push, pop, pop, push, push, pop, push, push, pop, pop, pop, pop, pop] 연산을 수행하면 수열 [4, 3, 6, 8, 7, 5, 2, 1]을 얻을 수 있다.       코드   #include &lt;bits/stdc++.h&gt;  using namespace std;  int main(void) {     vector&lt;int&gt; v, t;     vector&lt;char&gt; e;     vector&lt;char&gt;::iterator iter;      int n;     int b = 0, r = 0;      cin&gt;&gt;n;      for(int i=0; i&lt;n; i++) {         int k;         cin&gt;&gt;k;          v.push_back(k);     }          while(r != n) {         e.push_back('+');         t.push_back(++r);          while((b &lt; n) &amp;&amp; (v[b] == t.back())) {             e.push_back('-');             t.pop_back();             b++;         }     }      if(b == n)         for(iter = e.begin(); iter != e.end(); iter++)              cout&lt;&lt;(*iter)&lt;&lt;'\\n';     else         cout&lt;&lt;\"NO\";      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-39/",
        "teaser": null
      },{
        "title": "BOJ: 2470 두 용액",
        "excerpt":"문제   KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다. 산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 알칼리성 용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다.   같은 양의 두 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다. 이 연구소에서는 같은 양의 두 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다.   예를 들어, 주어진 용액들의 특성값이 [-2, 4, -99, -1, 98]인 경우에는 특성값이 -99인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, 이 용액이 특성값이 0에 가장 가까운 용액이다. 참고로, 두 종류의 알칼리성 용액만으로나 혹은 두 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다.   산성 용액과 알칼리성 용액의 특성값이 주어졌을 때, 이 중 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액을 찾는 프로그램을 작성하시오.   입력   첫째 줄에는 전체 용액의 수 \\(N\\)이 입력된다. \\(N\\)은 2 이상 100,000 이하이다. 둘째 줄에는 용액의 특성값을 나타내는 \\(N\\)개의 정수가 빈칸을 사이에 두고 주어진다. 이 수들은 모두 -1,000,000,000 이상 1,000,000,000 이하이다. \\(N\\)개의 용액들의 특성값은 모두 다르고, 산성 용액만으로나 알칼리성 용액만으로 입력이 주어지는 경우도 있을 수 있다.   출력   첫째 줄에 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액의 특성값을 출력한다. 출력해야 하는 두 용액은 특성값의 오름차순으로 출력한다. 특성값이 0에 가장 가까운 용액을 만들어내는 경우가 두 개 이상일 경우에는 그 중 아무것이나 하나를 출력한다.   예제 입력 1   5 -2 4 -99 -1 98   예제 출력 1   -99 98       코드   #include &lt;bits/stdc++.h&gt;  using namespace std;  void two_value(vector&lt;int&gt; v, int n) {     int x=0, y=0;     int i=0;     int j=n-1;     int d=INT_MAX;      sort(v.begin(), v.end());      while(i&lt;j) {         if(abs(v[i] + v[j] - 0) &lt; d) {             x = i;             y = j;             d = abs(v[i] + v[j] - 0);         }          if(v[i] + v[j] &lt; 0)             i++;         else             j--;     }      cout&lt;&lt;v[x]&lt;&lt;' '&lt;&lt;v[y]; }   int main(void) {     vector&lt;int&gt; v;      int n;      cin&gt;&gt;n;      for(int i=0; i&lt;n; i++) {         int k;          cin&gt;&gt;k;           v.push_back(k);     }      two_value(v, n);          return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-40/",
        "teaser": null
      },{
        "title": "BOJ: 11279 최대 힙",
        "excerpt":"문제   널리 잘 알려진 자료구조 중 최대 힙이 있다. 최대 힙을 이용하여 다음과 같은 연산을 지원하는 프로그램을 작성하시오.      배열에 자연수 \\(x\\)를 넣는다.   배열에서 가장 큰 값을 출력하고, 그 값을 배열에서 제거한다.   프로그램은 처음에 비어있는 배열에서 시작하게 된다.   입력   첫째 줄에 연산의 개수 \\(N(1 \\leq N \\leq 100,000)\\)이 주어진다. 다음 \\(N\\)개의 줄에는 연산에 대한 정보를 나타내는 정수 \\(x\\)가 주어진다. 만약 \\(x\\)가 자연수라면 배열에 \\(x\\)라는 값을 넣는(추가하는) 연산이고, \\(x\\)가 0이라면 배열에서 가장 큰 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 입력되는 자연수는 \\(2^{31}\\)보다 작다.   출력   입력에서 0이 주어진 회수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 가장 큰 값을 출력하라고 한 경우에는 0을 출력하면 된다.   예제 입력 1   13 0 1 2 0 0 3 2 1 0 0 0 0 0   예제 출력 1   0 2 1 3 2 1 0 0       코드   #include &lt;bits/stdc++.h&gt;  using namespace std;  void small(priority_queue&lt;int&gt; *v) {     if(v-&gt;size() == 0)         printf(\"0\\n\");     else {         printf(\"%d\\n\", v-&gt;top());         v-&gt;pop();     } }  int main(void) {     priority_queue&lt;int&gt; v;     int n;      scanf(\"%d\", &amp;n);      for(int i=0; i&lt;n; i++) {         int k;          scanf(\"%d\", &amp;k);          if(k &gt; 0)             v.push(k);         else             small(&amp;v);     }      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-41/",
        "teaser": null
      },{
        "title": "BOJ: 1927 최소 힙",
        "excerpt":"문제   널리 잘 알려진 자료구조 중 최소 힙이 있다. 최소 힙을 이용하여 다음과 같은 연산을 지원하는 프로그램을 작성하시오.      배열에 자연수 \\(x\\)를 넣는다.   배열에서 가장 작은 값을 출력하고, 그 값을 배열에서 제거한다.   프로그램은 처음에 비어있는 배열에서 시작하게 된다.   입력   첫째 줄에 연산의 개수 \\(N(1 \\leq N \\leq 100,000)\\)이 주어진다. 다음 \\(N\\)개의 줄에는 연산에 대한 정보를 나타내는 정수 \\(x\\)가 주어진다. 만약 \\(x\\)가 자연수라면 배열에 \\(x\\)라는 값을 넣는(추가하는) 연산이고, \\(x\\)가 0이라면 배열에서 가장 작은 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 입력되는 자연수는 \\(2^{31}\\)보다 작다.   출력   입력에서 0이 주어진 회수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 가장 큰 값을 출력하라고 한 경우에는 0을 출력하면 된다.   예제 입력 1   9 0 12345678 1 2 0 0 0 0 32   예제 출력 1   0 1 2 12345678 0       코드   #include &lt;bits/stdc++.h&gt;  using namespace std;  void small(priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; *v) {     if(v-&gt;size() == 0)         printf(\"0\\n\");     else {         printf(\"%d\\n\", v-&gt;top());         v-&gt;pop();     } }  int main(void) {     priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; v;     int n;      scanf(\"%d\", &amp;n);      for(int i=0; i&lt;n; i++) {         int k;          scanf(\"%d\", &amp;k);          if(k &gt; 0)             v.push(k);         else             small(&amp;v);     }      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-42/",
        "teaser": null
      },{
        "title": "Fluid Mechanics: Studying 10-1",
        "excerpt":"질문   내용   다음과 같은 유속성분을 가지는 비압축성 정상류는 존재할 수 있는가?   \\[u=2x^{2}-xy+z^{2}\\]  \\[v=x^{2}-4xy+y^{2}\\]  \\[w=-2xy-yz+y^{2}\\]  답변   내용     ","categories": ["Fluid Mechanics"],
        "tags": ["Fluid Mechanics"],
        "url": "http://localhost:4000/fluid%20mechanics/Studying-Fluid-7/",
        "teaser": null
      },{
        "title": "Fluid Mechanics: Studying 9-1",
        "excerpt":"질문   내용   그림에 표시된 원형유선을 따른 흐름의 유속이 \\(2m/sec\\)로 일정할 때 유선상의 임의 점에서의 접선 및 법선방향의 가속도성분을 구하라.      답변   내용     ","categories": ["Fluid Mechanics"],
        "tags": ["Fluid Mechanics"],
        "url": "http://localhost:4000/fluid%20mechanics/Studying-Fluid-8/",
        "teaser": null
      },{
        "title": "BOJ: 11654 아스키 코드",
        "excerpt":"문제   알파벳 소문자, 대문자, 숫자 0-9중 하나가 주어졌을 때, 주어진 글자의 아스키 코드값을 출력하는 프로그램을 작성하시오.   입력   알파벳 소문자, 대문자, 숫자 0-9 중 하나가 첫째 줄에 주어진다.   출력   입력으로 주어진 글자의 아스키 코드 값을 출력한다.   예제 입력 1   A   예제 출력 1   65   예제 입력 2   C   예제 출력 2   67   예제 입력 3   0   예제 출력 3   48   예제 입력 4   9   예제 출력 4   57   예제 입력 5   a   예제 출력 5   97   예제 입력 6   z   예제 출력 6   122       코드   #include &lt;iostream&gt; using namespace std; int main(void) {     char i;     cin&gt;&gt;i;     cout&lt;&lt;static_cast&lt;int&gt;(i);     return 0; }       Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-43/",
        "teaser": null
      },{
        "title": "Blog: Github 서버 점검",
        "excerpt":"문제   블로그 포스팅 글이 커밋 시점 이후에 제대로 발행되지 않는 문제가 발생하여 기존에 Minimal-mistakes 템플릿의 업데이트 문제를 의심 하였으나, 아래와 같이 깃헙 서버 점검 문제로 발생한 일이었다.   (점검 시간이 오래 걸린것으로 보아 생각보다 대규모의 점검이었나보다;;)      깃헙 서버 상태를 확인할 수 있는 사이트는 아래의 Reference를 참고하면 된다.   Reference   Github_Status  ","categories": ["Blog"],
        "tags": ["Blog","Github","Issue"],
        "url": "http://localhost:4000/blog/Blog-Issue-1/",
        "teaser": null
      },{
        "title": "BOJ: 10430 나머지",
        "excerpt":"문제   \\((A+B)\\%C\\)는 \\(((A\\%C)+(B\\%C))\\%C\\)와 같을까?   \\((A \\times B)\\%C\\)는 \\(((A\\%C) \\times (B\\%C))\\%C\\) 와 같을까?   세 수 \\(A, B, C\\)가 주어졌을 때, 위의 네 가지 값을 구하는 프로그램을 작성하시오.   입력   첫째 줄에 \\(A, B, C\\)가 순서대로 주어진다. \\((2 \\leq A, B, C \\leq 10000)\\)   출력   첫째 줄에 \\((A+B)\\%C\\), 둘째 줄에 \\(((A\\%C) + (B\\%C))\\%C\\), 셋째 줄에 \\((A \\times B)\\%C\\), 넷째 줄에 \\(((A\\%C) \\times (B\\%C))\\%C\\)를 출력한다.   예제 입력 1   5 8 4   예제 출력 1   1 1 0 0       코드   #include &lt;iostream&gt; using namespace std; int main(void) {     int a, b, c;     cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;     cout&lt;&lt;(a+b)%c&lt;&lt;'\\n';     cout&lt;&lt;((a%c)+(b%c))%c&lt;&lt;'\\n';     cout&lt;&lt;(a*b)%c&lt;&lt;'\\n';     cout&lt;&lt;((a%c)*(b%c))%c;     return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-44/",
        "teaser": null
      },{
        "title": "BOJ: 9498 시험 성적",
        "excerpt":"문제   시험 점수를 입력받아 90 ~ 100점은 A, 80 ~ 89점은 B, 70 ~ 79점은 C, 60 ~ 69점은 D, 나머지 점수는 F를 출력하는 프로그램을 작성하시오.   입력   첫째 줄에 시험 점수가 주어진다. 시험 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다.   출력   시험 성적을 출력한다.   예제 입력 1   100   예제 출력 1   A       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int grade;      cin&gt;&gt;grade;      if(grade &gt;= 90) {         cout&lt;&lt;'A';     }else if(grade &gt;= 80) {         cout&lt;&lt;'B';     }else if(grade &gt;= 70) {         cout&lt;&lt;'C';     }else if(grade &gt;= 60) {         cout&lt;&lt;'D';     }else{         cout&lt;&lt;'F';     }      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-45/",
        "teaser": null
      },{
        "title": "BOJ: 5338 마이크로소프트 로고",
        "excerpt":"문제   마이크로소프트 로고를 예제 출력처럼 출력하는 프로그램을 작성하시오.   출력   마이크로소프트 로고를 예제 출력처럼 출력한다.   예제 입력 1     예제 출력 1          _.-;;-._ '-..-'|   ||   | '-..-'|_.-;;-._| '-..-'|   ||   | '-..-'|_.-''-._|       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {      cout&lt;&lt;\"       _.-;;-._\"&lt;&lt;endl;     cout&lt;&lt;\"'-..-'|   ||   |\"&lt;&lt;endl;     cout&lt;&lt;\"'-..-'|_.-;;-._|\"&lt;&lt;endl;     cout&lt;&lt;\"'-..-'|   ||   |\"&lt;&lt;endl;     cout&lt;&lt;\"'-..-'|_.-''-._|\"&lt;&lt;endl;      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-46/",
        "teaser": null
      },{
        "title": "BOJ: 10718 We love kriii",
        "excerpt":"문제   ACM-ICPC 인터넷 예선, Regional, 그리고 World Finals까지 이미 2회씩 진출해버린 kriii는 미련을 버리지 못하고 왠지 모르게 올해에도 파주 World Finals 준비 캠프에 참여했다.   대회를 뜰 줄 모르는 지박령 kriii를 위해서 격려의 문구를 출력해주자.   입력   본 문제는 입력이 없다.   출력   두 줄에 걸쳐 “강한친구 대한육군”을 한 줄에 한 번씩 출력한다.   예제 입력 1     예제 출력 1   강한친구 대한육군 강한친구 대한육군       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {          cout&lt;&lt;\"강한친구 대한육군\"&lt;&lt;endl;     cout&lt;&lt;\"강한친구 대한육군\"&lt;&lt;endl;      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-47/",
        "teaser": null
      },{
        "title": "Fluid Mechanics: Test 3-5",
        "excerpt":"질문   내용   다음 그림을 이용하여 오전 8시에 서울에서 출발하여 \\(100km/hr\\)로 남하하는 경우, 2시간 후 온도를 계산하시오.      답변   내용     ","categories": ["Fluid Mechanics"],
        "tags": ["Fluid Mechanics"],
        "url": "http://localhost:4000/fluid%20mechanics/Studying-Fluid-9/",
        "teaser": null
      },{
        "title": "BOJ: 2440 별 찍기 - 3",
        "excerpt":"문제   첫째 줄에는 별 \\(N\\)개, 둘째 줄에는 별 \\(N-1\\)개, …, \\(N\\)번째 줄에는 별 1개를 찍는 문제   입력   첫째 줄에 \\(N(1 \\leq N \\leq 100)\\)이 주어진다.   출력   첫째 줄부터 \\(N\\)번째 줄까지 차례대로 별을 출력한다.   예제 입력 1   5   예제 출력 1   ***** **** *** ** *       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int n;      cin&gt;&gt;n;      for(int i=n; i&gt;0; i--) {         for(int j=0; j&lt;i; j++)             cout&lt;&lt;'*';         cout&lt;&lt;endl;     }      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-48/",
        "teaser": null
      },{
        "title": "Differential Equation: Studying 3-1",
        "excerpt":"질문   내용   미분방정식 \\(2xyy^{'}=y^{2}-x^{2}\\)의 일반해를 구하여라.   답변   내용     ","categories": ["Differential Equation"],
        "tags": ["Differential Equation"],
        "url": "http://localhost:4000/differential%20equation/Studying-Differential-Equation-5/",
        "teaser": null
      },{
        "title": "Differential Equation: Test 2-1",
        "excerpt":"질문   내용   용수철 상수가 \\(27N/m\\)인 용수철의 아랫 부분에 질량이 \\(3kg\\)인 물체가 매달려 있고, 그 아래에 감쇠상수가 \\(12kg/sec\\)인 제동장치가 달려 있다. 이 물체를 아래로 \\(4m\\) 잡아당긴 상태에서 초기속도 \\(0m/sec\\)로 놓았을 때, \\(t\\)초 후의 운동을 나타내는 식을 구하고, 시간에 따른 위치를 그래프로 나타내어라.   답변   내용     ","categories": ["Differential Equation"],
        "tags": ["Differential Equation"],
        "url": "http://localhost:4000/differential%20equation/Studying-Differential-Equation-6/",
        "teaser": null
      },{
        "title": "Differential Equation: Test 2-2",
        "excerpt":"질문   내용   매개변수 변환법을 이용하여 전개하면 다음과 같은 식을 얻을 수 있다. 이 식을 통해 \\(y_{p}\\)를 구하는 과정을 설명하시오.   \\[u_{1}^{''}y_{1}+2u_{1}^{'}y_{1}^{'}+u_{2}^{''}y_{2}+2u_{2}^{'}y_{2}^{'}+p(x)(u_{1}^{'}y_{1}+u_{2}^{'}y_{2})=r(x)\\]  답변   내용     ","categories": ["Differential Equation"],
        "tags": ["Differential Equation"],
        "url": "http://localhost:4000/differential%20equation/Studying-Differential-Equation-7/",
        "teaser": null
      },{
        "title": "Differential Equation: Test 2-5",
        "excerpt":"질문   내용   다음 행렬의 고유값과 고유벡터를 구하시오.   \\[A = \\begin{bmatrix}1 &amp; 2 \\\\ 2 &amp; 4\\end{bmatrix}\\]  답변   내용     ","categories": ["Differential Equation"],
        "tags": ["Differential Equation"],
        "url": "http://localhost:4000/differential%20equation/Studying-Differential-Equation-8/",
        "teaser": null
      },{
        "title": "Differential Equation: Test 2-4",
        "excerpt":"질문   내용   \\((e^{y}-ye^{x})dx + (xe^{y}-e^{x})dy = 0\\)이 완전미분방정식임을 보이고 해를 구하시오.   답변   내용     ","categories": ["Differential Equation"],
        "tags": ["Differential Equation"],
        "url": "http://localhost:4000/differential%20equation/Studying-Differential-Equation-9/",
        "teaser": null
      },{
        "title": "Relative Error of Closure",
        "excerpt":"Relative Error of Closure   내용   결합 트래버스에서 폐합비를 도출해내었을 때, 폐합비가 허용범위 내에 들어오지 않을 경우 재측의 상황에 놓이게 된다.   이러한 경우 임의로 측선을 조정하고 다시 폐합비를 계산하여 이를 확인하는 과정이 필요한데, 어떠한 의미도 포함하지 않은 단순 계산이므로 컴퓨터에게 이러한 작업을 맡겨보기로 했다.   아래는 이번 측량학 조별 과제를 수행하면서 내가 작성한 파이썬 프로그램이다.   코드   import math import random  bef_d = [[359, 31, 31.67], [271, 33, 18.34], [231, 37, 5.01], [214, 30, 51.68], [181, 12, 13.34], [90, 0, 0.01]];  aft_d = []; leng = [45.56, 24.93, 11.03, 18.91, 23.35, 45.52]; aft_leng = [0, 0, 0, 0, 0, 0]; n = []; e = []; flag = 0  def dms2deg(bef_d):     return bef_d[0]+bef_d[1]/60+bef_d[2]/3600  while(True):     deg = []; n_t = 0; e_t = 0; d = 0      if(flag == 0):         for i in range(0, 6):             aft_d.append(dms2deg(bef_d[i])); n.append(round(leng[i]*math.cos(math.radians(aft_d[i])), 3)); n_t += n[i]; e.append(round(leng[i]*math.sin(math.radians(aft_d[i])), 3))             e_t += e[i]          err = round(math.sqrt(math.pow(n_t, 2)+math.pow(e_t, 2)), 3)          for i in leng: d += i          r = err/d          print(aft_d); print(n); print(e); print(round(n_t, 3)); print(round(e_t, 3)); print(err); print(r)          if(r &lt; 1/3000):             print(\"허용오차 범위 내 존재\"); break         else:             print(\"허용오차 범위 내 존재하지 않음\"); all = random.randrange(1, 5); flag = 1      else:         for i in range(0, 6):             aft_leng[i] = random.randrange(int(math.modf(leng[i])[1])-all, int(math.modf(leng[i])[1])+all+1) + float(math.modf(leng[i])[0])             n[i] = round(aft_leng[i]*math.cos(math.radians(aft_d[i])), 3); n_t += n[i]             e[i] = round(aft_leng[i]*math.sin(math.radians(aft_d[i])), 3); e_t += e[i]          err = round(math.sqrt(math.pow(n_t, 2)+math.pow(e_t, 2)), 3)          for i in aft_leng: d += i          r = err/d          print(aft_d); print(n); print(e); print(round(n_t, 3)); print(round(e_t, 3)); print(err); print(r); print(aft_leng); print(d)          if(r &lt; 1/3000):             print(\"허용오차 범위 내 존재\"); print(aft_leng); break         else:             print(\"허용오차 범위 내 존재하지 않음\"); all = random.randrange(1, 5); flag = 1       코드 설명   1~4 범위 내에서 하나의 값을 랜덤으로 도출하게끔 하고 그 값을 이용하여 기존의 재측 이전의 측선 거리의 반경값을 계산하였으며, 이러한 반경 내에서 랜덤하게 거리를 도출해내었다.   뿐만 아니라, 도출된 거리 값을 이용하여 폐합비를 계산하였으며, 그 폐합비가 \\(\\frac{1}{3000}\\)보다 작은 경우에만 그때의 조정된 측선의 거리 값을 출력하게 했다.   물론 여기서 반경 내의 값이 소수점 이하의 값이 존재하지 않는 즉, 기존 측선 거리 값에 비해 정밀도가 떨어지는 값이 아니냐고 반문할 수 있어서, 필자는 먼저 기존 측선의 거리 값에서 정수부와 실수부로 분리하여 정수부 기준으로 반경 1~4까지의 랜덤 값을 뽑아내고 그 값에 분리해놓은 실수부를 결합시키는 방식으로 소수점 이하의 값이 손실되는 것을 방지하였다.   위 프로그램을 실행한 결과는 아래와 같다.   실행 결과      ","categories": ["Exhibition","Geomatics Engineering"],
        "tags": ["Geomatics Engineering"],
        "url": "http://localhost:4000/exhibition/geomatics%20engineering/Relative_Error_Of_Closure/",
        "teaser": null
      },{
        "title": "Fluid Mechanics: Test 3-2",
        "excerpt":"질문   내용   다음과 같이 하부 저수지에 있는 \\(3,600m^{2}\\)의 물을 저수지로부터 \\(20m\\) 위에 있는 수로로 2시간 동안 양수하기 위해 필요한 펌프의 소요출력을 \\(KW\\)로 계산하시오. 단, 펌프의 효율은 \\(70%\\)로 가정하며, 모든 손실은 무시하시오.      답변   내용     ","categories": ["Fluid Mechanics"],
        "tags": ["Fluid Mechanics"],
        "url": "http://localhost:4000/fluid%20mechanics/Studying-Fluid-10/",
        "teaser": null
      },{
        "title": "BOJ: 2557 Hello World",
        "excerpt":"문제   Hello World!를 출력하시오.   입력   없음   출력   Hello World!를 출력하시오.   예제 입력 1     예제 출력 1   Hello World!       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     cout&lt;&lt;\"Hello World!\";      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-48/",
        "teaser": null
      },{
        "title": "BOJ: 14681 사분면 고르기",
        "excerpt":"문제   흔한 수학 문제 중 하나는 주어진 점이 어느 사분면에 속하는지 알아내는 것이다. 사분면은 아래 그림처럼 1부터 4까지 번호를 갖는다. “Quadrant n”은 “제n사분면”이라는 뜻이다.      예를 들어, 좌표가 \\((12,5)\\)인 점 \\(A\\)는 \\(x\\)좌표와 \\(y\\)좌표가 모두 양수이므로 제1사분면에 속한다. 점 \\(B\\)는 \\(x\\)좌표가 음수이고 \\(y\\)좌표가 양수이므로 제2사분면에 속한다.   점의 좌표를 입력받아 그 점이 어느 사분면에 속하는지 알아내는 프로그램을 작성하시오. 단, \\(x\\)좌표와 \\(y\\)좌표는 모두 양수나 음수라고 가정한다.   입력   첫 줄에는 정수 \\(x\\)가 주어진다. \\((-1000 \\leq x \\leq 1000; x \\neq 0)\\) 다음 줄에는 정수 \\(y\\)가 주어진다. \\((-1000 \\leq y \\leq 1000; y \\neq 0)\\)   출력   점 \\((x, y)\\)의 사분면 번호(1, 2, 3, 4 중 하나)를 출력한다.   예제 입력 1   12 5   예제 출력 1   1   예제 입력 2   9 -13   예제 출력 2   4       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int x;     int y;      cin&gt;&gt;x;     cin&gt;&gt;y;      if(x &gt; 0 &amp;&amp; y &gt; 0)         cout&lt;&lt;1;     else if(x &gt; 0 &amp;&amp; y &lt; 0)         cout&lt;&lt;4;     else if(x &lt; 0 &amp;&amp; y &gt; 0)         cout&lt;&lt;2;     else if(x &lt; 0 &amp;&amp; y &lt; 0)         cout&lt;&lt;3;          return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-49/",
        "teaser": null
      },{
        "title": "BOJ: 1000 A+B",
        "excerpt":"문제   두 정수 \\(A\\)와 \\(B\\)를 입력받은 다음, \\(A+B\\)를 출력하는 프로그램을 작성하시오.   입력   첫째 줄에 \\(A\\)와 \\(B\\)가 주어진다. \\((0 &lt; A,B &lt; 10)\\)   출력   첫째 줄에 \\(A+B\\)를 출력한다.   예제 입력 1   1 2   예제 출력 1   3   힌트   여기를 누르면 1000번 예제 소스를 볼 수 있습니다.       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int a, b;      cin&gt;&gt;a&gt;&gt;b;      cout&lt;&lt;a+b;      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-50/",
        "teaser": null
      },{
        "title": "BOJ: 10940 BASE16 인코딩",
        "excerpt":"문제   문자열 \\(S\\)가 주어졌을 때, \\(S\\)를 BASE16 인코딩해 출력하는 프로그램을 작성하시오.   입력   첫째 줄에 문자열 \\(S\\)가 주어진다. \\(S\\)는 알파벳 대문자와 소문자, 그리고 숫자로만 이루어져 있으며, 길이는 최대 50이다.   출력   첫째 줄에 \\(S\\)를 BASE16으로 인코딩한 값을 출력한다.   예제 입력 1   Baekjoon   예제 출력 1   4261656B6A6F6F6E       코드   #include &lt;bits/stdc++.h&gt;  using namespace std;  int main(void) {     ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);     char base16[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};     char str[51];     int i=0;      cin&gt;&gt;str;      while(str[i] != '\\0') {         cout&lt;&lt;base16[(int(str[i])/16)%16];         cout&lt;&lt;base16[int(str[i])%16];         i++;     }      return 0; }    Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-51/",
        "teaser": null
      },{
        "title": "BOJ: 10546 배부른 마라토너",
        "excerpt":"문제   마라토너라면 국적과 나이를 불문하고 누구나 참가하고 싶어하는 백준 마라톤 대회가 열린다. \\(42.195km\\)를 달리는 이 마라톤은 모두가 참가하고 싶어했던 만큼 매년 모두가 완주해왔다. 단, 한 명만 빼고!   모두가 참가하고 싶어서 안달인데 이런 백준 마라톤 대회에 참가해 놓고 완주하지 못한 배부른 참가자 한 명은 누굴까?   입력   첫째 줄에는 참가자 수 \\(N\\)이 주어진다. \\((1 \\leq N \\leq 10^{5})\\)   \\(N\\)개의 줄에는 참가자의 이름이 주어진다.   추가적으로 주어지는 \\(N-1\\)개의 줄에는 완주한 참가자의 이름이 쓰여져 있다.   참가자들의 이름은 길이가 1보다 크거나 같고, 20보다 작거나 같은 문자열이고, 알파벳 소문자로만 이루어져 있다.   참가자들 중엔 동명이인이 있을 수도 있다.   출력   마라톤을 완주하지 못한 참가자의 이름을 출력한다.   예제 입력 1   3 leo kiki eden eden kiki   예제 출력 1   leo   예제 입력 2   5 marina josipa nikola vinko filipa josipa filipa marina nikola   예제 출력 2   vinko   예제 입력 3   4 mislav stanko mislav ana stanko ana mislav   예제 출력 3   mislav       코드   #include &lt;bits/stdc++.h&gt; #include &lt;unordered_map&gt;  using namespace std;  int main(void) {     ios_base::sync_with_stdio(false);     cin.tie(NULL); cout.tie(NULL);          unordered_map&lt;string, int&gt; player;     unordered_map&lt;string, int&gt;:: iterator itr;      string name;     int n;      cin&gt;&gt;n;      for(int i=0; i&lt;n; i++) {         cin&gt;&gt;name;          if(player.find(name) != player.end())             player[name]++;         else             player.insert(make_pair(name, 1));     }      for(int i=0; i&lt;n-1; i++) {         cin&gt;&gt;name;          if(player.find(name) != player.end())             player[name]--;     }      for(itr=player.begin(); itr != player.end(); itr++)         if(itr-&gt;second != 0)             cout&lt;&lt;itr-&gt;first&lt;&lt;'\\n';      return 0; }    Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-52/",
        "teaser": null
      },{
        "title": "BOJ: 17352 여러분의 다리가 되어 드리겠습니다!",
        "excerpt":"문제   선린월드에는 \\(N\\)개의 섬이 있다. 섬에는 \\(1, 2, ..., N\\)의 번호가 하나씩 붙어 있다. 그 섬들을 \\(N-1\\)개의 다리가 잇고 있으며, 어떤 두 섬 사이든 다리로 왕복할 수 있다.      어제까지는 그랬다.   “왜 다리가 \\(N-1\\)개밖에 없냐, 통행하기 불편하다”며 선린월드에 불만을 갖던 욱제가 다리 하나를 무너뜨렸다! 안 그래도 불편한 통행이 더 불편해졌다. 서로 왕복할 수 없는 섬들이 생겼기 때문이다. 일단 급한 대로 정부는 선린월드의 건축가를 고용해, 서로 다른 두 섬을 다리로 이어서 다시 어떤 두 섬 사이든 왕복할 수 있게 하라는 지시를 내렸다.   그런데 그 건축가가 당신이다! 안 그래도 천하제일 코딩대회에 참가하느라 바쁜데…   입력   첫 줄에 정수 \\(N\\)이 주어진다. \\((2 \\leq N \\leq 300,000)\\)   그 다음 \\(N-2\\)개의 줄에는 욱제가 무너뜨리지 않은 다리들이 잇는 두 섬의 번호가 주어진다.   출력   다리로 이을 두 섬의 번호를 출력한다. 여러 가지 방법이 있을 경우 그 중 아무거나 한 방법만 출력한다.   예제 입력 1   4 1 2 1 3   예제 출력 1   1 4   “4 1”이나 “2 4”, “4 3” 등 가능한 정답은 많이 있지만, 아무거나 하나만 출력해야 한다.   예제 입력 2   2   예제 출력 2   1 2   예제 입력 3   5 1 2 2 3 4 5   예제 출력 3   3 4       코드   #include &lt;bits/stdc++.h&gt;  using namespace std;  class Djs {     int* rank;     int* parent;     int n;      public:     void init(int n) {         rank = new int[n];         parent = new int[n];         this-&gt;n = n;         makeSet();     }      void makeSet() {         for(int i=0; i&lt;n; i++) parent[i] = i+1;     }      int find(int x) {         if(parent[x-1] != x) parent[x-1] = find(parent[x-1]);          return parent[x-1];     }      void Union(int x, int y) {         int xset = find(x);         int yset = find(y);          if(xset == yset) return;          if(rank[xset-1] &lt; rank[yset-1]) parent[xset-1] = yset;         else if(rank[xset-1] &gt; rank[yset-1]) parent[yset-1] = xset;         else { parent[yset-1] = xset; rank[xset-1] = rank[xset-1] + 1;}     }      ~Djs() {         delete[] rank; delete[] parent;     } };  int main(void) {     Djs d;     int n, k, t;     int flag=0;      cin&gt;&gt;n;      d.init(n);      for(int i=0; i&lt;n-2; i++) { cin&gt;&gt;k&gt;&gt;t; d.Union(k, t); }       for(int i=0; i&lt;n; i++) {          for(int j=0; j&lt;n; j++) if(d.find(i+1) != d.find(j+1)) { cout&lt;&lt;i+1&lt;&lt;' '&lt;&lt;j+1; flag=1; break;}                  if(flag == 1) break;     }          return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-53/",
        "teaser": null
      },{
        "title": "BOJ: 11653 소인수분해",
        "excerpt":"문제   정수 \\(N\\)이 주어졌을 때, 소인수분해하는 프로그램을 작성하시오.   입력   첫째 줄에 정수 \\(N(1 \\leq N \\leq 10,000,000)\\)이 주어진다.   출력   \\(N\\)의 소인수분해 결과를 한 줄에 하나씩 오름차순으로 출력한다. \\(N\\)이 1인 경우 아무것도 출력하지 않는다.   예제 입력 1   72   예제 출력 1   2 2 2 3 3   예제 입력 2   3   예제 출력 2   3   예제 입력 3   6   예제 출력 3   2 3   예제 입력 4   2   예제 출력 4   2   예제 입력 5   9991   예제 출력 5   97 103       코드   #include &lt;bits/stdc++.h&gt;  using namespace std;  bool is_prime(int n) {     int count = 0;      for(int i=1; i&lt;=n; i++) n % i == 0 ? count++ : false;      return count == 2 ? true : false; }  int main(void) {     int n, i=1, val=0, exa=0;      cin&gt;&gt;n;      while(n != 1) { while(n % i == 0 &amp;&amp; is_prime(i)) { cout&lt;&lt;i&lt;&lt;'\\n'; n /= i; } i++; }      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-54/",
        "teaser": null
      },{
        "title": "BOJ: 1330 두 수 비교하기",
        "excerpt":"문제   두 정수 \\(A\\)와 \\(B\\)가 주어졌을 때, \\(A\\)와 \\(B\\)를 비교하는 프로그램을 작성하시오.   입력   첫째 줄에 \\(A\\)와 \\(B\\)가 주어진다. \\(A\\)와 \\(B\\)는 공백 한 칸으로 구분되어져 있다.   출력   첫째 줄에 다음 세 가지 중 하나를 출력한다.      \\(A\\)가 \\(B\\)보다 큰 경우에는 ‘&gt;’를 출력한다.   \\(A\\)가 \\(B\\)보다 작은 경우에는 ‘&lt;’를 출력한다.   \\(A\\)와 \\(B\\)가 같은 경우에는 ‘==’를 출력한다.   제한       \\[-10,000 \\leq A, B \\leq 10,000\\]      예제 입력 1   1 2   예제 출력 1   &lt;   예제 입력 2   10 2   예제 출력 2   &gt;   예제 입력 3   5 5   예제 출력 3   ==       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int a, b;      cin&gt;&gt;a&gt;&gt;b;      if(a &gt; b) {         cout&lt;&lt;\"&gt;\"&lt;&lt;endl;     }else if(a &lt; b) {         cout&lt;&lt;\"&lt;\"&lt;&lt;endl;     }else{         cout&lt;&lt;\"==\"&lt;&lt;endl;     }      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-55/",
        "teaser": null
      },{
        "title": "BOJ: 1978 소수 찾기",
        "excerpt":"문제   주어진 수 \\(N\\)개 중에서 소수가 몇 개인지 찾아서 출력하는 프로그램을 작성하시오.   입력   첫 줄에 수의 개수 \\(N\\)이 주어진다. \\(N\\)은 100이하이다. 다음으로 \\(N\\)개의 수가 주어지는데 수는 \\(1,000\\) 이하의 자연수이다.   출력   주어진 수들 중 소수의 개수를 출력한다.   예제 입력 1   4 1 3 5 7   예제 출력 1   3       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int n;     int arr[100] = {0,};     int count = 0;     int chk = 0;      cin&gt;&gt;n;      for(int i=0; i&lt;n; i++)         cin&gt;&gt;arr[i];      for(int i=0; i&lt;n; i++) {         chk = 0;                  for(int j=1; j&lt;=arr[i]; j++)             if(arr[i] % j == 0)                 chk++;          if(chk == 2)             count++;     }      cout&lt;&lt;count;      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-56/",
        "teaser": null
      },{
        "title": "BOJ: 2438 별 찍기 - 1",
        "excerpt":"문제   첫째 줄에는 별 1개, 둘째 줄에는 별 2개, \\(N\\)번째 줄에는 별 \\(N\\)개를 찍는 문제   입력   첫째 줄에 \\(N(1 \\leq N \\leq 100)\\)이 주어진다.   출력   첫째 줄부터 \\(N\\)번째 줄까지 차례대로 별을 출력한다.   예제 입력 1   5   예제 출력 1   * ** *** **** *****       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int n;      cin&gt;&gt;n;      for(int i=0; i&lt;n; i++) {         for(int j=0; j&lt;=i; j++)             cout&lt;&lt;'*';         cout&lt;&lt;endl;     }      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-57/",
        "teaser": null
      },{
        "title": "Mechanics of Materials: Tensile Strength Test - 1",
        "excerpt":"Tensile Strength Test   내용   5월 25일부터 진행되었던 재료역학 실험실습 보고서 작성 과제가 어제 잘 마무리가 되었고, 본 포스팅을 통해 필자가 그 결과를 보이고자 한다.   먼저 실험실습은 코로나 상황으로 인해서 온라인으로 진행되었기 때문에 단순 영상시청으로만 실험 과정을 확인해볼 수 있었으며, 다음과 같이 인장시험의 결과 도출된 데이터만 csv 파일로 주어졌다.   SM45C   인장시험에 사용된 시험편은 국민 강재로 알려진 SM45C이다. 이것에 대해서 간략히 설명을 하자면, SM45C는 기계구조용 탄소강재로서, 열처리나 경화 작업을 통해 기계적 강도가 요구되는 부품의 재료로 사용되고 있다. 일반적으로 SM재에서 많이 사용하는 재질은 지금 다루고 있는 SM45C와 SM35C를 주로 많이 사용한다. 또한, SM45C에서 S와 M은 Steel과 Machine의 앞 글자를 딴 것이고, 45는 탄소함유량을 나타내며, C는 탄소를 의미한다. 마지막으로 국민 강재로 불리게 된 이유도 설명을 하자면, 철과 탄소가 아주 흔한 물질이고, 화학적 결합이 쉬워서이며, 가공성과 강도가 괜찮기 때문이다.   이 정도로 간략히 설명을 마치고, 위에서 주어진 csv 데이터들을 이용해서 본 보고서가 요구한 사항들을 해결해보기로 하겠다. 먼저 보고서의 요구사항을 확인해보자.      공칭 응력-변형율 선도   탄성계수   0.2% 오프셋에 의한 항복응력   극한강도   파단연신율   csv 파일의 데이터들을 Excel을 통해서 처리해도 되지만, 필자는 한 걸음 더 나아가 Python을 이용해보았다.   csv 파일의 데이터를 처리하기 위해서는 다음과 같이 Python에서 csv 파일을 열고 그 데이터를 읽어들여야 한다.   import csv  sm = open(\"SM.csv\", \"r\") rdr = csv.reader(sm)  sm.close()   데이터를 읽어들인 후에는 다음과 같이 반복문을 통해서 행 단위로 데이터를 읽어들일 수 있다.   for line in rdr:     # Ex. line[0] line[1] line[2] ...   공칭 응력-변형율 선도   공칭 응력-변형율 선도를 그리기 위해서는 변형율(Strain) 값과 응력(Stress) 값이 필요한데, csv 파일에서 이미 Stress data를 Mpa 단위로 제공해주고 있기 때문에 문제 될 것이 없으나, Strain의 경우에는 표면적으로 그 data가 드러나 있지 않기 때문에 어떤 data를 통해서 Strain의 값을 도출해내야 한다.   csv file을 잘 살펴보면, Elongation Percent data가 존재하고, 해당 data는 다음의 식으로부터 유도되었으며,   \\[Elongation = \\frac{\\Delta{L}}{L}\\times{100}(\\%)\\]  위 식에서 \\(Strain = \\varepsilon = \\frac{\\Delta{L}}{L}\\) 이므로, Elongation Percent data를 단순히 100으로 나눠주기만 하면 그 값이 Strain이라는 것은 자명하다.   그러므로 다음과 같이 코드를 작성하여 Stress data(9 Column)는 Stress List에, Strain data는 Elongation Percent data(10 Column)를 100으로 나누어 Strain List에 삽입하자.      물론 데이터 처리시에 기본적으로 읽어들인 값의 type은 str이므로, 형 변환을 해주어야 함을 잊지 말자.    import csv  sm = open(\"SM.csv\", \"r\") rdr = csv.reader(sm) stress = [] strain = []   for line in rdr:     stress.append(float(line[8])); strain.append(float(line[9])/100)  sm.close()   그런데 1, 2 row는 수치가 아닌 category와 unit data이므로 3 row부터 읽어들여야 한다.   그러므로 다음과 같이 코드를 작성하자.   import csv  sm = open(\"SM.csv\", \"r\") rdr = csv.reader(sm) stress = [] strain = []  next(rdr); next(rdr)  for line in rdr:     stress.append(float(line[8])); strain.append(float(line[9])/100)  sm.close()   위 코드를 작성한 후 다음의 print문을 추가하여 stress와 strain이 각 List에 잘 삽입되었는지 확인해보자.   print(stress); print(strain)   코드의 실행결과가 Error 없이 다음과 같이 도출되었다면, 성공이다.      이제 읽어들인 Strain과 Stress 데이터를 가지고, matplotlib 라이브러리를 이용해서 Graph를 그려볼 것이다.   다음과 같이 코드를 작성하자.   import matplotlib.pyplot as plt import csv  sm = open(\"SM.csv\", \"r\") rdr = csv.reader(sm) stress = [] strain = []  next(rdr); next(rdr)  for line in rdr:     stress.append(float(line[8])); strain.append(float(line[9])/100)  plt.plot(strain, stress) plt.xlabel(\"Strain\"); plt.ylabel(\"Stress(Mpa)\")  plt.savefig(\"S-S Curve.png\", dpi=300, bbox_inches=\"tight\")  sm.close()   위 코드를 실행한 후, 코드 파일과 동일한 Path에 다음과 같이 S-S Curve.png 파일이 생성되고,      그 결과, 다음과 같은 그래프가 도출되었다면 성공이다.      위 코드에서 plot에 인자를 보낼 때 먼저 보낸 Data가 x, 뒤에 보낸 Data가 y가 된다는 사실을 유념하자. 또한, 필자는 가로축과 세로축에 각각 Strain, Stress(Mpa)를 레이블로 설정하였는데, Strain은 무차원이기 때문에 Stress에서처럼 따로 단위를 기재하지는 않았다.   그렇게 도출된 Graph를 show()해도 되나, 보고서 특성상 따로 이미지를 첨부해야 하기 때문에 필자의 경우에는 savefig()를 했다.   여기서 1편을 마무리 짓고, 다음 편에서는 탄성계수를 도출해낸 과정과 0.2% 오프셋 방법을 이용하여 항복응력을 도출해낸 과정을 설명하겠다.  ","categories": ["Exhibition","Mechanics of Materials"],
        "tags": ["Mechanics of Materials"],
        "url": "http://localhost:4000/exhibition/mechanics%20of%20materials/Materials_Report/",
        "teaser": null
      },{
        "title": "Fluid Mechanics: Finals 4-4",
        "excerpt":"질문   내용   유속분포가 다음과 같을 때 운동에너지 및 운동량 보정계수를 구하여라. 관의 모양은 직사각형이며 폭은 \\(1m\\)로 가정하여라.      답변   내용     ","categories": ["Fluid Mechanics"],
        "tags": ["Fluid Mechanics"],
        "url": "http://localhost:4000/fluid%20mechanics/Studying-Fluid-11/",
        "teaser": null
      },{
        "title": "Fluid Mechanics: Finals 4-5",
        "excerpt":"질문   내용      다음을 계산하시오.   (2) 수두가 \\(5m, Q=10m^3/sec\\)일 때 동력을 계산하여 \\(w(watt)\\)로 나타내시오.   답변   내용     ","categories": ["Fluid Mechanics"],
        "tags": ["Fluid Mechanics"],
        "url": "http://localhost:4000/fluid%20mechanics/Studying-Fluid-12/",
        "teaser": null
      },{
        "title": "Fluid Mechanics: Finals 4-3",
        "excerpt":"질문   내용      아래의 수문에서 상류 및 하류의 수심이 각각 \\(5m, 1m\\)일 때, 수문에 작용하는 힘을 구하시오. 단위폭을 가정하여라.      답변   내용     ","categories": ["Fluid Mechanics"],
        "tags": ["Fluid Mechanics"],
        "url": "http://localhost:4000/fluid%20mechanics/Studying-Fluid-13/",
        "teaser": null
      },{
        "title": "Fluid Mechanics: Finals 4-2",
        "excerpt":"질문   내용      다음과 같이 제형단면의 수로에 물이 흐르고 있을 때, 동수반경을 구하시오.      답변   내용     ","categories": ["Fluid Mechanics"],
        "tags": ["Fluid Mechanics"],
        "url": "http://localhost:4000/fluid%20mechanics/Studying-Fluid-14/",
        "teaser": null
      },{
        "title": "BOJ: 10950 A + B - 3",
        "excerpt":"문제   두 정수 \\(A\\)와 \\(B\\)를 입력받은 다음, \\(A+B\\)를 출력하는 프로그램을 작성하시오.   입력   첫째 줄에 테스트 케이스의 개수 \\(T\\)가 주어진다.   각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 \\(A\\)와 \\(B\\)가 주어진다. \\((0 &lt; A, B &lt; 10)\\)   출력   각 테스트 케이스마다 \\(A+B\\)를 출력한다.   예제 입력 1   5 1 1 2 3 3 4 9 8 5 2   예제 출력 1   2 5 7 17 7       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int a, b, t;      cin&gt;&gt;t;      for(int i=0; i&lt;t; i++) {         cin&gt;&gt;a&gt;&gt;b;                  cout&lt;&lt;a+b&lt;&lt;endl;     }      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-58/",
        "teaser": null
      },{
        "title": "BOJ: 2588 곱셈",
        "excerpt":"문제   (세 자리 수) \\(\\times\\) (세 자리 수)는 다음과 같은 과정을 통하여 이루어진다.      (1)과 (2) 위치에 들어갈 세 자리 자연수가 주어질 때 (3), (4), (5), (6) 위치에 들어갈 값을 구하는 프로그램을 작성하시오.   입력   첫째 줄에 (1)의 위치에 들어갈 세 자리 자연수가, 둘째 줄에 (2)의 위치에 들어갈 세자리 자연수가 주어진다.   출력   첫째 줄부터 넷째 줄까지 차례대로 (3), (4), (5), (6)에 들어갈 값을 출력한다.   예제 입력 1   472 385   예제 출력 1   2360 3776 1416 181720       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int a, b, t;      cin&gt;&gt;a&gt;&gt;b;          t = b;      while(1) {         if(t == 0)             break;          cout&lt;&lt;a * (t % 10)&lt;&lt;'\\n';          t /= 10;     }      cout&lt;&lt;a*b;              return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-59/",
        "teaser": null
      },{
        "title": "BOJ: 10869 사칙연산",
        "excerpt":"문제   두 자연수 \\(A\\)와 \\(B\\)가 주어진다. 이때, \\(A+B, A-B, A*B, A/B, A%B\\)를 출력하는 프로그램을 작성하시오.   입력   두 자연수 \\(A\\)와 \\(B\\)가 주어진다. \\((1 \\leq A, B \\leq 10,000)\\)   출력   첫째 줄에 \\(A+B\\), 둘째 줄에 \\(A-B\\), 셋째 줄에 \\(A*B\\), 넷째 줄에 \\(A/B\\), 다섯째 줄에 \\(A%B\\)를 출력한다.   예제 입력 1   7 3   예제 출력 1   10 4 21 2 1       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int a, b;      cin&gt;&gt;a&gt;&gt;b;      cout&lt;&lt;a+b&lt;&lt;'\\n';     cout&lt;&lt;a-b&lt;&lt;'\\n';     cout&lt;&lt;a*b&lt;&lt;'\\n';     cout&lt;&lt;a/b&lt;&lt;'\\n';     cout&lt;&lt;a%b&lt;&lt;'\\n';      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-60/",
        "teaser": null
      },{
        "title": "BOJ: 11021 A + B - 7",
        "excerpt":"문제   두 정수 \\(A\\)와 \\(B\\)를 입력받은 다음, \\(A+B\\)를 출력하는 프로그램을 작성하시오.   입력   첫째 줄에 테스트 케이스의 개수 \\(T\\)가 주어진다.   각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 \\(A\\)와 \\(B\\)가 주어진다. \\((0 &lt; A, B &lt; 10)\\)   출력   각 테스트 케이스마다 “Case #x: “를 출력한 다음, \\(A+B\\)를 출력한다. 테스트 케이스 번호는 1부터 시작한다.   예제 입력 1   5 1 1 2 3 3 4 9 8 5 2   예제 출력 1   Case #1: 2 Case #2: 5 Case #3: 7 Case #4: 17 Case #5: 7       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int a, b;     int n;      cin&gt;&gt;n;      for(int i=0; i&lt;n; i++) {         cin&gt;&gt;a&gt;&gt;b;          if(a &lt;= 0 || b &gt;= 10) {             i--;             continue;         }                      cout&lt;&lt;\"Case #\"&lt;&lt;i+1&lt;&lt;':'&lt;&lt;' '&lt;&lt;a+b&lt;&lt;endl;     }      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-61/",
        "teaser": null
      },{
        "title": "BOJ: 10039 평균 점수",
        "excerpt":"문제   상현이가 가르치는 아이폰 앱 개발 수업의 수강생은 원섭, 세희, 상근, 숭, 강수이다.   어제 이 수업의 기말고사가 있었고, 상현이는 지금 학생들의 기말고사 시험지를 채점하고 있다. 기말고사 점수가 40점 이상인 학생들은 그 점수 그대로 자신의 성적이 된다. 하지만, 40점 미만인 학생들은 보충학습을 듣는 조건을 수락하면 40점을 받게 된다. 보충학습은 거부할 수 없기 때문에, 40점 미만인 학생들은 항상 40점을 받게 된다.   학생 5명의 점수가 주어졌을 때, 평균 점수를 구하는 프로그램을 작성하시오.   입력   입력은 총 5줄로 이루어져 있고, 원섭이의 점수, 세희의 점수, 상근이의 점수, 숭이의 점수, 강수의 점수가 순서대로 주어진다.   점수는 모두 0점 이상, 100점 이하인 5의 배수이다. 따라서, 평균 점수는 항상 정수이다.   출력   첫째 줄에 학생 5명의 평균 점수를 출력한다.   예제 입력 1   10 65 100 30 95   예제 출력 1   68   힌트   숭과 원섭이는 40점 미만이고, 보충학습에 참여할 예정이기 때문에 40점을 받게 된다. 따라서, 점수의 합은 340점이고, 평균은 68점이 된다.       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int arr[5];     int result = 0;      for(int i=0; i&lt;5; i++) {         cin&gt;&gt;arr[i];                  if(arr[i] &lt; 40) {             result += 40;             continue;         }                      result += arr[i];     }          cout&lt;&lt;result/5;      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-62/",
        "teaser": null
      },{
        "title": "BOJ: 10952 A + B - 5",
        "excerpt":"문제   두 정수 \\(A\\)와 \\(B\\)를 입력받은 다음, \\(A+B\\)를 출력하는 프로그램을 작성하시오.   입력   입력은 여러 개의 테스트 케이스로 이루어져 있다.   각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 \\(A\\)와 \\(B\\)가 주어진다. \\((0 &lt; A, B &lt; 10)\\)   입력의 마지막에는 0 두 개가 들어온다.   출력   각 테스트 케이스마다 \\(A+B\\)를 출력한다.   예제 입력 1   1 1 2 3 3 4 9 8 5 2 0 0   예제 출력 1   2 5 7 17 7       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int a, b;      while(1) {         cin&gt;&gt;a&gt;&gt;b;                  if(a == 0 &amp;&amp; b == 0)             break;              cout&lt;&lt;a+b&lt;&lt;endl;     }          return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-63/",
        "teaser": null
      },{
        "title": "BOJ: 2741 N 찍기",
        "excerpt":"문제   자연수 \\(N\\)이 주어졌을 때, 1부터 \\(N\\)까지 한 줄에 하나씩 출력하는 프로그램을 작성하시오.   입력   첫째 줄에 \\(100,000\\)보다 작거나 같은 자연수 \\(N\\)이 주어진다.   출력   첫째 줄부터 \\(N\\)번째 줄까지 차례대로 출력한다.   예제 입력 1   5   예제 출력 1   1 2 3 4 5       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int n;      cin&gt;&gt;n;      for(int i=1; i&lt;=n; i++)         cout&lt;&lt;i&lt;&lt;'\\n';      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-64/",
        "teaser": null
      },{
        "title": "Mechanics of Materials: Tensile Strength Test - 2",
        "excerpt":"Tensile Strength Test   지난 편에 이어서 재료역학 시간에 실시한 인장 시험 보고서의 내용을 공개하고자 한다.   먼저 탄성계수부터 살펴보자.   탄성계수   탄성계수란 재료의 강성도(stiffness)를 나타내는 값으로서 공칭 응력-변형율 선도의 선형 구간에서의 기울기이다.   이전 시간에 우리는 SM.csv 파일로부터 데이터를 불러들여 공칭 응력-변형율 선도를 python을 통해 draw 해보았다.   이번에는 탄성계수를 도출하기 위해서 공칭 응력-변형율 선도로부터 선형 구간을 찾아내고 그 선형 구간에서의 데이터를 기반으로 기울기 값 즉, 탄성계수를 도출해보자.   먼저 공칭 응력-변형율 선도에서 선형 구간을 찾기 위해서 필자는 다음의 생각을 떠올렸다.      양수이면서 가장 앞서는 기울기 데이터를 기준으로 설정하여 그 이후에 등장하는 기울기 값과의 차이가 설정한 범위 내에 존재한다면 그 값이 선형 구간에서의 기울기이다.    말이 이해가 가지 않을 수 있으니 직접 코드로 보이면서 이를 설명하겠다.   먼저 지난 편에서 작성한 전체 코드를 가져오자.   import matplotlib.pyplot as plt import csv  sm = open(\"SM.csv\", \"r\") rdr = csv.reader(sm) stress = [] strain = []  next(rdr); next(rdr)  for line in rdr:     stress.append(float(line[8])); strain.append(float(line[9])/100)  plt.plot(strain, stress) plt.xlabel(\"Strain\"); plt.ylabel(\"Stress(Mpa)\")  plt.savefig(\"S-S Curve.png\", dpi=300, bbox_inches=\"tight\")  sm.close()   위 코드에서 먼저 기울기 데이터를 담을 리스트를 하나 선언하자.   import matplotlib.pyplot as plt import csv  sm = open(\"SM.csv\", \"r\") rdr = csv.reader(sm) stress = [] strain = [] slope_l = []        # 기울기 데이터를 담을 리스트  next(rdr); next(rdr)  for line in rdr:     stress.append(float(line[8])); strain.append(float(line[9])/100)  plt.plot(strain, stress) plt.xlabel(\"Strain\"); plt.ylabel(\"Stress(Mpa)\")  plt.savefig(\"S-S Curve.png\", dpi=300, bbox_inches=\"tight\")  sm.close()   이제 기울기 값을 도출해내야 하는데 이는 다음의 식으로부터 도출해낼 수 있다.   \\[slope = \\frac{\\Delta{Strain}}{\\Delta{Stress}}\\]  또한, 이미 stress와 strain 데이터를 각각 stress, strain 리스트에 삽입했으므로 이를 이용하자.   import matplotlib.pyplot as plt import csv  sm = open(\"SM.csv\", \"r\") rdr = csv.reader(sm) stress = [] strain = [] slope_l = []  next(rdr); next(rdr)  for line in rdr:     stress.append(float(line[8])); strain.append(float(line[9])/100)  for i in range(0, len(stress)-1):     slope = (strain[i+1] - strain[i]) / (stress[i+1] - stress[i])  plt.plot(strain, stress) plt.xlabel(\"Strain\"); plt.ylabel(\"Stress(Mpa)\")  plt.savefig(\"S-S Curve.png\", dpi=300, bbox_inches=\"tight\")  sm.close()   그런데 필자가 위의 아이디어에서 말했듯 양수 기울기가 필요하므로 반복문 내에 조건(기울기 값이 양수)을 걸고 그 조건을 만족할 때에 기울기 값을 리스트에 삽입하는 동작을 수행하게끔 하자.   또한, 몇 번째 데이터로부터 해당 기울기 값을 도출해내었는지 확인하기 위해 반복문에 의해 카운트 되는 변수(아래 코드에서 i)의 값도 리스트에 삽입하자.   import matplotlib.pyplot as plt import csv  sm = open(\"SM.csv\", \"r\") rdr = csv.reader(sm) stress = [] strain = [] slope_l = []  next(rdr); next(rdr)  for line in rdr:     stress.append(float(line[8])); strain.append(float(line[9])/100)  for i in range(0, len(stress)-1):           # Index Error를 미연에 방지하기 위해 stress의 길이에서 1을 뺌     slope = (strain[i+1] - strain[i]) / (stress[i+1] - stress[i])       # 위에서 기울기를 도출해내기 위해 작성한 수식에 의해      if(slope &gt; 0):      # 기울기 값이 0보다 크면         slope_l.append([i, slope])          # slope_l 리스트에 i 값과 기울기 값을 리스트로 묶어서 삽입  plt.plot(strain, stress) plt.xlabel(\"Strain\"); plt.ylabel(\"Stress(Mpa)\")  plt.savefig(\"S-S Curve.png\", dpi=300, bbox_inches=\"tight\")  sm.close()   그 후 기울기를 삽입한 slope_l 리스트를 순회하면서 첫 번째 기울기가 첫 번째 이후의 기울기와 그 차이가 0.0000005 이내일 때에만 slope_l의 원소를 출력하도록 하자.   import matplotlib.pyplot as plt import csv  sm = open(\"SM.csv\", \"r\") rdr = csv.reader(sm) stress = [] strain = [] slope_l = []  next(rdr); next(rdr)  for line in rdr:     stress.append(float(line[8])); strain.append(float(line[9])/100)  for i in range(0, len(stress)-1):     slope = (strain[i+1] - strain[i]) / (stress[i+1] - stress[i])      if(slope &gt; 0):         slope_l.append([i, slope])  for i in range(1, len(slope_l)):        # 첫 번째 이후의 slope_l 원소에 접근하기 위함     if(abs(slope_l[0][1] - slope_l[i][1]) &lt; 0.0000005):         # 첫 번째 기울기가 첫 번째 이후의 기울기와 그 차이가 0.0000005 이내일 때         print(slope_l[i])         # slope_l 리스트의 원소 출력  plt.plot(strain, stress) plt.xlabel(\"Strain\"); plt.ylabel(\"Stress(Mpa)\")  plt.savefig(\"S-S Curve.png\", dpi=300, bbox_inches=\"tight\")  sm.close()   출력의 결과가 다음과 같다면 성공이다.      위 출력 결과를 분석해보면 343번째 데이터 이후에 갑자기 1418번째 데이터가 등장함을 확인할 수 있는데, 이는 다음의 공칭 응력-변형율 선도를 확인해보면 어느정도 유추를 해볼 수 있다.      즉, 양수이면서 가장 앞선 기울기 데이터와 차이가 0.0000005 이내인 기울기가 다음의 공칭 응력-변형율 선도에서      대략 위의 빨간색 네모친 부분에 위치함을 유추해볼 수 있다.   그러므로 우리는 가장 앞에서부터 300~350개의 데이터만을 가지고 이 데이터들을 가장 잘 대표하는 기울기를 하나 찾아낸다면 그것이 곧 탄성계수가 됨을 생각해볼 수 있다.   먼저 위에서 작성했던 전체 코드 중   import matplotlib.pyplot as plt import csv  sm = open(\"SM.csv\", \"r\") rdr = csv.reader(sm) stress = [] strain = [] slope_l = []      # 기울기 관련 코드  next(rdr); next(rdr)  for line in rdr:     stress.append(float(line[8])); strain.append(float(line[9])/100)   # 기울기 관련 코드 for i in range(0, len(stress)-1):     slope = (strain[i+1] - strain[i]) / (stress[i+1] - stress[i])      if(slope &gt; 0):         slope_l.append([i, slope])  # 기울기 관련 코드  for i in range(1, len(slope_l)):     if(abs(slope_l[0][1] - slope_l[i][1]) &lt; 0.0000005):         print(slope_l[i])  plt.plot(strain, stress) plt.xlabel(\"Strain\"); plt.ylabel(\"Stress(Mpa)\")  plt.savefig(\"S-S Curve.png\", dpi=300, bbox_inches=\"tight\")  sm.close()   선형 구간을 찾아내기 위해 삽입했던 기울기 관련 구문들을 모두 삭제하자.   import matplotlib.pyplot as plt import csv  sm = open(\"SM.csv\", \"r\") rdr = csv.reader(sm) stress = [] strain = []  next(rdr); next(rdr)  for line in rdr:     stress.append(float(line[8])); strain.append(float(line[9])/100)  plt.plot(strain, stress) plt.xlabel(\"Strain\"); plt.ylabel(\"Stress(Mpa)\")  plt.savefig(\"S-S Curve.png\", dpi=300, bbox_inches=\"tight\")  sm.close()   이제 stress_ex, strain_ex 리스트를 선언하여 350개의 stress와 strain 데이터들을 저장하자.   이때도 역시 기존의 stress와 strain 리스트를 활용하자.   import matplotlib.pyplot as plt import csv  sm = open(\"SM.csv\", \"r\") rdr = csv.reader(sm) stress = [] strain = [] stress_ex = [] strain_ex = []  next(rdr); next(rdr)  for line in rdr:     stress.append(float(line[8])); strain.append(float(line[9])/100)  for i in range(0, 350):     stress_ex.append(stress[i])     strain_ex.append(strain[i])  plt.plot(strain, stress) plt.xlabel(\"Strain\"); plt.ylabel(\"Stress(Mpa)\")  plt.savefig(\"S-S Curve.png\", dpi=300, bbox_inches=\"tight\")  sm.close()   그 후 350개의 stress와 strain을 가장 잘 대표하는 기울기를 찾고 이를 출력해보자.   이를 위해 우리가 직접 알고리즘을 구현할 필요는 없다.   numpy에서 제공하는 polyfit이라는 함수를 이용하면 된다.   import numpy as np import matplotlib.pyplot as plt import csv  sm = open(\"SM.csv\", \"r\") rdr = csv.reader(sm) stress = [] strain = [] stress_ex = [] strain_ex = []  next(rdr); next(rdr)  for line in rdr:     stress.append(float(line[8])); strain.append(float(line[9])/100)  for i in range(0, 350):     stress_ex.append(stress[i])     strain_ex.append(strain[i])  slope_intercept = np.polyfit(strain_ex, stress_ex, 1)       # strain_ex, stress_ex 리스트의 원소들(strain, stress의 350개의 데이터들)을 가장 잘 대표하는 기울기와 y 절편 산출  print(slope_intercept)  plt.plot(strain, stress) plt.xlabel(\"Strain\"); plt.ylabel(\"Stress(Mpa)\")  plt.savefig(\"S-S Curve.png\", dpi=300, bbox_inches=\"tight\")  sm.close()   위 코드의 실행 결과가 다음과 같이 도출되었다면 성공이다.   [1.25515487e+05 2.43356112e+01]   왜 결과 값이 하나가 아닌 두 개가 도출되었는지 의문이 생길 수 있다. (위 코드에서 주석을 먼저 확인해본 사람이라면 그 답을 알 수 있다.)   polyfit 함수는 기울기 값 뿐만 아니라 직선의 y 절편 값도 반환하기 때문이다.   즉, 우리가 구하고자 하는 값은 2.43356112e+01이다. (이것이 탄성계수 값이다.)   탄성계수 값 도출을 마지막으로 이번 편을 마무리 짓고 다음 편에서는 보고서에 작성한 0.2% 오프셋 방법을 설명하도록 하겠다.  ","categories": ["Exhibition","Mechanics of Materials"],
        "tags": ["Mechanics of Materials"],
        "url": "http://localhost:4000/exhibition/mechanics%20of%20materials/Materials_Report-2/",
        "teaser": null
      },{
        "title": "BOJ: 2742 기찍 N",
        "excerpt":"문제   자연수 \\(N\\)이 주어졌을 때, \\(N\\)부터 1까지 한 줄에 하나씩 출력하는 프로그램을 작성하시오.   입력   첫째 줄에 \\(100,000\\)보다 작거나 같은 자연수 \\(N\\)이 주어진다.   출력   첫째 줄부터 \\(N\\)번째 줄까지 차례대로 출력한다.   예제 입력 1   5   예제 출력 1   5 4 3 2 1       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int n;      cin&gt;&gt;n;      for(int i=n; i&gt;0; i--)         cout&lt;&lt;i&lt;&lt;'\\n';              return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-65/",
        "teaser": null
      },{
        "title": "BOJ: 5337 웰컴",
        "excerpt":"문제   Welcome을 예제 출력처럼 출력하는 프로그램을 작성하시오.   출력   Welcome을 아래 예제 출력처럼 출력한다.   예제 입력 1      예제 출력 1   .  .   . |  | _ | _. _ ._ _  _ |/\\|(/.|(_.(_)[ | )(/.       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     cout&lt;&lt;\".  .   .\"&lt;&lt;endl;     cout&lt;&lt;\"|  | _ | _. _ ._ _  _\"&lt;&lt;endl;     cout&lt;&lt;\"|/\\\\|(/.|(_.(_)[ | )(/.\";      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-66/",
        "teaser": null
      },{
        "title": "Mechanics of Materials: Tensile Strength Test - 3",
        "excerpt":"Tensile Strength Test   지난 편에 이어서 재료역학 시간에 실시한 인장 시험 보고서의 내용을 공개하고자 한다.   다음으로 0.2% 오프셋에 의한 항복응력을 구하는 과정을 서술하겠다.   0.2% 오프셋에 의한 항복응력   먼저 항복응력에 대해서 설명하겠다.      물체에 힘을 가하여 양쪽으로 당긴다고 했을 때 그 물체의 길이는 어떻게 될까?    당연하게도 물체의 길이는 늘어나게 될 것이다.   그런데 여기서 어느 정도 힘을 가하고 그 힘을 놓게 된다면 그 물체는 다시 원래의 길이로 돌아가게 될 것이다.   하지만 일정 크기 이상의 힘으로 그 물체를 양쪽에서 당긴 후 힘을 놓게 된다면 그 물체는 원래 상태로 되돌아가지 못하고 더 길어지게 될 것이다.   이때, 물체에 인장력을 가하여 그 물체가 원래 상태로 돌아갈 수 있을 때의 최대 힘을 항복강도 또는 항복응력이라고 한다.   이러한 항복응력은 다음의 Stress-strain diagram에서 볼 수 있듯이 육안으로 확인할 수 있는 반면,      우리에게 주어진 데이터로부터 그려진 다음의 Stress-strain diagram의 경우에는      항복응력의 위치를 찾아내는 것이 어렵다.   그러므로 이러한 경우에 근사적으로 항복응력의 값을 도출하기 위해서 0.2% 오프셋 방법이 등장하게 되었다.   이 방법은 곡선의 초기 선형 구간에서의 직선을 0.2%(우리의 경우에는 기존 Elongation percent data를 100으로 나누었으므로 0.002)만큼 오른쪽으로 평행이동한 후 그 직선이 곡선과 만나는 지점의 Stress 값이 항복응력이 된다는 원리이다.   우리는 이전 시간에 탄성계수 즉, 곡선의 초기 선형 구간에서의 기울기를 도출했고 또 그때의 y절편도 도출했으므로 이 값들을 그대로 이용하여 일차함수를 구성해주고 Draw 한 후 직선과 곡선이 만나는 점의 y 좌표 값만 산출해주면 되겠다.   (일차함수보다 직선이 더 큰 개념이지만 실습 데이터로부터 그리고 0.2% 오프셋 방법으로부터 본 포스팅에서는 일차함수의 관점에서 서술하겠다.)   먼저 지난 시간에 작성한 코드를 가져오자.   import numpy as np import matplotlib.pyplot as plt import csv  sm = open(\"SM.csv\", \"r\") rdr = csv.reader(sm) stress = [] strain = [] stress_ex = [] strain_ex = []  next(rdr); next(rdr)  for line in rdr:     stress.append(float(line[8])); strain.append(float(line[9])/100)  for i in range(0, 350):     stress_ex.append(stress[i])     strain_ex.append(strain[i])  slope_intercept = np.polyfit(strain_ex, stress_ex, 1)  print(slope_intercept)  plt.plot(strain, stress) plt.xlabel(\"Strain\"); plt.ylabel(\"Stress(Mpa)\")  plt.savefig(\"S-S Curve.png\", dpi=300, bbox_inches=\"tight\")  sm.close()   먼저 위 코드에서 slope_intercept를 출력하는 출력문을 삭제하자.   그 후, 직선을 Draw 하기 위해서 정의역에 대한 배열을 구성해주어야 하는데 numpy에서 linspace 함수를 제공해주므로 이를 이용하자.   import numpy as np import matplotlib.pyplot as plt import csv  sm = open(\"SM.csv\", \"r\") rdr = csv.reader(sm) stress = [] strain = [] stress_ex = [] strain_ex = []  next(rdr); next(rdr)  for line in rdr:     stress.append(float(line[8])); strain.append(float(line[9])/100)  for i in range(0, 350):     stress_ex.append(stress[i])     strain_ex.append(strain[i])  slope_intercept = np.polyfit(strain_ex, stress_ex, 1)  x = np.linspace(-0.0001, 0.01, 10000)           # -0.0001 ~ 0.01에서 10000개의 element를 가진 numpy array를 생성한다.  plt.plot(strain, stress) plt.xlabel(\"Strain\"); plt.ylabel(\"Stress(Mpa)\")  plt.savefig(\"S-S Curve.png\", dpi=300, bbox_inches=\"tight\")  sm.close()   정의역을 구성했다면 이제 치역을 구성하자.   import numpy as np import matplotlib.pyplot as plt import csv  sm = open(\"SM.csv\", \"r\") rdr = csv.reader(sm) stress = [] strain = [] stress_ex = [] strain_ex = []  next(rdr); next(rdr)  for line in rdr:     stress.append(float(line[8])); strain.append(float(line[9])/100)  for i in range(0, 350):     stress_ex.append(stress[i])     strain_ex.append(strain[i])  slope_intercept = np.polyfit(strain_ex, stress_ex, 1)  x = np.linspace(-0.0001, 0.01, 10000)            y = slope_intercept[0] * x + slope_intercept[1]             # slope_intercept의 첫 번째 데이터가 slope이고 두 번째 데이터가 y-intercept이다.  plt.plot(strain, stress) plt.xlabel(\"Strain\"); plt.ylabel(\"Stress(Mpa)\")  plt.savefig(\"S-S Curve.png\", dpi=300, bbox_inches=\"tight\")  sm.close()   그 후 plot 함수의 추가 인자로 x와 y를 넘겨주자.   import numpy as np import matplotlib.pyplot as plt import csv  sm = open(\"SM.csv\", \"r\") rdr = csv.reader(sm) stress = [] strain = [] stress_ex = [] strain_ex = []  next(rdr); next(rdr)  for line in rdr:     stress.append(float(line[8])); strain.append(float(line[9])/100)  for i in range(0, 350):     stress_ex.append(stress[i])     strain_ex.append(strain[i])  slope_intercept = np.polyfit(strain_ex, stress_ex, 1)  x = np.linspace(-0.0001, 0.01, 10000)            y = slope_intercept[0] * x + slope_intercept[1]               plt.plot(strain, stress, x, y)              # plot 함수의 추가 인자로 x와 y를 넘겨줌. plt.xlabel(\"Strain\"); plt.ylabel(\"Stress(Mpa)\")  plt.savefig(\"S-S Curve.png\", dpi=300, bbox_inches=\"tight\")  sm.close()   위 코드 실행 후 동일 Directory 내에 생성된 S-S Curve.png의 결과가 다음과 같다면 성공이다.      동일한 방식으로 직선을 하나 더 그려야하기 때문에 정의역을 하나 더 구성해주고, 그 때의 치역도 하나 더 구성해주자.   치역에 대한 식을 작성할 때는 위에서 설명했듯이 0.002만큼 오른쪽으로의 평행이동을 고려하고, 그래프가 깔끔하게 그려지도록 y 값이 0보다 크거나 같은 구간에서만 Draw가 되도록 하자.   즉, 치역에 y가 0보다 크거나 같다는 제한을 두면 된다.   import numpy as np import matplotlib.pyplot as plt import csv  sm = open(\"SM.csv\", \"r\") rdr = csv.reader(sm) stress = [] strain = [] stress_ex = [] strain_ex = []  next(rdr); next(rdr)  for line in rdr:     stress.append(float(line[8])); strain.append(float(line[9])/100)  for i in range(0, 350):     stress_ex.append(stress[i])     strain_ex.append(strain[i])  slope_intercept = np.polyfit(strain_ex, stress_ex, 1)  x = np.linspace(-0.0001, 0.01, 10000)            x1 = np.linspace(0.002, 0.01, 8112)                # 0.002 ~ 0.01에서 8112개의 element를 가진 numpy array를 생성한다. y = slope_intercept[0] * x + slope_intercept[1]              y1 = list(filter(lambda y1: y1 &gt;= 0, slope_intercept[0] * (x - 0.002) + slope_intercept[1]))      # 0.002만큼 오른쪽으로의 평행이동과 깔끔한 그래프 Draw를 위한 y1이 0보다 크거나 같다는 제한  plt.plot(strain, stress, x, y) plt.xlabel(\"Strain\"); plt.ylabel(\"Stress(Mpa)\")  plt.savefig(\"S-S Curve.png\", dpi=300, bbox_inches=\"tight\")  sm.close()   그 다음, 다음과 같이 plot의 추가 인자로 x1과 y1을 보내주자.   import numpy as np import matplotlib.pyplot as plt import csv  sm = open(\"SM.csv\", \"r\") rdr = csv.reader(sm) stress = [] strain = [] stress_ex = [] strain_ex = []  next(rdr); next(rdr)  for line in rdr:     stress.append(float(line[8])); strain.append(float(line[9])/100)  for i in range(0, 350):     stress_ex.append(stress[i])     strain_ex.append(strain[i])  slope_intercept = np.polyfit(strain_ex, stress_ex, 1)  x = np.linspace(-0.0001, 0.01, 10000)            x1 = np.linspace(0.002, 0.01, 8112)                 y = slope_intercept[0] * x + slope_intercept[1]              y1 = list(filter(lambda y1: y1 &gt;= 0, slope_intercept[0] * (x - 0.002) + slope_intercept[1]))        plt.plot(strain, stress, x, y, x1, y1)              # plot 함수의 추가 인자로 x1과 y1을 인자로 보내줌. plt.xlabel(\"Strain\"); plt.ylabel(\"Stress(Mpa)\")  plt.savefig(\"S-S Curve.png\", dpi=300, bbox_inches=\"tight\")  sm.close()   위 코드 실행 후 S-S Curve.png의 결과가 다음과 같다면 성공이다.      마지막으로 평행이동한 직선과 곡선이 만나는 점의 y 좌표를 산출해야 하는데, 필자는 이것을 위한 별도의 알고리즘 구현없이 shapely라는 패키지를 이용하여 처리하였다.      shapely는 직교 좌표 평면에서의 geometric objects들에 대한 조작 및 분석과 관련된 기능들을 제공해주는 패키지이다.    먼저 다음과 같이 평행이동한 직선에 대해서 LineString 클래스에 대한 객체를 생성하고, 마찬가지로 S-S Curve에 대해서도 LineString 클래스에 대한 객체를 생성하자.   import numpy as np import matplotlib.pyplot as plt import csv from shapely.geometry import LineString  sm = open(\"SM.csv\", \"r\") rdr = csv.reader(sm) stress = [] strain = [] stress_ex = [] strain_ex = []  next(rdr); next(rdr)  for line in rdr:     stress.append(float(line[8])); strain.append(float(line[9])/100)  for i in range(0, 350):     stress_ex.append(stress[i])     strain_ex.append(strain[i])  slope_intercept = np.polyfit(strain_ex, stress_ex, 1)  x = np.linspace(-0.0001, 0.01, 10000)            x1 = np.linspace(0.002, 0.01, 8112)                 y = slope_intercept[0] * x + slope_intercept[1]              y1 = list(filter(lambda y1: y1 &gt;= 0, slope_intercept[0] * (x - 0.002) + slope_intercept[1]))        line_1 = LineString(np.column_stack((x1, y1)))          # 평행이동한 직선에 대한 LineString 객체 생성 line_2 = LineString(np.column_stack((strain, stress)))          # S-S Curve에 대한 LineString 객체 생성  plt.plot(strain, stress, x, y, x1, y1) plt.xlabel(\"Strain\"); plt.ylabel(\"Stress(Mpa)\")  plt.savefig(\"S-S Curve.png\", dpi=300, bbox_inches=\"tight\")  sm.close()   그 후 평행이동한 직선과 S-S Curve의 교차점을 찾기 위해 intersection 함수를 이용하자.   import numpy as np import matplotlib.pyplot as plt import csv from shapely.geometry import LineString  sm = open(\"SM.csv\", \"r\") rdr = csv.reader(sm) stress = [] strain = [] stress_ex = [] strain_ex = []  next(rdr); next(rdr)  for line in rdr:     stress.append(float(line[8])); strain.append(float(line[9])/100)  for i in range(0, 350):     stress_ex.append(stress[i])     strain_ex.append(strain[i])  slope_intercept = np.polyfit(strain_ex, stress_ex, 1)  x = np.linspace(-0.0001, 0.01, 10000)            x1 = np.linspace(0.002, 0.01, 8112)                 y = slope_intercept[0] * x + slope_intercept[1]              y1 = list(filter(lambda y1: y1 &gt;= 0, slope_intercept[0] * (x - 0.002) + slope_intercept[1]))        line_1 = LineString(np.column_stack((x1, y1)))           line_2 = LineString(np.column_stack((strain, stress)))            intersection = line_1.intersection(line_2)          # line_1과 line_2의 교차점에 대한 representation을 intersection에 저장  plt.plot(strain, stress, x, y, x1, y1) plt.xlabel(\"Strain\"); plt.ylabel(\"Stress(Mpa)\")  plt.savefig(\"S-S Curve.png\", dpi=300, bbox_inches=\"tight\")  sm.close()   그 다음, x와 y 좌표를 각각 x_c와 y_c에 삽입하자.   import numpy as np import matplotlib.pyplot as plt import csv from shapely.geometry import LineString  sm = open(\"SM.csv\", \"r\") rdr = csv.reader(sm) stress = [] strain = [] stress_ex = [] strain_ex = []  next(rdr); next(rdr)  for line in rdr:     stress.append(float(line[8])); strain.append(float(line[9])/100)  for i in range(0, 350):     stress_ex.append(stress[i])     strain_ex.append(strain[i])  slope_intercept = np.polyfit(strain_ex, stress_ex, 1)  x = np.linspace(-0.0001, 0.01, 10000)            x1 = np.linspace(0.002, 0.01, 8112)                 y = slope_intercept[0] * x + slope_intercept[1]              y1 = list(filter(lambda y1: y1 &gt;= 0, slope_intercept[0] * (x - 0.002) + slope_intercept[1]))        line_1 = LineString(np.column_stack((x1, y1)))           line_2 = LineString(np.column_stack((strain, stress)))      intersection = line_1.intersection(line_2)           x_c, y_c = intersection.xy          # x와 y 좌표를 각각 x_c와 y_c에 삽입  plt.plot(strain, stress, x, y, x1, y1) plt.xlabel(\"Strain\"); plt.ylabel(\"Stress(Mpa)\")  plt.savefig(\"S-S Curve.png\", dpi=300, bbox_inches=\"tight\")  sm.close()   마지막으로 교차점을 그래프에 표시하고, 교차점의 x좌표와 y좌표를 출력하자.   import numpy as np import matplotlib.pyplot as plt import csv from shapely.geometry import LineString  sm = open(\"SM.csv\", \"r\") rdr = csv.reader(sm) stress = [] strain = [] stress_ex = [] strain_ex = []  next(rdr); next(rdr)  for line in rdr:     stress.append(float(line[8])); strain.append(float(line[9])/100)  for i in range(0, 350):     stress_ex.append(stress[i])     strain_ex.append(strain[i])  slope_intercept = np.polyfit(strain_ex, stress_ex, 1)  x = np.linspace(-0.0001, 0.01, 10000)            x1 = np.linspace(0.002, 0.01, 8112)                 y = slope_intercept[0] * x + slope_intercept[1]              y1 = list(filter(lambda y1: y1 &gt;= 0, slope_intercept[0] * (x - 0.002) + slope_intercept[1]))        line_1 = LineString(np.column_stack((x1, y1)))           line_2 = LineString(np.column_stack((strain, stress)))      intersection = line_1.intersection(line_2)           x_c, y_c = intersection.xy           print(x_c, y_c)             # 교차점의 x좌표와 y좌표 출력  plt.plot(strain, stress, x, y, x1, y1) plt.plot(*intersection.xy, 'ro')            # 그래프에 교차점 표시 plt.xlabel(\"Strain\"); plt.ylabel(\"Stress(Mpa)\")  plt.savefig(\"S-S Curve.png\", dpi=300, bbox_inches=\"tight\")  sm.close()   x와 y좌표가 각각 다음과 같이 출력되고,      그래프에 교차점이 다음과 같이 표시된다면 성공이다.      결론적으로 항복응력은 대략 700 근처임을 유추할 수 있겠다.   여기까지 이번 포스팅을 마무리 짓고 다음 포스팅에서는 극한강도와 파단연신율을 산출했던 과정을 설명하도록 하겠다.  ","categories": ["Exhibition","Mechanics of Materials"],
        "tags": ["Mechanics of Materials"],
        "url": "http://localhost:4000/exhibition/mechanics%20of%20materials/Materials_Report-3/",
        "teaser": null
      },{
        "title": "BOJ: 11720 숫자의 합",
        "excerpt":"문제   \\(N\\)개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오.   입력   첫째 줄에 숫자의 개수 \\(N (1 \\leq N \\leq 100)\\)이 주어진다. 둘째 줄에 숫자 \\(N\\)개가 공백없이 주어진다.   출력   입력으로 주어진 숫자 \\(N\\)개의 합을 출력한다.   예제 입력 1   1 1   예제 출력 1   1   예제 입력 2   5 54321   예제 출력 2   15   예제 입력 3   25 7000000000000000000000000   예제 출력 3   7   예제 입력 4   11 10987654321   예제 출력 4   46       코드   #include &lt;iostream&gt;  using namespace std;  int main(void) {     int n;     int result = 0;     char i[100];      cin&gt;&gt;n;      for(int k=0; k&lt;n; k++)         cin&gt;&gt;i[k];      for(int k=0; k&lt;n; k++)         result += (i[k] - 48);      cout&lt;&lt;result;      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-67/",
        "teaser": null
      },{
        "title": "BOJ: 9653 스타워즈 로고",
        "excerpt":"문제   스타워즈 로고를 예제 출력과 같이 출력하는 프로그램을 작성하시오.   출력   스타워즈 로고를 출력한다.   예제 입력 1      예제 출력 1       8888888888  888    88888    88     88   88 88   88  88     8888  88  88   88  88888        88 88 888888888 88   88 88888888  88 88     88 88    888888  88  88  88   888    88888    888888 88  88  88  88 88   88  88  88 88 8888 88 88   88  88888    8888  888  888 888888888 88  88      88   88  88  88     88 88   88888888       코드   #include &lt;bits/stdc++.h&gt;  using namespace std;  int main(void) {     cout&lt;&lt;\"    8888888888  888    88888\"&lt;&lt;endl;     cout&lt;&lt;\"   88     88   88 88   88  88\"&lt;&lt;endl;     cout&lt;&lt;\"    8888  88  88   88  88888\"&lt;&lt;endl;     cout&lt;&lt;\"       88 88 888888888 88   88\"&lt;&lt;endl;     cout&lt;&lt;\"88888888  88 88     88 88    888888\"&lt;&lt;endl;     cout&lt;&lt;endl;     cout&lt;&lt;\"88  88  88   888    88888    888888\"&lt;&lt;endl;     cout&lt;&lt;\"88  88  88  88 88   88  88  88\"&lt;&lt;endl;     cout&lt;&lt;\"88 8888 88 88   88  88888    8888\"&lt;&lt;endl;     cout&lt;&lt;\" 888  888 888888888 88  88      88\"&lt;&lt;endl;     cout&lt;&lt;\"  88  88  88     88 88   88888888\";      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-68/",
        "teaser": null
      },{
        "title": "BOJ: 15059 Hard choice",
        "excerpt":"문제   In long flights, airlines offer hot meals. Usually the flight attendants push carts containing the meals down along the aisles of the plane. When a cart reaches your row, you are asked right away: “Chicken, beef, or pasta?” You know your choices, but you have only a few seconds to choose and you don’t know how your choice will look like because your neighbor hasn’t opened his wrap yet. . .   The flight attendant in this flight decided to change the procedure. First she will ask all passengers what choice of meal they would prefer, and then she will check if the number of meals available in this flight for each choice are enough.   As an example, consider that the available number of meals for chicken, beef and pasta are respectively (80, 20, 40), while the number of passenger’s choices for chicken, beef and pasta are respectively (45, 23, 48). In this case, eleven people will surely not receive their selection for a meal, since three passengers who wanted beef and eight passengers who wanted pasta cannot be pleased.   Given the quantity of meals available for each choice and the number of meals requested for each choice, could you please help the flight attendant to determine how many passengers will surely not receive their selection for a meal?   입력   The first line contains three integers \\(C_{a}, B_{a}\\) and \\(P_{a} (0 \\leq C_{a}, B_{a}, P_{a} \\leq 100)\\), representing respectively the number of meals available for chicken, beef and pasta. The second line contains three integers \\(C_{r}, B_{r}\\) and \\(P_{r} (0 \\leq C_{r}, B_{r}, P_{r} \\leq 100)\\), indicating respectively the number of meals requested for chicken, beef and pasta.   출력   Output a single line with an integer representing the number of passengers that will surely not receive their selection for a meal.   예제 입력 1   80 20 40 45 23 48   예제 출력 1   11   예제 입력 2   0 0 0 100 100 100   예제 출력 2   300   예제 입력 3   41 42 43 41 42 43   예제 출력 3   0       코드   #include &lt;bits/stdc++.h&gt;  using namespace std;  int main(void) {     int i[3], j[3];     int res=0;      for(int k=0; k&lt;3; k++) cin&gt;&gt;i[k];     for(int k=0; k&lt;3; k++) cin&gt;&gt;j[k];     for(int k=0; k&lt;3; k++) if(i[k] &lt; j[k]) res += (j[k] - i[k]);      cout&lt;&lt;res;      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-69/",
        "teaser": null
      },{
        "title": "BOJ: 10926 ??!",
        "excerpt":"문제   준하는 사이트에 회원가입을 하다가 joonas라는 아이디가 이미 존재하는 것을 보고 놀랐다. 준하는 놀람을 ??!로 표현한다. 준하가 가입하려고 하는 사이트에 이미 존재하는 아이디가 주어졌을 때, 놀람을 표현하는 프로그램을 작성하시오.   입력   첫째 줄에 준하가 가입하려고 하는 사이트에 이미 존재하는 아이디가 주어진다. 아이디는 알파벳 소문자로만 이루어져 있으며, 길이는 50자를 넘지 않는다.   출력   첫째 줄에 준하의 놀람을 출력한다. 놀람은 아이디 뒤에 ??!를 붙여서 나타낸다.   예제 입력 1   joonas   예제 출력 1   joonas??!       코드   #include &lt;bits/stdc++.h&gt;  using namespace std;  int main(void) {     char ch[51];      cin&gt;&gt;ch;      cout&lt;&lt;ch&lt;&lt;\"\\?\\?!\";      return 0; }   Reference   BOJ  ","categories": ["Algorithms"],
        "tags": ["BOJ"],
        "url": "http://localhost:4000/algorithms/Studying-Algorithm-70/",
        "teaser": null
      }]
